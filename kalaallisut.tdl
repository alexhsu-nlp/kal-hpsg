;;; -*- Mode: TDL; Coding: utf-8 -*-
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Grammar of Kalaallisut
;;; created at:
;;;     Tue Feb 18 23:40:33 UTC 2025
;;; based on Matrix customization system version of:
;;;     Thu Jan 30 23:09:44 UTC 2025
;;;
;;; 
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Type assigning empty mod list. Added to basic types for nouns, verbs and determiners.

non-mod-lex-item := lex-item &
  [ SYNSEM.LOCAL.CAT.HEAD.MOD < > ]
"""`lex-item` with empty `HEAD.MOD`.""".

;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Matrix Type Addenda
;;;;;;;;;;;;;;;;;;;;;;;;;

basic-head-comp-phrase :+ [ SYNSEM [ LIGHT -,
             LOCAL.CAT.MC #mc ],
    HEAD-DTR.SYNSEM.LOCAL.CAT.MC #mc ].

head :+ [ PRON bool,
          POSSESSOR poss,
          SPEC-INIT bool,
          INIT bool, 
          NMZ bool, 
          MIN relation ].

; MIN_basic := avm.

noun-relation :+ noncard.

time-relation := noun-relation.

nontime-noun-relation := noun-relation.

named-relation :+ nontime-noun-relation.

+nd :+ [ CASE case ].

+nvjrp :+ [ INCORP luk, 
            DBT luk, 
            DUR luk ].

;;; Whether this verb is a participle referring back to the incorporated noun.
verb :+ [ REF bool ].

+rp :+ [ DBT na, 
         DUR na ].

; noun :+ [ TIME bool ].

;;;mod
;;; necessary flags:
;;; V_END-OR-V_END_NEG-FLAG (for general verb ending)
;;; HAB-FLAG (to avoid clashing with -ŋŋit)
;;; NEG_V_END_FLAG (to indicate whether the ending should be pos or neg)
;;; TRANS_ONLY_V-VERB-FLAG (to prevent it from entering null-htr-rule)
;;; INFL_QUES_N-NOUN-FLAG (prevents it from taking abs-lex-rule, although idk why this is necessary)
;;; PI_V-VERB-FLAG (to prevent it from taking a lot of rule, but forget why exactly)

;;; questionable:
;;; TI_NNIK_FLAG (hmm... or maybe not?)
;;; NULL_HTR-FLAG (many -'s, but I feel like this is just to flag that something is transitive, 
;;;     and that can be well replaced by null_htr-rule-dtr UNLESS something intervenes in between; 
;;;     but note the potential "cross-verbal" HTRs)
;;; TI_ANTIPASS-OR-NORMAL-OR-TRANS_CAUS_PASS-FLAG (can be represented by null_htr-rule-dtr, or may not)

;;; deletable flags (nothing required in DTR for selection and nothing negative to prevent infl-satisfied):
;;; TRANS_CLAUSE_VERB-OR-TRANS_CLAUSE_VERB_NEG-OR-V_END-OR-V_END_NEG-FLAG (can be represented by general v_end function)
;;; TRANS_CLAUSE_VERB_NEG-OR-TRANS_VERB_NEG-OR-V_END-OR-V_END_NEG-FLAG (same)
;;; [deleted]
;;; ANTIPASS-OR-PASS-OR-TRANS_CAUS_PASS-FLAG (no use)
;;; CLITIC_V-VERB-OR-INTRANS_V-VERB-FLAG (no use)
;;; CL_INTRANS_V-VERB-OR-CLITIC_V-VERB-FLAG (no use)
;;; CL_TRANS_V-VERB-FLAG (no use)
;;; NNIK_HTR-OR-TRANS_VALCHG-FLAG (no use)
;;; TI_HTR-FLAG (no use)
;;; ARG_CASE-FLAG luk (no use)
inflected :+ [ TRANS_ONLY_V-VERB-FLAG luk,
    V_END-OR-V_END_NEG-FLAG luk,
    ANTIPASS-OR-PASS-FLAG luk,
    SG_ABS_QUES_NOUN-NOUN-FLAG luk,
    TRANS_CLAUSE_VERB_NEG-OR-TRANS_VERB_NEG-OR-V_END-OR-V_END_NEG-FLAG luk,
    HAB-FLAG luk,
    TI_ANTIPASS-OR-NORMAL-OR-TRANS_CAUS_PASS-FLAG luk,
    TRANS_CLAUSE_VERB-OR-TRANS_CLAUSE_VERB_NEG-OR-V_END-OR-V_END_NEG-FLAG luk,
    TRANS_VALCHG-FLAG luk,
    CASE_ENDING-FLAG luk,
    NULL_HTR-FLAG luk,
    CL_Q_TRANS_V-VERB-OR-CL_TRANS_V-VERB-FLAG luk,
    INFL_QUES_N-NOUN-FLAG luk,
    PI_V-VERB-FLAG luk,
    NUM_CASE_END-FLAG luk,
    NUM_CASE-OR-POSS-FLAG luk,
    NUM_CASE-FLAG luk,
    TENSE-FLAG luk,
    NEG_V_END_FLAG luk, 
    TI_NNIK_FLAG luk,
    DEM_OBLIQUE-FLAG luk ].

infl-satisfied :+ [ TRANS_ONLY_V-VERB-FLAG na-or-+,
    V_END-OR-V_END_NEG-FLAG na-or-+,
    ANTIPASS-OR-PASS-FLAG na-or-+,
    SG_ABS_QUES_NOUN-NOUN-FLAG na-or-+,
    TRANS_CLAUSE_VERB_NEG-OR-TRANS_VERB_NEG-OR-V_END-OR-V_END_NEG-FLAG na-or-+,
    HAB-FLAG na-or-+,
    TI_ANTIPASS-OR-NORMAL-OR-TRANS_CAUS_PASS-FLAG na-or-+,
    TRANS_CLAUSE_VERB-OR-TRANS_CLAUSE_VERB_NEG-OR-V_END-OR-V_END_NEG-FLAG na-or-+,
    TRANS_VALCHG-FLAG na-or-+,
    CASE_ENDING-FLAG na-or-+,
    NULL_HTR-FLAG na-or-+,
    CL_Q_TRANS_V-VERB-OR-CL_TRANS_V-VERB-FLAG na-or-+,
    INFL_QUES_N-NOUN-FLAG na-or-+,
    PI_V-VERB-FLAG na-or-+,
    NUM_CASE_END-FLAG na-or-+,
    NUM_CASE-OR-POSS-FLAG na-or-+,
    NUM_CASE-FLAG na-or-+,
    TENSE-FLAG na-or-+ ].

png :+ [ PER person,
    NUM number ].

cat :+ [ POSSESSUM poss ].

poss := *top* &
  [ POSS-AGR png ].

basic-bare-np-phrase :+ [ SYNSEM.LOCAL.CAT [ VAL.SPEC < >,
                       HEAD #head,
                       POSSESSUM #possessum ],
    HEAD-DTR.SYNSEM.LOCAL.CAT [ HEAD #head,
                                POSSESSUM #possessum & nonpossessive ] ].

basic-head-1st-comp-phrase :+ [ SYNSEM.LOCAL.CAT.POSSESSUM #poss,
    HEAD-DTR.SYNSEM.LOCAL.CAT.POSSESSUM #poss ].

basic-determiner-lex :+ [ SYNSEM.LOCAL.CAT [ HEAD.POSSESSOR nonpossessive,
                       POSSESSUM nonpossessive ] ].

basic-head-opt-subj-phrase :+ [ HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS < > ].

top-coord-rule :+ [ SYNSEM.LOCAL.CAT [ HEAD.POSSESSOR #possessor,
                       POSSESSUM #possessum ],
    RCOORD-DTR.SYNSEM.LOCAL.CAT [ HEAD.POSSESSOR #possessor,
                                  POSSESSUM #possessum ],
    LCOORD-DTR.SYNSEM.LOCAL.CAT [ HEAD.POSSESSOR #possessor,
                                  POSSESSUM #possessum ] ].

bottom-coord-phrase :+ [ SYNSEM.LOCAL.CAT [ HEAD.POSSESSOR #possessor,
                       POSSESSUM #possessum ],
    NONCONJ-DTR.SYNSEM.LOCAL.CAT [ HEAD.POSSESSOR #possessor,
                                   POSSESSUM #possessum ] ].

basic-head-mod-phrase-simple :+ [ SYNSEM.LOCAL.CAT.MC #mc,
    HEAD-DTR.SYNSEM.LOCAL.CAT.MC #mc ].

;;; CCH 2025-11-16 temporary addition to fix the unreasonable modifying quotes given the current quote interpretation
basic-head-mod-phrase-simple :+ [ ARGS.FIRST.SYNSEM.PUNCT.RPUNCT non-quote-punct, 
                                  ARGS.REST.FIRST.SYNSEM.PUNCT.LPUNCT non-quote-punct ].

;basic-head-mod-phrase-simple :+ [ HEAD-DTR.SYNSEM.L-PERIPH #periph,
;    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.MOD < [ L-PERIPH #periph ] > ].

;;;;;;;;;;;;;;
;;; Features
;;;;;;;;;;;;;;

;;; Person

person := *top*.
1st+2nd+3rd := person.
2nd+3rd+4th := person.
1st+3rd+4th := person.
1st+2nd+4th := person.
1st+2nd := 1st+2nd+3rd & 1st+2nd+4th.
2nd+3rd := 1st+2nd+3rd & 2nd+3rd+4th.
1st+3rd := 1st+2nd+3rd & 1st+3rd+4th.
1st+4th := 1st+2nd+4th & 1st+3rd+4th.
2nd+4th := 1st+2nd+4th & 2nd+3rd+4th.
3rd+4th := 1st+3rd+4th & 2nd+3rd+4th.
1st := 1st+2nd & 1st+3rd & 1st+4th.
2nd := 1st+2nd & 2nd+3rd & 2nd+4th.
3rd := 1st+3rd & 2nd+3rd & 3rd+4th.
4th := 1st+4th & 2nd+4th & 3rd+4th
"""
Fourth persion in Kalaallisut is approximately the third person reflexive, but it may have some other usages.
This includes the impersonal sense for weathers and etc.
""".

;;; ICONS

;;neq-ref-ind-pair := info-str &
;;  [ IARG1 individual,
;;    IARG2 individual ].

;;; Number

number := *top*
"""Mother type of all the numbers (value of a PNG feature mostly related to noun indices).""".
sg := number
"""singular""".
pl := number
"""plural""".

;;; Possession

possession := *top*.
possessive := poss.  ; supertype for possessive features
nonpossessive := poss.  ; type for nonpossessive
possessor := possessive.
possessum := possessive.
possessive-1 := possessive.  ; supertype for strategy 1
possessor-1 := possessor & possessive-1.
possessum-1 := possessum & possessive-1.

;;; Possession

possessive-pron-1 := possessive.  ; supertype for strategy pron-1
possessor-pron-1 := possessor & possessive-pron-1.
possessum-pron-1 := possessum & possessive-pron-1.

;;; Case

case := *top*
"""The value type of HEAD feature in nouns and determiners.""".
no-case := case. ; to forbid attributive adjectives from getting subjects
real-case := case.  ; intermediate case type for all real cases
ins := real-case
"""The Kalaallisut instrumental case (e.g., -mik and -nik.)""".
abl+all+loc := real-case. ; space case.
abl := abl+all+loc
"""The Kalaallisut ablative case (e.g., -mit, which has a variant -miit, and -nit.)""".
all := abl+all+loc
"""The Kalaallisut allative case (e.g., -mut and -nut.)""".
loc := abl+all+loc
"""locative case""".
erg+abs := real-case
"""A case that is either ergative or absolutive.""".
erg := erg+abs
"""ergative case (common alias: relative)""".
abs := erg+abs
"""absolutive case""".
equ := real-case
"""equative case""".
via := real-case
"""vialis case (common alias: prosecutive)""".

;;; Tense

;;; CCH 2025-10-2 TODO: colors for lines of docstrings not started with """
nonfuture := tense
"""This tense is unmarked in Kalaallisut; there is no explicit morpheme for this tense, and the absence of a tense morpheme indicates that it is in nonfuture tense""".
future := tense
"""-ssa""".

;;; Aspect

perfective := aspect
"""-sima""".
habitual := aspect
"""-ðaq""".
;;; 2025-11-12 this is also temporary
continuative := aspect
"""-juaq""".
terminative := aspect
"""-yunnaaq. See: 
- Bogren Svensson, V. (2023). Manner Modifiers as SyntacticHeads. 
[Doctoral Thesis (monograph), Centre for Languages and Literature]. 
Centre for Languages and Literature, Lund University.""".
inceptive := aspect
"""Sometimes called inchoative. `-liq`""".
no-aspect := aspect.

;;; Mood

;;; 2025-04-01 TODO: how to solve the problem that 
;;; negative contemporative could be a matrix mood in imperatives?
;;; Probably I should add explicit MC constraints.
;;; NOTE: negative optative is also special (using -gi).

non-cntp-mood := mood.
matrix_mood+cntp := mood.
matrix_mood := matrix_mood+cntp & non-cntp-mood. 
subord_mood := mood
"""Subordinate moods. This includes moods in clausal modifiers and clausal complements.""".
imperative := matrix_mood.
optative := matrix_mood.
indic+inter := matrix_mood.
indicative := indic+inter.
interrogative := indic+inter.
causative := subord_mood & non-cntp-mood.
conditional := subord_mood & non-cntp-mood.
iterative := subord_mood & non-cntp-mood.
cl_comp_mood := subord_mood
"""Moods allowed in clausal complements.""".
contemporative := cl_comp_mood & matrix_mood+cntp.
participial := cl_comp_mood & non-cntp-mood.
no-mood := non-cntp-mood.

;;;;;;;;;;;;;;;;;;;
;;; Lexical Types
;;;;;;;;;;;;;;;;;;;

;;; Nouns

;;;mod   which_q_rel to wh_q_rel
wh-pronoun-noun-lex := basic-wh-word-lex & norm-hook-lex-item & basic-icons-lex-item & non-mod-lex-item & zero-arg-que &
  [ SYNSEM [ LOCAL [ CAT [ HEAD noun,
                           VAL [ SPR < >,
                                 SUBJ < >,
                                 COMPS < >,
                                 SPEC < > ] ],
                     CONT [ RELS.LIST < [ LBL #larg,
                                          ARG0 ref-ind & #arg0 ],
                                        quant-relation &
                                        [ PRED "wh_q_rel",
                                          ARG0 #arg0,
                                          RSTR #harg ] >,
                            HCONS.LIST < [ HARG #harg,
                                           LARG #larg ] > ] ],
             NON-LOCAL.QUE.LIST < #arg0 > ] ].

basic-name-lex := norm-sem-lex-item & basic-icons-lex-item &
  [ SYNSEM [ LOCAL.CAT.HEAD noun & [ MIN nontime-noun-relation, PRON - ],
             LKEYS.KEYREL named-relation ] ].

basic-hour-lex := norm-sem-lex-item & basic-icons-lex-item &
  [ SYNSEM [ LOCAL.CAT.HEAD noun & [ MIN time-relation, PRON - ],
             LKEYS.KEYREL hour-relation ] ].

hour-lex := basic-hour-lex & basic-non-wh-word-lex & non-local-none-lex-item & no-hcons-lex-item & non-mod-lex-item & num_case-rule-dtr &
  [ SYNSEM.LOCAL [ CONT.HOOK.INDEX.PNG.PER 3rd, 
                   CAT [ HEAD.CASE all, 
                         VAL [ SPR < >,
                               COMPS < >,
                               SUBJ < >,
                               SPEC < > ] ]],
    ARG-ST < >, 
    INFLECTED.NUM_CASE-OR-POSS-FLAG - ].

pl-hour-lex := hour-lex & 
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NUM pl ].

name-lex := basic-name-lex & basic-non-wh-word-lex & non-local-none-lex-item & no-hcons-lex-item & non-mod-lex-item & num_case-rule-dtr & noun_pred_affix-lex-rule-dtr & 
  [ SYNSEM.LOCAL.CAT.VAL [ SPR < >,
                           COMPS < >,
                           SUBJ < >,
                           SPEC < > ],
    ARG-ST < >, 
    INFLECTED.NUM_CASE-OR-POSS-FLAG - ]
"""Lexical entries for names. This includes person names and place names.""".

name-lex :+ [ SYNSEM.LOCAL.CONT.HOOK.INDEX [ PNG.PER 3rd, 
                                             COG-ST uniq-or-more, 
                                             SPECI + ] ].

pl-name-lex := name-lex & pl-norm-lex.

general-noun-lex := basic-noun-lex & basic-non-wh-word-lex & non-local-none-lex-item & no-hcons-lex-item & non-mod-lex-item &
  [ SYNSEM.LOCAL.CAT.VAL [ SPR < #spr &
                                 [ LOCAL.CAT.HEAD det ] >,
                           SUBJ < >,
                           SPEC < > ],
    ARG-ST < #spr > ].

noun-lex := general-noun-lex & [ SYNSEM.LOCAL.CAT.VAL.COMPS < > ].

arg1-noun-lex := general-noun-lex & 
  [ SYNSEM [ LKEYS.KEYREL noun-arg1-relation & [ ARG1 #ind ], 
             LOCAL.CAT.VAL.COMPS < [ LOCAL [ CAT [ HEAD noun & [ MOD < > ], 
                                                   VAL [ SPR < >, 
                                                         COMPS < >, 
                                                         SUBJ < > ] ], 
                                             CONT.HOOK.INDEX #ind ] ] > ] ]
"""The base type for relational nouns, where the noun relation contains an `ARG1` feature.""".

no-spr-noun-lex := noun-lex &
  [ SYNSEM.LOCAL.CAT.VAL.SPR < [ OPT + ] > ].

; Nouns which cannot take specifiers mark their SPR requirement
; as OPT +.  Making the non-head daughter OPT - in this rule
; keeps such nouns out.
; 
; Rules for building NPs.  Note that the Matrix uses SPR for
; the specifier of nouns and SUBJ for the subject (specifier) of verbs.

head-spec-phrase := basic-head-spec-phrase & head-initial &
  [ NON-HEAD-DTR.SYNSEM [ OPT -,
                          LOCAL.CAT [ VAL.SPEC < [ LOCAL.CAT.POSSESSUM #poss ] >,
                                      HEAD.SPEC-INIT - ] ],
    HEAD-DTR.SYNSEM.LOCAL.CAT [ POSSESSUM #poss,
                                VAL.COMPS < > ] ].

pron-noun-lex := no-spr-noun-lex &
  [ SYNSEM.LOCAL [ CONT.HOOK.INDEX [ COG-ST activ-or-more, 
                                     SPECI + ], 
                   CAT [ HEAD [ PRON +,
                              POSSESSOR nonpossessive ],
                       POSSESSUM nonpossessive ] ] ]
"""Mother lexical type of all pronoun stems.""".

pron-noun-lex :+ [ SYNSEM.NON-LOCAL [ CRF.LIST < >, CRF-H.LIST < > ] ].

;;; TODO: use ALTKEYREL!!!
;;; 2025-03-22 note that the *first* element of CONT.RELS is the KEYREL!
demonstr-pron-noun-lex := norm-ltop-lex-item & basic-icons-lex-item & non-mod-lex-item & basic-non-wh-word-lex & non-local-none-lex-item & no-hcons-lex-item & demonstr-pron-end-dtr &
  [ SYNSEM [ LOCAL [ CAT [ HEAD noun & [ PRON +, MIN nontime-noun-relation ],
                           VAL [ SPR < >,
                                 SUBJ < >,
                                 COMPS < >,
                                 SPEC < > ] ],
                     CONT [ HOOK.INDEX #n-arg, 
                            RELS.LIST < arg1-ev-relation &
                                        [ PRED demonstrative_a_rel,
                                          LBL #larg, 
                                          ARG1 #n-arg ], 
                                        noun-relation & 
                                        [ PRED "_entity_n_rel", 
                                          LBL #larg,
                                          ARG0 ref-ind & #n-arg & [ PNG.PER 3rd, 
                                                                    COG-ST activ+fam ] ]
                                         > ] ] ], 
    INFLECTED.NUM_CASE-OR-POSS-FLAG - ].

;;; 2025-09-29 CCH should we have something like _loc_p_rel?
;;; 2025-09-30 remove & [ PRON +, TIME - ] 
;;; (but to be added back, since we want _loc_p_rel to be handled by pp-phrase)
;;; NOTE: we will not assign _loc_p_rel etc. here, but in the case ending
demonstr-pron-adv-lex := norm-ltop-lex-item & basic-icons-lex-item & non-mod-lex-item & basic-non-wh-word-lex & non-local-none-lex-item & no-hcons-lex-item & demonstr-pron-adv-end-dtr & 
  [ SYNSEM [ LOCAL [ CAT [ HEAD noun & [ PRON +, MIN nontime-noun-relation ],
                           VAL [ SPR < >,
                                 SUBJ < >,
                                 COMPS < >,
                                 SPEC < > ] ],
                     CONT [ HOOK.INDEX #n-arg, 
                            RELS.LIST < arg1-ev-relation &
                                        [ PRED demonstrative_a_rel,
                                          LBL #larg, 
                                          ARG1 #n-arg ], 
                                        noun-relation & 
                                        [ PRED "_place_n_rel", 
                                          LBL #larg,
                                          ARG0 ref-ind & #n-arg & [ PNG.PER 3rd, 
                                                                    COG-ST activ+fam ] ]
                                         > ] ] ], 
    INFLECTED [ NUM_CASE-OR-POSS-FLAG - ] ]
"""Lexical type of demonstrative adverbs.""".

dem-pron-oblique-sg-dtr := word-or-lexrule
"""Demonstrative pronoun stems for *singular* number oblique cases.""".
dem-pron-oblique-pl-dtr := word-or-lexrule
"""Demonstrative pronoun stems for *plural* number oblique cases.""".
demonstr-pron-oblique-end-dtr := word-or-lexrule
"""Stems that can attach an oblique ending for demonstrative pronouns.""".

; 2025-10-02 why PNG.NUM sg? remove this first
demonstr-pron-gram-noun-lex := demonstr-pron-noun-lex & 
  [ ;SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NUM sg , 
    INFLECTED [ DEM_OBLIQUE-FLAG - ] ].
demonstr-pron-oblique-sg-noun-lex := demonstr-pron-noun-lex & dem-pron-oblique-sg-dtr & 
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NUM sg , 
    INFLECTED [ DEM_OBLIQUE-FLAG + ] ].
demonstr-pron-oblique-pl-noun-lex := demonstr-pron-noun-lex & dem-pron-oblique-pl-dtr & 
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NUM pl , 
    INFLECTED [ DEM_OBLIQUE-FLAG + ] ].

sg_pron-noun-lex := pron-noun-lex &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NUM sg ].

pl_pron-noun-lex := pron-noun-lex &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NUM pl ].

1sg_pron-noun-lex := sg_pron-noun-lex & 1p_pron-noun-lex & erg_abs_pron-noun-lex.

2sg_pron-noun-lex := sg_pron-noun-lex & 2p_pron-noun-lex & erg_abs_pron-noun-lex.

1pl_pron-noun-lex := pl_pron-noun-lex & 1p_pron-noun-lex & erg_abs_pron-noun-lex.

2pl_pron-noun-lex := pl_pron-noun-lex & 2p_pron-noun-lex & erg_abs_pron-noun-lex.

usual_common_n-noun-lex := common_n-noun-lex &
"""The most common type of nouns in Kalaallisut. They inflect for cases and both numbers."""
  [ SYNSEM.LOCAL.CAT [ HEAD [ POSSESSOR nonpossessive, 
                              MIN nontime-noun-relation ],
                       POSSESSUM nonpossessive ], 
    SYNSEM.LKEYS.KEYREL nontime-noun-relation ].

direction-noun-lex := usual_common_n-noun-lex & 
  [ SYNSEM.LOCAL [ CAT.HEAD.CASE abl+all+loc, 
                   CONT.HOOK.INDEX.PNG.NUM sg ] ].

;;; TODO: we want the complement of this type to be strong (i.e. before any **verbal** modifiers)
;;; it seems that it should also be before noun modifiers???
;;; Temporary idea: add a CAT (HEAD?) feature [ STRONG-COMP luk ].
rel-noun-lex := arg1-noun-lex & num_case-rule-dtr & noun_incorp-rule-dtr & poss-rule-dtr & noun_pred_affix-lex-rule-dtr &
  [ SYNSEM.LOCAL [ CAT [ HEAD.MIN nontime-noun-relation, 
                         VAL.COMPS.FIRST [ LOCAL.CAT.HEAD.CASE ins, 
                                           NON-LOCAL.CRF-H.LIST < > ] ], 
                   CONT.HOOK.INDEX.PNG.PER 3rd ],
    INFLECTED.NUM_CASE-OR-POSS-FLAG - ].

rel-noun-lex :+ [ SYNSEM.LOCAL.CAT [ HEAD.POSSESSOR nonpossessive,
                       POSSESSUM nonpossessive ] ].

1p_pron-noun-lex := pron-noun-lex &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.PER 1st ].

2p_pron-noun-lex := pron-noun-lex &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.PER 2nd ].

language-noun-lex := noun-lex & 
    [ SYNSEM.LOCAL [ CAT.HEAD [ CASE equ,
                                MIN nontime-noun-relation ], 
                     CONT.HOOK.INDEX.PNG [ PER 3rd, NUM sg ] ] ].

language-noun-lex :+ [ SYNSEM.NON-LOCAL [ CRF.LIST < >, CRF-H.LIST < > ] ].

time-noun-lex := common_n-noun-lex &
  [ SYNSEM [ LOCAL.CAT [ HEAD [ MIN time-relation, 
                              POSSESSOR nonpossessive ],
                       POSSESSUM nonpossessive ], 
             LKEYS.KEYREL time-relation ] ]
"""Lexical entry for temporal nouns, like `aucaq` (summer).""".

; usual_common_n-noun-lex :+ [ SYNSEM.LOCAL.CAT.HEAD.TIME - ].

pl-norm-lex := norm-sem-lex-item & 
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NUM pl ].

common_n-noun-lex := noun-lex & num_case-rule-dtr & noun_incorp-rule-dtr & poss-rule-dtr & noun_pred_affix-lex-rule-dtr &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.PER 3rd,
    INFLECTED.NUM_CASE-OR-POSS-FLAG - ].

pl_common_n-noun-lex := common_n-noun-lex & pl-norm-lex & 
  [ SYNSEM.LOCAL.CAT [ HEAD [ POSSESSOR nonpossessive, 
                              MIN nontime-noun-relation ],
                       POSSESSUM nonpossessive ] ]
"""
Common nouns that are always plural. 

A typical example is 'biilit' (car). When we say 'one car', it still takes a plural ending.
""".

; pl_common_n-noun-lex :+ [ SYNSEM.LOCAL.CAT.HEAD.TIME - ].
pl_common_n-noun-lex :+ [ SYNSEM.LOCAL.CAT.HEAD.MIN nontime-noun-relation ].

ques_n-noun-lex := wh-pronoun-noun-lex &
  [ SYNSEM.LOCAL [ CONT.HOOK.INDEX.PNG.PER 3rd,
                   CAT [ HEAD.POSSESSOR nonpossessive,
                         POSSESSUM nonpossessive ] ] ].

infl_ques_n-noun-lex := ques_n-noun-lex & num_case-rule-dtr & noun_incorp-rule-dtr & 
  [ INFLECTED [ NUM_CASE-FLAG -,
                INFL_QUES_N-NOUN-FLAG + ],
    SYNSEM.LOCAL.CAT [ HEAD.POSSESSOR nonpossessive,
                       POSSESSUM nonpossessive ] ].

erg_abs_pron-noun-lex := pron-noun-lex &
  [ SYNSEM.LOCAL.CAT.HEAD.CASE erg+abs ].

allat_pron-noun-lex := pron-noun-lex &
  [ SYNSEM.LOCAL.CAT.HEAD.CASE all ].

ins_pron-noun-lex := pron-noun-lex &
  [ SYNSEM.LOCAL.CAT.HEAD.CASE ins ].

1sg_allat_pron-noun-lex := sg_pron-noun-lex & 1p_pron-noun-lex & allat_pron-noun-lex.

2sg_allat_pron-noun-lex := sg_pron-noun-lex & 2p_pron-noun-lex & allat_pron-noun-lex.

abl_pron-noun-lex := no-spr-noun-lex &
  [ SYNSEM.LOCAL.CAT.HEAD.CASE abl ].

1sg_abl_pron-noun-lex := sg_pron-noun-lex & 1p_pron-noun-lex & abl_pron-noun-lex.

2sg_abl_pron-noun-lex := sg_pron-noun-lex & 2p_pron-noun-lex & abl_pron-noun-lex.

1sg_ins_pron-noun-lex := sg_pron-noun-lex & 1p_pron-noun-lex & ins_pron-noun-lex.

2sg_ins_pron-noun-lex := sg_pron-noun-lex & 2p_pron-noun-lex & ins_pron-noun-lex.

;;;mod
sg_abs_ques_noun-noun-lex := ques_n-noun-lex & noun_pred_affix-lex-rule-dtr &
  [ INFLECTED.SG_ABS_QUES_NOUN-NOUN-FLAG +,
      SYNSEM.LOCAL [ CONT.HOOK.INDEX.PNG.NUM sg,
                    CAT [ HEAD [ CASE abs,
                                 POSSESSOR nonpossessive, 
                                 MIN noncard ],
                          POSSESSUM nonpossessive ] ] ].

sg_abs_ques_noun-noun-lex :+ [ SYNSEM.NON-LOCAL [ CRF.LIST < >, CRF-H.LIST < > ] ].

pl_erg_abs_ques_noun-noun-lex := ques_n-noun-lex &
  [ SYNSEM.LOCAL [ CONT.HOOK.INDEX.PNG.NUM pl,
                   CAT [ HEAD [ CASE erg+abs,
                                POSSESSOR nonpossessive ],
                         POSSESSUM nonpossessive ] ] ].

pl_erg_abs_ques_noun-noun-lex :+ [ SYNSEM.NON-LOCAL [ CRF.LIST < >, CRF-H.LIST < > ] ].

;;; Verbs

verb-lex := basic-verb-lex & non-mod-lex-item & basic-non-wh-word-lex &
  [ SYNSEM.LOCAL [ CAT [VAL [ SPEC < >,
                              SUBJ < #subj > ],
                        HEAD.DBT - ],
                   CONT.HOOK.XARG #xarg ],
    ARG-ST.FIRST #subj &
                 [ LOCAL [ CAT cat-sat &
                               [ VAL [ SPR < >,
                                       COMPS < > ] ],
                           CONT.HOOK.INDEX #xarg ] ],
    INFLECTED [ TRANS_VALCHG-FLAG na-or--,
                NEG_V_END_FLAG na-or-- ] ].

intransitive-verb-lex := verb-lex & intransitive-lex-item &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS < >,
    ARG-ST < [ LOCAL.CAT.HEAD noun &
                              [ CASE real-case ] ] > ]
"""Inherently intransitive verbs in Kalaallisut. They usually take intransitive endings.""".

;;; 2025-03-25 abuse SPEC-INIT to be `+` (originally -) and delete it (due to enclitic verbs)
;;; Since its subject should be BEFORE the verb
;;; 2025-03-26 remove adundant cat-sat for second ARG-ST element

base-transitive-verb-lex := verb-lex & transitive-lex-item &
"""All transitive verbs **plus *tassa***."""
  [ ARG-ST < [ LOCAL.CAT.HEAD noun &
                              [ CASE real-case ] ],
             #comps &
             [ LOCAL.CAT [ VAL [ SPR < >,
                                 COMPS < > ],
                           HEAD noun &
                                [ CASE real-case ] ] ] >,
    SYNSEM.LOCAL.CAT.VAL.COMPS < #comps > ].

transitive-verb-lex := base-transitive-verb-lex &
  [ INFLECTED [ V_END-OR-V_END_NEG-FLAG -,
                TENSE-FLAG -,
                CL_Q_TRANS_V-VERB-OR-CL_TRANS_V-VERB-FLAG na-or-- ],
    SYNSEM.LOCAL.CAT.HEAD.INIT - ]
"""
Inherently transitive verbs in Kalaallisut. 
Most of them can take either transitive or intransitive endings, 
depending on whether there is a realized HTR morpheme.
""".

ditransitive-non-pp-verb-lex := verb-lex & ditransitive-lex-item & 
  [ SYNSEM.LOCAL.CAT [ VAL.COMPS < #comps-1, #comps-2 > ], 
    ARG-ST < [ LOCAL.CAT.HEAD noun &
                              [ CASE real-case ] ], 
             #comps-1 & [ LOCAL.CAT [ VAL [ SPR < >,
                                            COMPS < > ],
                                      HEAD noun & [ CASE real-case ] ] ], 
             #comps-2 & [ LOCAL.CAT [ VAL [ SPR < >,
                                            COMPS < > ],
                                      HEAD noun & [ CASE real-case ] ] ] > ].

ditransitive-pp-verb-lex := verb-lex & ditransitive-lex-item & 
  [ SYNSEM.LOCAL.CAT [ VAL.COMPS < #comps-1, #comps-2 > ], 
    ARG-ST < [ LOCAL.CAT.HEAD noun &
                              [ CASE real-case ] ], 
             #comps-1 & [ LOCAL.CAT [ VAL [ SPR < >,
                                            COMPS < > ],
                                      HEAD noun & [ CASE real-case ] ] ], 
             #comps-2 & [ LOCAL.CAT [ VAL [ SPR < >,
                                            COMPS < > ],
                                      HEAD noun & [ CASE real-case ] ] ] > ].

;;; NOTE: the real surface order is [ ERG, ABS, INS ]
;;erg-ins-abs-ditransitive-verb-lex := ditransitive-verb-lex & 
;;  [ ARG-ST < [ LOCAL.CAT.HEAD.CASE erg ],
;;             [ LOCAL.CAT.HEAD.CASE ins ], 
;;             [ LOCAL.CAT.HEAD.CASE abs ] > ].

;;; TODO: add HTRs
;;; iobj-abs dobj-ins V.
ditrans_v-verb-lex := ditransitive-non-pp-verb-lex & ditrans-null_htr-rule-dtr &
  [ SYNSEM.LOCAL.CAT [ HEAD.SPEC-INIT +, 
                       VAL [ COMPS.REST.FIRST #mark-obj, 
                             --KEYCOMP #mark-obj ] ],
    INFLECTED [ NULL_HTR-FLAG -,
                TENSE-FLAG -,
                V_END-OR-V_END_NEG-FLAG -,
                CL_Q_TRANS_V-VERB-OR-CL_TRANS_V-VERB-FLAG na-or--, 
                TI_NNIK_FLAG na-or-- ] ]
"""
Inherently ditransitive verbs in Kalaallisut. 

This type assumes that their instrumental-marking object takes the second position of `COMPS`.
""".

ditrans-pp-null_htr-rule-dtr := word-or-lexrule.

;;; dobj-all iobj-abs V.
ditrans_v-pp-verb-lex := ditransitive-pp-verb-lex & ditrans-pp-null_htr-rule-dtr &
  [ SYNSEM.LOCAL.CAT [ HEAD.SPEC-INIT +, 
                       VAL [ COMPS.FIRST #mark-obj, 
                             --KEYCOMP #mark-obj ] ],
    INFLECTED [ NULL_HTR-FLAG -,
                TENSE-FLAG -,
                V_END-OR-V_END_NEG-FLAG -,
                CL_Q_TRANS_V-VERB-OR-CL_TRANS_V-VERB-FLAG na-or--, 
                TI_NNIK_FLAG na-or-- ] ].

;;;mod   add type `clausal-second-arg-trans-lex-item`
;;;mod add MOD <>
clausal-verb-lex := verb-lex & clausal-second-arg-trans-lex-item &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS < #comps >,
    ARG-ST < [ LOCAL.CAT.HEAD noun ],
             #comps &
             [ LOCAL.CAT [ HEAD [ MOD < >, 
                                  DUR - ], 
                           MC na-or--,
                           VAL [ SPR < >,
                                 COMPS < >,
                                 SUBJ < > ] ] ] > ]
"""Verbs taking clausal complements.""".

clausal-verb-lex :+ [ SYNSEM.LOCAL.CAT.HEAD.SPEC-INIT + ].

clausal-verb-lex :+ [ SYNSEM.LOCAL.CAT.VAL.COMPS.FIRST.NON-LOCAL.CRF-H.LIST < > ].

abs-intransitive-verb-lex := intransitive-verb-lex &
  [ ARG-ST.FIRST.LOCAL.CAT.HEAD.CASE abs ]
"""Intransitive verbs taking absolutive case subjects.""".

erg-abs-transitive-verb-lex := transitive-verb-lex &
  [ ARG-ST < [ LOCAL.CAT.HEAD.CASE erg ],
             [ LOCAL.CAT.HEAD.CASE abs ] > ]
"""
Transitive verbs taking ergative case subjects and absolutive case objects.

Note that not all Kalaallisut transitive verbs behave in this way; for example, 
'-miippoq' takes an absolutive subject and a locative PP object.
""".

clausal-erg-verb-lex := clausal-verb-lex &
  [ ARG-ST.FIRST.LOCAL.CAT.HEAD.CASE erg ].

;;; TODO: maybe this should be changed to 0-1-list instead.
non-synsem := avm
"""To preclude an avm from taking a synsem type. Mainly used for `--KEYCOMP`.""".

;;; 2025-11-10 try: remove abs case (abs-intr => intr)
intrans_v-verb-lex := intransitive-verb-lex & modal-rule-dtr & aspect-rule-dtr & tense-rule-dtr & incorp-adv-rule-dtr &
  [ SYNSEM.LOCAL.CAT.VAL.--KEYCOMP non-synsem, 
    INFLECTED [ TENSE-FLAG -,
                V_END-OR-V_END_NEG-FLAG -,
                CL_Q_TRANS_V-VERB-OR-CL_TRANS_V-VERB-FLAG na-or--,
                TI_NNIK_FLAG na-or-- ] ].

;;; abuse --KEYCOMP to save the ditransitive case
;;; TODO: KEYCOMP must fail for valchg now. add it later.
;;; 2025-03-29 move --KEYCOMP identity to null_htr-lex-rule-super.
trans_v-verb-lex := transitive-verb-lex &
  [ SYNSEM.LOCAL.CAT [ HEAD.SPEC-INIT + ] ].

clausal_mood-lex-super := add-only-no-ccont-rule & const-lex-rule & modal-rule-dtr & aspect-rule-dtr & tense-rule-dtr & 
  [ INFLECTED #infl,
    DTR clausal_mood-rule-dtr & 
        [ INFLECTED #infl ] ].

clausal_cntp-lex-rule := clausal_mood-lex-super & [ SYNSEM.LOCAL.CAT.VAL.COMPS.FIRST.LOCAL.CONT.HOOK.INDEX.E.MOOD contemporative ].

clausal_part-lex-rule := clausal_mood-lex-super & [ SYNSEM.LOCAL.CAT.VAL.COMPS.FIRST.LOCAL.CONT.HOOK.INDEX.E.MOOD participial ].

clausal_cntp_1st_2nd_subj-lex-rule := clausal_cntp-lex-rule & 
  [ SYNSEM.LOCAL.CAT.VAL [ SUBJ.FIRST.LOCAL.CONT.HOOK.INDEX #xarg & [ PNG.PER 1st+2nd ],
			                     COMPS.FIRST.LOCAL.CONT.HOOK.XARG #xarg ] ].

clausal_cntp_3rd_4th_subj-lex-rule := clausal_cntp-lex-rule & 
  [ SYNSEM.LOCAL.CAT.VAL [ SUBJ.FIRST.LOCAL.CONT.HOOK.INDEX [ 
                                      COG-ST #cogst, 
                                      SPECI #speci, 
                                      PNG [ PER 3rd+4th, NUM #num ] ],
			                     COMPS < [ LOCAL.CONT.HOOK.XARG [ 
                                      COG-ST #cogst, 
                                      SPECI #speci, 
                                      PNG [ PER 4th, NUM #num] ] ] > ] ].

clausal_part_1st_subj-lex-rule := clausal_part-lex-rule &
  [ SYNSEM.LOCAL.CAT.VAL [ SUBJ.FIRST.LOCAL.CONT.HOOK.INDEX.PNG.PER 1st,
			                     COMPS.FIRST.LOCAL.CONT.HOOK.XARG.PNG.PER 2nd+3rd ] ].

clausal_part_2nd_subj-lex-rule := clausal_part-lex-rule &
  [ SYNSEM.LOCAL.CAT.VAL [ SUBJ.FIRST.LOCAL.CONT.HOOK.INDEX.PNG.PER 2nd,
			                     COMPS.FIRST.LOCAL.CONT.HOOK.XARG.PNG.PER 1st+3rd ] ].

clausal_part_3rd_4th_subj-lex-rule := clausal_part-lex-rule &
  [ SYNSEM.LOCAL.CAT.VAL [ SUBJ.FIRST.LOCAL.CONT.HOOK.INDEX.PNG.PER 3rd+4th,
			                     COMPS.FIRST.LOCAL.CONT.HOOK.XARG.PNG.PER 1st+2nd+3rd ] ].

;;;mod   del type `clausal-second-arg-trans-lex-item`
;;; TODO: I seem to have deleted something about QUE that should not get deleted. Need to get it back.
cl_intrans_v-verb-lex := clausal-verb-lex & clausal_mood-rule-dtr &
  [ INFLECTED [ TENSE-FLAG -,
                V_END-OR-V_END_NEG-FLAG -,
                CL_Q_TRANS_V-VERB-OR-CL_TRANS_V-VERB-FLAG na-or--, 
                TI_NNIK_FLAG na-or-- ],
    SYNSEM [ LOCAL.CAT [ VAL [ SUBJ.FIRST.LOCAL.CAT.HEAD.CASE abs,
                               COMPS < [ LOCAL [ CRF-UP.BOOL +,
                                                 CAT.HEAD verb,
                                                 CONT.HOOK.INDEX [ E.MOOD cl_comp_mood,
                                                                   SF prop ] ],
                                         NON-LOCAL.SLASH.LIST < >, 
                                         NON-LOCAL.CRF-H.LIST < > ] >, 
                               --KEYCOMP non-synsem ],
                         HEAD.INIT + ] ] ].

quote-verb-lex := verb-lex & clausal-second-arg-trans-lex-item &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS < #comps >,
    ARG-ST < [ LOCAL.CAT.HEAD noun ],
             #comps & root-synsem & [ PUNCT [ LPUNCT quote-punct, 
                                              RPUNCT quote-punct ], 
                                      OPT - ] > ]
"""Verbs taking quote.""".

;; remember ARG-ST order: subj, obj, clause (perfect!)
quote-trans-verb-lex := verb-lex & clausal-third-arg-ditrans-lex-item &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS < #comps-noun, #comps-clause >,
    ARG-ST < [ LOCAL.CAT.HEAD noun ],
             #comps-noun & [ LOCAL.CAT.HEAD noun ], 
             #comps-clause & root-synsem & [ PUNCT [ LPUNCT quote-punct, 
                                              RPUNCT quote-punct ], 
                                             OPT - ] > ].

;;; 2025-11-12 remove HEAD.INIT +, as we can typically quote things from either side.
;;; 2025-11-13 CCH TODO: in the word order "..." SUBJ VERB, we must have subj-head first and then "..." => separate rule?
quote-cl_intrans_v-verb-lex := quote-verb-lex & tense-rule-dtr & 
  [ INFLECTED [ TENSE-FLAG -,
                V_END-OR-V_END_NEG-FLAG -,
                CL_Q_TRANS_V-VERB-OR-CL_TRANS_V-VERB-FLAG na-or--, 
                TI_NNIK_FLAG na-or-- ],
    SYNSEM [ LOCAL.CAT.VAL [ SUBJ.FIRST.LOCAL.CAT.HEAD.CASE abs, 
                             --KEYCOMP non-synsem ] ] ].

;;; This has a true object
quote-cl_trans_v-verb-lex := quote-trans-verb-lex & tense-rule-dtr & 
  [ SYNSEM.LOCAL.CAT [ VAL [ SUBJ.FIRST.LOCAL.CAT.HEAD.CASE erg,
                             COMPS.FIRST #comps-noun & [ LOCAL.CAT.HEAD.CASE abs ], 
                             --KEYCOMP #comps-noun ] ],
    INFLECTED [ TENSE-FLAG -,
                TRANS_CLAUSE_VERB-OR-TRANS_CLAUSE_VERB_NEG-OR-V_END-OR-V_END_NEG-FLAG -,
                CL_Q_TRANS_V-VERB-OR-CL_TRANS_V-VERB-FLAG + ] ].

;;;2025-03-29
;;; hmm can I say --KEYCOMP here is synsem-min BUT it is NOT linked to the clause?
;;; but its HOOK.INDEX must be 3rd singular; then we don't need separate clausal verb endings
cl_trans_v-verb-lex := clausal-erg-verb-lex & clausal_mood-rule-dtr &
  [ SYNSEM.LOCAL.CAT [ VAL [ COMPS < [ LOCAL [ CAT.HEAD verb, CRF-UP.BOOL + ], 
                                       NON-LOCAL.SLASH.LIST < >, 
                                       NON-LOCAL.CRF-H.LIST < > ] >, 
                             --KEYCOMP synsem-min & [ LOCAL.CONT.HOOK.INDEX.PNG [ PER 3rd, NUM sg ] ] ],
                       HEAD.INIT + ],
    INFLECTED [ TENSE-FLAG -,
                TRANS_CLAUSE_VERB-OR-TRANS_CLAUSE_VERB_NEG-OR-V_END-OR-V_END_NEG-FLAG -,
                CL_Q_TRANS_V-VERB-OR-CL_TRANS_V-VERB-FLAG + ] ].

;;;mod   del type `clausal-second-arg-trans-lex-item`
cl_q_trans_v-verb-lex := clausal-erg-verb-lex & clausal_mood-rule-dtr &
  [ INFLECTED [ TENSE-FLAG -,
                TRANS_CLAUSE_VERB_NEG-OR-TRANS_VERB_NEG-OR-V_END-OR-V_END_NEG-FLAG -,
                CL_Q_TRANS_V-VERB-OR-CL_TRANS_V-VERB-FLAG + ],
    SYNSEM.LOCAL.CAT [ VAL [ COMPS < [ LOCAL [ CAT.HEAD verb & [ DBT + ],
                                             CONT.HOOK.INDEX [ E.MOOD cl_comp_mood,
                                                               SF ques ], 
                                               CRF-UP.BOOL + ], 
                                     NON-LOCAL.SLASH.LIST < >, 
                                     NON-LOCAL.CRF-H.LIST < > ] >, 
                             --KEYCOMP synsem-min & [ LOCAL.CONT.HOOK.INDEX.PNG [ PER 3rd, NUM sg ] ] ],
                       HEAD.INIT + ] ].

nonpatient_p_v-verb-lex := trans_v-verb-lex & null_htr-rule-dtr & pass-rule-dtr & null_antipass-rule-dtr & 
  [ INFLECTED [ NULL_HTR-FLAG -,
                TENSE-FLAG -,
                V_END-OR-V_END_NEG-FLAG -,
                CL_Q_TRANS_V-VERB-OR-CL_TRANS_V-VERB-FLAG na-or--, 
                TI_NNIK_FLAG na-or-- ] ].



patient_p_v-verb-lex := trans_v-verb-lex & pass-rule-dtr & null_htr-rule-dtr &
  [ INFLECTED [ CL_Q_TRANS_V-VERB-OR-CL_TRANS_V-VERB-FLAG na-or--, 
                TI_NNIK_FLAG + ] ].

ti_htr_v-verb-lex := patient_p_v-verb-lex & ti_antipass-rule-dtr & trans_valchg-rule-dtr &
  [ INFLECTED [ TENSE-FLAG -,
                V_END-OR-V_END_NEG-FLAG -,
                CL_Q_TRANS_V-VERB-OR-CL_TRANS_V-VERB-FLAG na-or-- ] ].

nnik_htr_v-verb-lex := patient_p_v-verb-lex & trans_valchg-rule-dtr & nnik_antipass-rule-dtr & 
  [ INFLECTED [ TENSE-FLAG -,
                V_END-OR-V_END_NEG-FLAG -,
                CL_Q_TRANS_V-VERB-OR-CL_TRANS_V-VERB-FLAG na-or-- ] ].

nonagent_p_v-verb-lex := patient_p_v-verb-lex & patient-pass-lex-rule-dtr.
both_p_v-verb-lex := patient_p_v-verb-lex & both_p_reflex-lex-rule-dtr.
ti_htr_nonagent_p_v-verb-lex := nonagent_p_v-verb-lex & ti_htr_v-verb-lex.
nnik_htr_nonagent_p_v-verb-lex := nonagent_p_v-verb-lex & nnik_htr_v-verb-lex.
ti_htr_both_p_v-verb-lex := both_p_v-verb-lex & ti_htr_v-verb-lex.
nnik_htr_both_p_v-verb-lex := both_p_v-verb-lex & nnik_htr_v-verb-lex.

;;; 2025-11-15 rename pi_v-verb-lex to better match its real intention
ins-obj-verb-lex := trans_v-verb-lex & null_htr-rule-dtr & null_antipass-rule-dtr & 
  [ INFLECTED [ NULL_HTR-FLAG -,
                TENSE-FLAG -,
                V_END-OR-V_END_NEG-FLAG -,
                CL_Q_TRANS_V-VERB-OR-CL_TRANS_V-VERB-FLAG na-or--,
                PI_V-VERB-FLAG +, 
                TI_NNIK_FLAG na-or-- ] ].

post-obj-verb-lex := base-transitive-verb-lex & null_htr-rule-dtr & pass-rule-dtr & 
  [ SYNSEM.LOCAL.CAT [ HEAD [ INIT -, SPEC-INIT + ] ], 
    INFLECTED [ NULL_HTR-FLAG -,
                TENSE-FLAG -,
                V_END-OR-V_END_NEG-FLAG -,
                CL_Q_TRANS_V-VERB-OR-CL_TRANS_V-VERB-FLAG na-or--,
                TRANS_ONLY_V-VERB-FLAG +, 
                TI_NNIK_FLAG na-or--, 
                V_END-OR-V_END_NEG-FLAG -,
                TENSE-FLAG -,
                CL_Q_TRANS_V-VERB-OR-CL_TRANS_V-VERB-FLAG na-or-- ] ].

trans_only_v-verb-lex := trans_v-verb-lex & null_htr-rule-dtr & pass-rule-dtr & trans_valchg-rule-dtr & 
  [ INFLECTED [ NULL_HTR-FLAG -,
                TENSE-FLAG -,
                V_END-OR-V_END_NEG-FLAG -,
                CL_Q_TRANS_V-VERB-OR-CL_TRANS_V-VERB-FLAG na-or--,
                TRANS_ONLY_V-VERB-FLAG +, 
                TI_NNIK_FLAG na-or-- ] ].

;;; TODO: remove CASE for participles
clitic_v-verb-lex := transitive-verb-lex & clitic-active-rule-dtr & null_htr-rule-dtr &
  [ SYNSEM.LOCAL.CAT.VAL [ COMPS.FIRST [ OPT -, 
                                         NON-LOCAL.CRF-H.LIST < > ], 
                           --KEYCOMP non-synsem ],
    INFLECTED [ TENSE-FLAG -,
                TI_NNIK_FLAG na-or-- ] ].

clitic_loc_v-verb-lex := clitic_v-verb-lex & 
 [ SYNSEM.LOCAL.CAT.VAL.COMPS.FIRST.LOCAL.CAT.HEAD.CASE loc ].

clitic_all_v-verb-lex := clitic_v-verb-lex & 
 [ SYNSEM.LOCAL.CAT.VAL.COMPS.FIRST.LOCAL.CAT.HEAD.CASE all ].

;;; 2025-03-10 remove event constraint
;;;basic-head-opt-comp-phrase :+ [ HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX event ].

basic-head-opt-comp-phrase :+ 
  [ SYNSEM.LOCAL.CAT [ POSSESSUM #possessum, 
                       VAL.--KEYCOMP #keycomp ], 
    HEAD-DTR.SYNSEM.LOCAL.CAT [ POSSESSUM #possessum, 
                                VAL.--KEYCOMP #keycomp ] ].

no-obj-drop-verb-lex := transitive-verb-lex &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS.FIRST.OPT - ].

obj-drop-verb-lex := transitive-verb-lex.

;;; Adjectives

;;;mod   add `non-local-none`
base-adj-lex := base-intersect-adj-lex & 
  [ SYNSEM [ LOCAL.CAT.VAL.--KEYCOMP non-synsem, 
             NON-LOCAL non-local-none ] ].

adj-lex := basic-intersective-adjective-lex & base-adj-lex.

base-basic-adj-lex :+ [ SYNSEM.NON-LOCAL [ CRF.LIST < >, CRF-H.LIST < > ] ].  

; basic-numeral-lex := norm-sem-lex-item &
;   [ SYNSEM [ LOCAL [ CAT [ HEAD adj,
;                            VAL [ COMPS < >,
;                                  SPEC < >,
;                                  SPR < > ] ] ] ] ].

; basic-intersective-adjective-lex := basic-numeral-lex &
;   [ SYNSEM [ LOCAL.CONT.HOOK.XARG ref-ind & #xarg,
;              LKEYS.KEYREL.ARG1 #xarg ] ].

base-numeral-adj-lex := base-attr-only-adj-lex & 
  [ SYNSEM [ LOCAL.CAT.VAL.SPR < >,
             LKEYS.KEYREL card ] ]
"""
Basic type of numerals that can only act as attributive modifiers.

Note that they do not claim an event relation -- type of their ARG0 is underspecified.
It will be specified as event as attributive adjectives, but as entities as numeral nouns.
""". 

numeral-adj-lex := base-numeral-adj-lex & num_case_end-rule-dtr & 
  [ INFLECTED.NUM_CASE_END-FLAG - ].

;;; CCH 2025-10-03
;;; ERG gets around of this event-index problem by stating ARG0 of numerals as only event-or-index, 
;;; But my analysis was event. Should I let the grammar decide this? [temporarily relaxed]
;;; TODO: this is WRONG. cannot be supported by noun incorporation. maybe need a lex-rule.
;;; CCH 2025-11-14 add the constraint that it cannot be possessed or possessing
numeral-noun-phrase := unary-phrase & 
  [ SYNSEM [ LOCAL [ CAT [ HEAD noun & [ MOD < >, 
                                         CASE #case, 
                                         INCORP -, 
                                         MIN card, 
                                         POSSESSOR nonpossessive ], 
                           VAL [ SUBJ < >, 
                                 COMPS < >, 
                                 SPEC < >, 
                                 SPR < [ LOCAL.CAT.HEAD det ] > ], 
                           POSSESSUM nonpossessive ],
                     CONT.HOOK #hook & [ INDEX ref-ind & [ PNG [ PER 3rd, 
                                                                 NUM #num ] ], 
                                         XARG.PNG.NUM #num ] ],
             NON-LOCAL #non-local & [ CRF.LIST < >, CRF-H.LIST < > ] ], 
    C-CONT [ HCONS.LIST < >, 
             ICONS.LIST < >, 
             RELS.LIST < > ],
    ARGS.FIRST.SYNSEM [ LIGHT +, 
                        LOCAL [ CAT.HEAD adj & [ MOD.FIRST.LOCAL.CAT.HEAD.CASE #case, 
                                                 INCORP -, 
                                                 MIN card ], 
                                CONT.HOOK #hook, 
                                COORD - ], 
                        NON-LOCAL #non-local ] ].

;; looks like numbers will be nouns here
;;; 2025-11-12 TODO: we might need [ SPEC..CAT.SUBJ cons ] to avoid combining measure after subj-head. but is this safe? 
;;; it seems that we don't have SUBJ empty (attributive-only) adj-lex in Kalaallisut
;;; 2025-11-14 add [ ARGS.FIRST...CASE ins ].
;;; CCH 2025-11-16 the value of C-CONT.HOOK does not look correct, but sadly there has no good way of dealing with this
numeral-measure-phrase := unary-phrase & 
  [ SYNSEM [ LOCAL [ CAT [ HEAD adv & [ MOD < > ], 
                           VAL [ SUBJ < >, 
                                 COMPS < >, 
                                 SPR < >, 
                                 SPEC.FIRST.LOCAL [ CAT.HEAD adj, 
                                                    CONT.HOOK [ LTOP #ltop,
                                                                INDEX #idx, 
                                                                XARG #xarg ] ] ] ] ], 
             NON-LOCAL [ CRF.LIST < >, CRF-H.LIST < > ] ], 
    C-CONT [ HOOK [ LTOP #ltop, 
                    INDEX #idx, 
                    XARG #xarg ], 
             RELS.LIST < measure-relation & [ PRED "measure_rel",
                                              LBL #ltop, 
                                              ; ARG0 #meas-idx, 
                                              ARG1 #idx, 
                                              ARG2 #num-idx ] >, 
             HCONS.LIST < >, 
             ICONS.LIST < > ], 
    ARGS.FIRST.SYNSEM.LOCAL [ CAT [ HEAD noun & [ CASE ins, 
                                                  MIN card, 
                                                  INCORP -, 
                                                  MOD < > ], 
                                    VAL [ SUBJ < >, 
                                          COMPS < >, 
                                          SPR < > ] ], 
                              CONT.HOOK.INDEX #num-idx ] ].

;;; TODO: maybe better directly in relation ARG1?
;;; TODO: marluk-t does not exist; need marluk only
pl-numeral-adj-lex := numeral-adj-lex & 
  [ SYNSEM.LOCAL.CONT.HOOK.XARG.PNG.NUM pl ].

two-adj-lex := base-numeral-adj-lex & 
  [ SYNSEM.LOCAL [ CONT.HOOK.XARG.PNG.NUM pl, 
                   CAT.HEAD.MOD.FIRST.LOCAL.CAT.HEAD.CASE erg+abs ] ].

;;;mod PRD, attr-affix-dtr, flag
;;;TODO: raise v_neg to tense; get a tense-or-attr inflection flag
;;; 2025-11-02 CCH: add incorp-adv-rule-dtr, but that may introduce aspect in adjectives; is that expected?
;;; 2025-11-03 add aspect-rule-dtr due to qiia-liq-...
verby_adj-adj-lex := attr-adj-lex & stative-pred-adj-lex & tense-rule-dtr & aspect-rule-dtr & attr-affix-dtr & incorp-adv-rule-dtr & 
  [ SYNSEM.LOCAL.CAT.HEAD.PRD bool, 
    INFLECTED [ NUM_CASE_END-FLAG -, 
                NEG_V_END_FLAG na-or-- ] ]
"""Adjectives that can be directly used as predicates without adding additional affixes.""".

;;;mod PRD, flag
nouny_adj-adj-lex := attr-adj-lex & stative-pred-adj-lex & num_case_end-rule-dtr & 
  [ SYNSEM.LOCAL.CAT.HEAD.PRD bool, 
    INFLECTED [ NUM_CASE_END-FLAG -, 
                NEG_V_END_FLAG na-or-- ] ]
"""Nominal adjectives. They don't take nominal affixes, but require a copula -u as predicates.""".

common_verby_adj-adj-lex := verby_adj-adj-lex &
  [ INFLECTED.NUM_CASE_END-FLAG - ]
"""Adjectives taking -ðuq as their nominal affix.""".

suuq_verby_adj-adj-lex := verby_adj-adj-lex &
  [ INFLECTED.NUM_CASE_END-FLAG - ]
"""Adjectives taking -suuq as their nominal affix.""".

tu_verby_adj-adj-lex := verby_adj-adj-lex &
  [ INFLECTED.NUM_CASE_END-FLAG - ]
"""A special class of adjectives ending in -tu that directly takes verb endigns as predicates but needs the nominalization morpheme -uq instead.""".

; Basic attributive adjective definition

base-attr-adj-lex := base-intersect-adj-lex & intersective-mod-lex &
  [ SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CAT [ HEAD noun,
                                              VAL.SPR cons ] ] > ]
"""Adjectives that can be used as NP modifiers.""".

attr-adj-lex := base-attr-adj-lex & adj-lex.


base-attr-only-adj-lex := base-attr-adj-lex &
  [ SYNSEM.LOCAL.CAT [ HEAD.PRD -,
                       VAL.SUBJ < > ] ]
"""
Adjectives that can *only* be used as NP modifiers.
A common case could be numerals (if we don't intend to make them determiners); after copulas they look more like numerals.
""".

attr-only-adj-lex := attr-adj-lex & base-attr-only-adj-lex.

; Stative predicate adjective definition
;;;mod   adj predication should have CASE abs subject
;;; 2025-03-13 this might not be quite true. What about CAUSV constructions?
stative-pred-adj-lex := adj-lex &
  [ SYNSEM.LOCAL [ CAT [ VAL.SUBJ < [ LOCAL [ CAT.HEAD.CASE abs,
                                              CONT.HOOK [ INDEX #xarg, 
                                                          ICONS-KEY.IARG1 #e, 
                                                          CLAUSE-KEY #e],
                                              CAT [ VAL [ SPR < >,
                                                          COMPS < > ],
                                                    HEAD noun ] ] ] >,
                         HEAD [ DBT -, DUR - ] ],
                   CONT.HOOK [ XARG #xarg, INDEX #e ] ] ]
"""Adjectives that can be used as sentential predicates.""".

;;; Complementizers

;;; Others

;;; Determiners
;;; SPEC is non-empty, and already specified by basic-determiner-lex.

determiner-lex := basic-determiner-lex & basic-non-wh-word-lex & norm-zero-arg & non-mod-lex-item &
  [ SYNSEM.LOCAL.CAT [ VAL [ SPR < >,
                             COMPS < >,
                             SUBJ < > ],
                       HEAD [ SPEC-INIT -,
                              INIT - ] ] ].

wh-determiner-lex := basic-wh-word-lex & basic-determiner-lex & non-mod-lex-item & zero-arg-nonslash &
  [ SYNSEM [ LOCAL.CAT.VAL [ SPR < >,
                             SPEC.FIRST.LOCAL.CONT.HOOK.INDEX #arg0,
                             COMPS < >,
                             SUBJ < > ],
             NON-LOCAL.QUE.LIST < #arg0 > ] ].

wh-determiner-lex :+ [ SYNSEM.NON-LOCAL [ CRF.LIST < >, CRF-H.LIST < > ] ].

ques-determiner-lex := wh-determiner-lex & one-icons-lex-item &
  [ INFLECTED.CASE_ENDING-FLAG - ].

ques_sg_abs-determiner-lex := wh-determiner-lex & one-icons-lex-item &
  [ SYNSEM.LOCAL.CAT.VAL.SPEC.FIRST.LOCAL [ CAT.HEAD.CASE abs,
                                            CONT.HOOK.INDEX.PNG.NUM sg ] ].

;;; Adverbs

;;; From the Grammar Matrix
adverb-lex-item := nonscop-adverb-lex & 
  [ SYNSEM [ LOCAL [ CAT [ VAL [ SUBJ < >, 
                                 SPEC < >,
                                 SPR < >,
                                 COMPS < > ],
                           HEAD adv &
                              [ MOD < [ LOCAL [ CONT.HOOK [ INDEX #arg1, 
                                                            LTOP #ltop ] ] ] > ] ],
                     CONT [ RELS.LIST < [ LBL #ltop, 
                                          ARG0 event,
                                          ARG1 #arg1, 
                                          ARG2 #ind ],
                                        [ PRED #pred, 
                                          ARG0 #ind, 
                                          LBL #larg ],
                                        [ ARG0 #ind, 
                                          RSTR #harg ] >,
                          HOOK.LTOP #ltop,
                          HCONS.LIST < qeq & [ HARG #harg,
                                               LARG #larg ] > ] ],
              LKEYS.KEYREL [ PRED #pred, 
                             ARG0 ref-ind & #ind, 
                             LBL #ltop ] ] ].

wh-adverb-lex := basic-wh-word-lex & adverb-lex-item & zero-arg-que &
[ SYNSEM [ LOCAL.CAT [ HEAD.MOD.FIRST.LOCAL intersective-mod & [ CAT.HEAD +vj ], 
                       POSTHEAD - ], 
           LOCAL.CONT.RELS.LIST < [ PRED "generic_pp_rel" ],
                                  [ ARG0 #arg0 ], 
                                  quant-relation & [ PRED "wh_q_rel" ] >,
           NON-LOCAL [ QUE.LIST < #arg0 >, 
                       CRF.LIST < >, 
                       CRF-H.LIST < > ] ] ].

fut-wh-adverb-lex := wh-adverb-lex & [ SYNSEM.LOCAL.CAT.HEAD.MOD.FIRST.LOCAL.CONT.HOOK.INDEX.E.TENSE future ].

;;; TODO: immaqa does NOT seem to be intersective adverb!
int-adverb-lex := basic-int-adverb-lex & non-local-none-lex-item & 
  [ SYNSEM.LOCAL.CAT.VAL [ SPR < >, 
                           SUBJ < >,
                           COMPS < > ] ].

int-adverb-lex :+ [ SYNSEM.NON-LOCAL [ CRF.LIST < >, CRF-H.LIST < > ] ].

; int-wh-adverb-lex := basic-wh-word-lex & int-adverb-lex.

scope-adverb-lex := basic-scopal-adverb-lex & non-local-none-lex-item & 
  [ SYNSEM.LOCAL.CAT.VAL [ SPR < >, 
                           SUBJ < >,
                           COMPS < > ] ].

scope-adverb-lex :+ [ SYNSEM.NON-LOCAL [ CRF.LIST < >, CRF-H.LIST < > ] ].

;;; Fortescue Page 101: it cannot be an S modifier, but VP
;;;; 2025-10-27 add SPEC < >. but is that theoretically sound?
pred-only-adverb-lex := int-adverb-lex &
  [ SYNSEM.LOCAL.CAT [ HEAD.MOD < [ LOCAL.CAT [ HEAD +vj & [ PRD na-or-+ ], 
                                                VAL.SUBJ cons ] ] >,  
                       POSTHEAD -, 
                       VAL.SPEC < > ] ]
"""Adverbs that cannot modify S but only V or VP.""".

;;; 2025-11-12 also add SPEC < >.
pred-only-pre-comps-adverb-lex := scope-adverb-lex &
  [ SYNSEM.LOCAL.CAT [ HEAD.MOD < [ LOCAL.CAT [ HEAD +vj & [ PRD na-or-+ ], 
                                                VAL.COMPS < > ] ] >, 
                       POSTHEAD -, 
                       VAL.SPEC < > ] ].

sent-adverb-lex := scope-adverb-lex &
"""Sentential adverbs like aap (yes), suu (yes), nagga (no), qujanaq (thanks)"""
  [ SYNSEM.LOCAL.CAT [ HEAD.MOD < root-synsem >, 
                       POSTHEAD -, 
                       VAL.SPEC < > ] ].

;;;;;;;;;;;;;;;;;;;
;;; Lexical Rules
;;;;;;;;;;;;;;;;;;;

; Adjective Incorporation

adj_incorporation-lex-rule := add-only-rule &
  [ C-CONT [ RELS.LIST < arg1-ev-relation &
                         [ LBL #ltop,
                           ARG1 #index ] >,
             HOOK #hook ],
    DTR.SYNSEM.LOCAL [ CAT.HEAD noun,
                       CONT.HOOK #hook &
                                 [ LTOP #ltop,
                                   INDEX #index ] ] ]
"""Lexical rule for nominal stems which introduces an event relation for an adjective.""".

;;; Intermediate rule types

pass-rule-dtr := word-or-lexrule.
ditrans_pass-rule-dtr := word-or-lexrule.
null_antipass-rule-dtr := word-or-lexrule.
ti_antipass-rule-dtr := word-or-lexrule.
nnik_antipass-rule-dtr := word-or-lexrule.
noun_incorp-rule-dtr := word-or-lexrule.
adj_incorp-rule-dtr := word-or-lexrule.
v_neg-rule-dtr := word-or-lexrule.
;;;ti_htr-rule-dtr := word-or-lexrule.
aspect-rule-dtr := word-or-lexrule.
tense-rule-dtr := word-or-lexrule.
trans_valchg-rule-dtr := word-or-lexrule.
dub-rule-dtr := word-or-lexrule.
null_htr-rule-dtr := word-or-lexrule.
ditrans-null_htr-rule-dtr := word-or-lexrule.
num_case_end-rule-dtr := word-or-lexrule.
evid-rule-dtr := word-or-lexrule.
v_end-rule-dtr := word-or-lexrule.
num_case-rule-dtr := word-or-lexrule.
v_end_neg-rule-dtr := word-or-lexrule.
clausal_mood-rule-dtr := word-or-lexrule.
noun_pred_affix-lex-rule-dtr := word-or-lexrule.
;;;2025-09-27 `atorpoq`
patient-pass-lex-rule-dtr := word-or-lexrule.

;;; Lexical rule types

nonpossessive-lex-rule-1 := add-only-no-ccont-rule &
  [ SYNSEM.LOCAL.CAT [ HEAD noun & 
                              [ POSSESSOR nonpossessive ], 
                       POSSESSUM nonpossessive ] ].

adj_incorp-lex-rule-super := infl-lex-rule & adj_incorporation-lex-rule & num_case-rule-dtr & noun_incorp-rule-dtr & 
  [ INFLECTED #inflected, 
    DTR usual_common_n-noun-lex & [ INFLECTED #inflected ] ].

little-lex-rule := adj_incorp-lex-rule-super & 
  [ C-CONT.RELS.LIST.FIRST.PRED "_little_a_rel" ].

passuit-lex-rule := adj_incorp-lex-rule-super & 
  [ C-CONT.RELS.LIST.FIRST.PRED "_a+great+many_a_rel",
    SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NUM pl ].

big-lex-rule := adj_incorp-lex-rule-super & 
  [ C-CONT.RELS.LIST.FIRST.PRED "_big_a_rel" ].

new-lex-rule := adj_incorp-lex-rule-super & 
  [ C-CONT.RELS.LIST.FIRST.PRED "_new_a_rel" ].

real-lex-rule := adj_incorp-lex-rule-super & 
  [ C-CONT.RELS.LIST.FIRST.PRED "_real_a_rel" ].

;;; 2025-11-12
old-lex-rule := adj_incorp-lex-rule-super & 
  [ C-CONT.RELS.LIST.FIRST.PRED "_old_a_rel" ].

noun-intro-lex-rule := same-cat-lex-rule & same-non-local-lex-rule &
  [ C-CONT [ HOOK [ LTOP #larg, 
                    INDEX #new-ind ], 
             RELS.LIST < arg1-relation & 
                      [ LBL  #larg, 
                        ARG0 #new-ind & [ PNG.PER 3rd ] , 
                        ARG1 #ind ] >, 
             HCONS.LIST < >, 
             ICONS.LIST < > ], 
    DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #ind ].

noun-intro-lex-rule-super := infl-lex-rule & num_case-rule-dtr & 
  [ INFLECTED #infl, 
    DTR name-lex & [ INFLECTED #infl ] ].

;; TODO: this may not be quite correct, for sentences like `Jensenkkut Ebbelu ...`
kkuq-lex-rule := noun-intro-lex-rule-super & noun-intro-lex-rule &
  [ C-CONT.RELS.LIST.FIRST [ PRED "_kkut_n_rel", 
                             ARG0.PNG.NUM pl ] ].

miuq-lex-rule := noun-intro-lex-rule-super & noun-intro-lex-rule &
  [ C-CONT.RELS.LIST.FIRST.PRED "_inhabitant_of_n_rel" ].

num_case-lex-rule-super := add-only-no-ccont-rule & 
  [ INFLECTED [ NUM_CASE-OR-POSS-FLAG +,
                NUM_CASE-FLAG +,
                TRANS_ONLY_V-VERB-FLAG #trans_only_v-verb,
                V_END-OR-V_END_NEG-FLAG #v_end-or-v_end_neg,
                ANTIPASS-OR-PASS-FLAG #antipass-or-nnik_null_pass,
                SG_ABS_QUES_NOUN-NOUN-FLAG #sg_abs_ques_noun-noun,
                TRANS_CLAUSE_VERB_NEG-OR-TRANS_VERB_NEG-OR-V_END-OR-V_END_NEG-FLAG #trans_clause_verb_neg-or-trans_verb_neg-or-v_end-or-v_end_neg,
                HAB-FLAG #hab,
                TI_ANTIPASS-OR-NORMAL-OR-TRANS_CAUS_PASS-FLAG #ti_antipass-or-ti_normal-or-trans_caus_pass,
                TRANS_CLAUSE_VERB-OR-TRANS_CLAUSE_VERB_NEG-OR-V_END-OR-V_END_NEG-FLAG #trans_clause_verb-or-trans_clause_verb_neg-or-v_end-or-v_end_neg,
                TRANS_VALCHG-FLAG #trans_valchg,
                CASE_ENDING-FLAG #case_ending,
                NULL_HTR-FLAG #null_htr,
                CL_Q_TRANS_V-VERB-OR-CL_TRANS_V-VERB-FLAG #cl_q_trans_v-verb-or-cl_trans_v-verb,
                INFL_QUES_N-NOUN-FLAG #infl_ques_n-noun,
                PI_V-VERB-FLAG #pi_v-verb,
                NUM_CASE_END-FLAG #num_case_end,
                TENSE-FLAG #tense ],
    DTR num_case-rule-dtr &
        [ INFLECTED [ TRANS_ONLY_V-VERB-FLAG #trans_only_v-verb,
                      V_END-OR-V_END_NEG-FLAG #v_end-or-v_end_neg,
                      ANTIPASS-OR-PASS-FLAG #antipass-or-nnik_null_pass,
                      SG_ABS_QUES_NOUN-NOUN-FLAG #sg_abs_ques_noun-noun,
                      TRANS_CLAUSE_VERB_NEG-OR-TRANS_VERB_NEG-OR-V_END-OR-V_END_NEG-FLAG #trans_clause_verb_neg-or-trans_verb_neg-or-v_end-or-v_end_neg,
                      HAB-FLAG #hab,
                      TI_ANTIPASS-OR-NORMAL-OR-TRANS_CAUS_PASS-FLAG #ti_antipass-or-ti_normal-or-trans_caus_pass,
                      TRANS_CLAUSE_VERB-OR-TRANS_CLAUSE_VERB_NEG-OR-V_END-OR-V_END_NEG-FLAG #trans_clause_verb-or-trans_clause_verb_neg-or-v_end-or-v_end_neg,
                      TRANS_VALCHG-FLAG #trans_valchg,
                      CASE_ENDING-FLAG #case_ending,
                      NULL_HTR-FLAG #null_htr,
                      CL_Q_TRANS_V-VERB-OR-CL_TRANS_V-VERB-FLAG #cl_q_trans_v-verb-or-cl_trans_v-verb,
                      INFL_QUES_N-NOUN-FLAG #infl_ques_n-noun,
                      PI_V-VERB-FLAG #pi_v-verb,
                      NUM_CASE_END-FLAG #num_case_end,
                      TENSE-FLAG #tense ] ] ].

;;; 2025-11-15 relaex CRF-H.LIST < >
num_case-lex-rule-super :+ [ SYNSEM.NON-LOCAL [ CRF.LIST < > ] ].

;;;mod
pl-lex-rule := infl-lex-rule & num_case-lex-rule-super & nonpossessive-lex-rule-1 & 
  [ DTR.INFLECTED.SG_ABS_QUES_NOUN-NOUN-FLAG na,
    SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NUM pl ].

abs-lex-rule := num_case-lex-rule-super &
  [ DTR.INFLECTED.INFL_QUES_N-NOUN-FLAG na,
    SYNSEM.LOCAL.CAT.HEAD.CASE abs ].

abs+erg-lex-rule := infl-lex-rule & num_case-lex-rule-super &
  [ SYNSEM.LOCAL.CAT.HEAD.CASE erg+abs ].

erg-lex-rule := abs+erg-lex-rule & 
  [ SYNSEM.LOCAL.CAT.HEAD.CASE erg ].

;;;mod
sg-lex-rule := num_case-lex-rule-super & nonpossessive-lex-rule-1 & 
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NUM sg ].

instr-lex-rule := infl-lex-rule & num_case-lex-rule-super &
  [ SYNSEM.LOCAL.CAT.HEAD.CASE ins ].

abl-lex-rule := infl-lex-rule & num_case-lex-rule-super &
  [ SYNSEM.LOCAL.CAT.HEAD.CASE abl ].

loc-lex-rule := infl-lex-rule & num_case-lex-rule-super &
  [ SYNSEM.LOCAL.CAT.HEAD.CASE loc ].

via-lex-rule := infl-lex-rule & num_case-lex-rule-super &
  [ SYNSEM.LOCAL.CAT.HEAD.CASE via ].

equ-lex-rule := infl-lex-rule & num_case-lex-rule-super &
  [ SYNSEM.LOCAL.CAT.HEAD.CASE equ ].

;;;mod
all-lex-rule := infl-lex-rule & num_case-lex-rule-super &
  [ SYNSEM.LOCAL.CAT.HEAD.CASE all ].

sg_abs-lex-rule := abs-lex-rule & const-lex-rule & sg-lex-rule.

;sg_abs_part-lex-rule := abs-lex-rule & const-lex-rule & 
;  [ DTR abs-participle-lex-rule-super ].

sg_erg-lex-rule := erg-lex-rule & sg-lex-rule.

sg_ins-lex-rule := instr-lex-rule & sg-lex-rule.

pl_abs+erg-lex-rule := abs+erg-lex-rule & pl-lex-rule.

;;pl_erg-lex-rule := erg-lex-rule & pl-lex-rule.

pl_ins-lex-rule := instr-lex-rule & pl-lex-rule.

sg_abl-lex-rule := abl-lex-rule & sg-lex-rule.

pl_abl-lex-rule := abl-lex-rule & pl-lex-rule.

sg_loc-lex-rule := loc-lex-rule & sg-lex-rule.

pl_loc-lex-rule := loc-lex-rule & pl-lex-rule.

sg_all-lex-rule := all-lex-rule & sg-lex-rule.

pl_all-lex-rule := all-lex-rule & pl-lex-rule.

sg_via-lex-rule := via-lex-rule & sg-lex-rule.

pl_via-lex-rule := via-lex-rule & pl-lex-rule.

sg_equ-lex-rule := equ-lex-rule & sg-lex-rule.

poss-rule-dtr := word-or-lexrule.

poss-lex-rule-super := infl-lex-rule & same-non-local-lex-rule &
  [ INFLECTED [ NUM_CASE-OR-POSS-FLAG +,
                TRANS_ONLY_V-VERB-FLAG #trans_only_v-verb,
                V_END-OR-V_END_NEG-FLAG #v_end-or-v_end_neg,
                ANTIPASS-OR-PASS-FLAG #antipass-or-nnik_null_pass,
                SG_ABS_QUES_NOUN-NOUN-FLAG #sg_abs_ques_noun-noun,
                TRANS_CLAUSE_VERB_NEG-OR-TRANS_VERB_NEG-OR-V_END-OR-V_END_NEG-FLAG #trans_clause_verb_neg-or-trans_verb_neg-or-v_end-or-v_end_neg,
                HAB-FLAG #hab,
                TI_ANTIPASS-OR-NORMAL-OR-TRANS_CAUS_PASS-FLAG #ti_antipass-or-ti_normal-or-trans_caus_pass,
                TRANS_CLAUSE_VERB-OR-TRANS_CLAUSE_VERB_NEG-OR-V_END-OR-V_END_NEG-FLAG #trans_clause_verb-or-trans_clause_verb_neg-or-v_end-or-v_end_neg,
                TRANS_VALCHG-FLAG #trans_valchg,
                CASE_ENDING-FLAG #case_ending,
                NULL_HTR-FLAG #null_htr,
                CL_Q_TRANS_V-VERB-OR-CL_TRANS_V-VERB-FLAG #cl_q_trans_v-verb-or-cl_trans_v-verb,
                INFL_QUES_N-NOUN-FLAG #infl_ques_n-noun,
                PI_V-VERB-FLAG #pi_v-verb,
                NUM_CASE_END-FLAG #num_case_end,
                NUM_CASE-FLAG #num_case,
                TENSE-FLAG #tense ],
    DTR poss-rule-dtr &
        [ INFLECTED [ TRANS_ONLY_V-VERB-FLAG #trans_only_v-verb,
                      V_END-OR-V_END_NEG-FLAG #v_end-or-v_end_neg,
                      ANTIPASS-OR-PASS-FLAG #antipass-or-nnik_null_pass,
                      SG_ABS_QUES_NOUN-NOUN-FLAG #sg_abs_ques_noun-noun,
                      TRANS_CLAUSE_VERB_NEG-OR-TRANS_VERB_NEG-OR-V_END-OR-V_END_NEG-FLAG #trans_clause_verb_neg-or-trans_verb_neg-or-v_end-or-v_end_neg,
                      HAB-FLAG #hab,
                      TI_ANTIPASS-OR-NORMAL-OR-TRANS_CAUS_PASS-FLAG #ti_antipass-or-ti_normal-or-trans_caus_pass,
                      TRANS_CLAUSE_VERB-OR-TRANS_CLAUSE_VERB_NEG-OR-V_END-OR-V_END_NEG-FLAG #trans_clause_verb-or-trans_clause_verb_neg-or-v_end-or-v_end_neg,
                      TRANS_VALCHG-FLAG #trans_valchg,
                      CASE_ENDING-FLAG #case_ending,
                      NULL_HTR-FLAG #null_htr,
                      CL_Q_TRANS_V-VERB-OR-CL_TRANS_V-VERB-FLAG #cl_q_trans_v-verb-or-cl_trans_v-verb,
                      INFL_QUES_N-NOUN-FLAG #infl_ques_n-noun,
                      PI_V-VERB-FLAG #pi_v-verb,
                      NUM_CASE_END-FLAG #num_case_end,
                      NUM_CASE-FLAG #num_case,
                      TENSE-FLAG #tense ] ] ].

possessum-lex-rule-1 := cat-change-only-lex-rule &
  [ SYNSEM.LOCAL.CAT [ HEAD noun &
                            [ MOD < >,
                              POSSESSOR nonpossessive ],
                       POSSESSUM possessum-1,
                       VAL #val &
                           [ SPEC < >,
                             SPR < [ LOCAL.CAT [ VAL.SPR < >,
                                                 HEAD.POSSESSOR possessor-1 ] ] > ] ],
    C-CONT [ HCONS.LIST < >,
             ICONS.LIST < >,
             RELS.LIST < > ],
    DTR.SYNSEM.LOCAL.CAT [ POSSESSUM nonpossessive,
                           HEAD.PRON -,
                           VAL #val ] ].

;;; Feb 27, 2025: make a poss_pron-lex-rule supertype for all possessive pronoun affixes
poss_pron-lex-rule := poss-lex-rule-super & no-icons-lexrule & 
  [ SYNSEM.LOCAL.CAT [ HEAD #head,
                       VAL [ SPR < >,
                             SPEC #spec,
                             SUBJ #subj,
                             COMPS #comps ] ],
    C-CONT [ HOOK #hook,
             RELS.LIST < noun-relation &
                         [ PRED "pron_rel",
                           LBL #lbl2,
                           ARG0 #possessor &
                                [ COG-ST activ-or-more,
                                  SPECI + ] ],
                         quant-relation &
                         [ PRED "exist_q_rel",
                           ARG0 #possessum,
                           RSTR #harg ],
                         arg12-ev-relation &
                         [ PRED "poss_rel",
                           LBL #lbl,
                           ARG1 #possessum,
                           ARG2 #possessor ],
                         quant-relation &
                         [ PRED "exist_q_rel",
                           ARG0 #possessor,
                           RSTR #harg2 ] >,
             HCONS.LIST < qeq &
                          [ HARG #harg,
                            LARG #lbl ],
                          qeq &
                          [ HARG #harg2,
                            LARG #lbl2 ] > ],
    DTR.SYNSEM.LOCAL [ CAT [ HEAD #head &
                                  [ PRON - ],
                             VAL [ SPEC #spec,
                                   SUBJ #subj,
                                   COMPS #comps ] ],
                       CONT.HOOK #hook &
                                 [ INDEX #possessum &
                                         [ COG-ST activ-or-more ],
                                   LTOP #lbl ] ] ].

poss_pron-lex-rule :+ [ SYNSEM.NON-LOCAL.CRF-H.LIST < > ].

4p_poss_pron-lex-rule := poss_pron-lex-rule & 
 [ C-CONT.RELS.LIST.FIRST.ARG0 #index & [ PNG.PER 3rd+4th ], 
   SYNSEM.NON-LOCAL [ CRF.LIST < #index > ] ].

1p_poss_pron-lex-rule := poss_pron-lex-rule & 
 [ C-CONT.RELS.LIST.FIRST.ARG0.PNG.PER 1st , 
   SYNSEM.NON-LOCAL [ CRF.LIST < > ] ].

2p_poss_pron-lex-rule := poss_pron-lex-rule & 
 [ C-CONT.RELS.LIST.FIRST.ARG0.PNG.PER 2nd, 
   SYNSEM.NON-LOCAL [ CRF.LIST < > ] ].

3p_poss_pron-lex-rule := poss_pron-lex-rule & 
 [ C-CONT.RELS.LIST.FIRST.ARG0.PNG.PER 3rd, 
   SYNSEM.NON-LOCAL [ CRF.LIST < > ] ].

sg_poss_pron-lex-rule := poss_pron-lex-rule & 
 [ C-CONT.RELS.LIST.FIRST.ARG0.PNG.NUM sg ].

pl_poss_pron-lex-rule := poss_pron-lex-rule & 
 [ C-CONT.RELS.LIST.FIRST.ARG0.PNG.NUM pl ].

1sg_poss_pron-lex-rule := sg_poss_pron-lex-rule & 1p_poss_pron-lex-rule.

1pl_poss_pron-lex-rule := pl_poss_pron-lex-rule & 1p_poss_pron-lex-rule.

2sg_poss_pron-lex-rule := sg_poss_pron-lex-rule & 2p_poss_pron-lex-rule.

2pl_poss_pron-lex-rule := pl_poss_pron-lex-rule & 2p_poss_pron-lex-rule.

3sg_poss_pron-lex-rule := sg_poss_pron-lex-rule & 3p_poss_pron-lex-rule.

3pl_poss_pron-lex-rule := pl_poss_pron-lex-rule & 3p_poss_pron-lex-rule.

4sg_poss_pron-lex-rule := sg_poss_pron-lex-rule & 4p_poss_pron-lex-rule.

4pl_poss_pron-lex-rule := pl_poss_pron-lex-rule & 4p_poss_pron-lex-rule.

1sg_possessor-lex-rule := poss-lex-rule-super & possessum-lex-rule-1 &
  [ SYNSEM.LOCAL.CAT.POSSESSUM.POSS-AGR [ PER 1st,
                                          NUM sg ], 
    SYNSEM.NON-LOCAL [ CRF.LIST < >, CRF-H.LIST < > ] ].

1pl_possessor-lex-rule := poss-lex-rule-super & possessum-lex-rule-1 &
  [ SYNSEM.LOCAL.CAT.POSSESSUM.POSS-AGR [ PER 1st,
                                          NUM pl ], 
    SYNSEM.NON-LOCAL [ CRF.LIST < >, CRF-H.LIST < > ] ].

2sg_possessor-lex-rule := poss-lex-rule-super & possessum-lex-rule-1 &
  [ SYNSEM.LOCAL.CAT.POSSESSUM.POSS-AGR [ PER 2nd,
                                          NUM sg ], 
    SYNSEM.NON-LOCAL [ CRF.LIST < >, CRF-H.LIST < > ] ].

3sg_possessor-lex-rule := poss-lex-rule-super & possessum-lex-rule-1 &
  [ SYNSEM.LOCAL.CAT.POSSESSUM.POSS-AGR [ NUM sg,
                                          PER 3rd ], 
    SYNSEM.NON-LOCAL [ CRF.LIST < >, CRF-H.LIST < > ] ].

3pl_possessor-lex-rule := poss-lex-rule-super & possessum-lex-rule-1 &
  [ SYNSEM.LOCAL.CAT.POSSESSUM.POSS-AGR [ NUM pl,
                                          PER 3rd ], 
    SYNSEM.NON-LOCAL [ CRF.LIST < >, CRF-H.LIST < > ] ].

sg_possessum-lex-rule := poss-lex-rule-super &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NUM sg ].

pl_possessum-lex-rule := poss-lex-rule-super &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NUM pl ].

abs_case-lex-rule := poss-lex-rule-super &
  [ SYNSEM.LOCAL.CAT.HEAD.CASE abs ].

erg_case-lex-rule := poss-lex-rule-super &
  [ SYNSEM.LOCAL.CAT.HEAD.CASE erg ].

ins_case-lex-rule := poss-lex-rule-super &
  [ SYNSEM.LOCAL.CAT.HEAD.CASE ins ].

loc_case-lex-rule := poss-lex-rule-super &
  [ SYNSEM.LOCAL.CAT.HEAD.CASE loc ].

all_case-lex-rule := poss-lex-rule-super &
  [ SYNSEM.LOCAL.CAT.HEAD.CASE all ].

abl_case-lex-rule := poss-lex-rule-super &
  [ SYNSEM.LOCAL.CAT.HEAD.CASE abl ].

sg_loc_poss-lex-rule := loc_case-lex-rule & sg_possessum-lex-rule.

pl_loc_poss-lex-rule := loc_case-lex-rule & pl_possessum-lex-rule.

1sg_sg_abs-lex-rule := 1sg_possessor-lex-rule & sg_abs_poss-lex-rule.

sg_abs_poss-lex-rule := abs_case-lex-rule & sg_possessum-lex-rule.

sg_ins_poss-lex-rule := ins_case-lex-rule & sg_possessum-lex-rule.

pl_ins_poss-lex-rule := ins_case-lex-rule & pl_possessum-lex-rule.

sg_abl_poss-lex-rule := abl_case-lex-rule & sg_possessum-lex-rule.

1pl_sg_abs-lex-rule := 1pl_possessor-lex-rule & sg_abs_poss-lex-rule.

sg_erg_poss-lex-rule := erg_case-lex-rule & sg_possessum-lex-rule.

1pl_sg_erg-lex-rule := 1pl_possessor-lex-rule & sg_erg_poss-lex-rule.

1sg_sg_erg-lex-rule := 1sg_possessor-lex-rule & sg_erg_poss-lex-rule.

1pl_pron_sg_erg-lex-rule := 1pl_poss_pron-lex-rule & sg_erg_poss-lex-rule.

1pl_pron_sg_abs-lex-rule := 1pl_poss_pron-lex-rule & sg_abs_poss-lex-rule.

1pl_pron_sg_loc-lex-rule := 1pl_poss_pron-lex-rule & sg_loc_poss-lex-rule.

1sg_pron_sg_erg-lex-rule := 1sg_poss_pron-lex-rule & sg_erg_poss-lex-rule.

1sg_pron_sg_abs-lex-rule := 1sg_poss_pron-lex-rule & sg_abs_poss-lex-rule.

1sg_pron_sg_loc-lex-rule := 1sg_poss_pron-lex-rule & sg_loc_poss-lex-rule.

2sg_pron_sg_loc-lex-rule := 2sg_poss_pron-lex-rule & sg_loc_poss-lex-rule.

1pl_pron_pl_abs-lex-rule := 1pl_poss_pron-lex-rule & pl_abs_poss-lex-rule.

2sg_pron_sg_abs-lex-rule := 2sg_poss_pron-lex-rule & sg_abs_poss-lex-rule.

2sg_sg_abs-lex-rule := 2sg_possessor-lex-rule & sg_abs_poss-lex-rule.

pl_abs_poss-lex-rule := abs_case-lex-rule & pl_possessum-lex-rule.

3sg_pl_abs-lex-rule := 3sg_possessor-lex-rule & pl_abs_poss-lex-rule.

3sg_sg_abs-lex-rule := 3sg_possessor-lex-rule & sg_abs_poss-lex-rule.

3sg_sg_abl-lex-rule := 3sg_possessor-lex-rule & sg_abl_poss-lex-rule.

3sg_sg_ins-lex-rule := 3sg_possessor-lex-rule & sg_ins_poss-lex-rule.

3sg_sg_loc-lex-rule := 3sg_possessor-lex-rule & sg_loc_poss-lex-rule.

3pl_sg_loc-lex-rule := 3pl_possessor-lex-rule & sg_loc_poss-lex-rule.

3pl_pl_loc-lex-rule := 3pl_possessor-lex-rule & pl_loc_poss-lex-rule.

3pl_sg_abs-lex-rule := 3pl_possessor-lex-rule & sg_abs_poss-lex-rule.

3pl_sg_abl-lex-rule := 3pl_possessor-lex-rule & sg_abl_poss-lex-rule.

3pl_pron_sg_abs-lex-rule := 3pl_poss_pron-lex-rule & sg_abs_poss-lex-rule.

3pl_pron_pl_abs-lex-rule := 3pl_poss_pron-lex-rule & pl_abs_poss-lex-rule.

3sg_pron_sg_abs-lex-rule := 3sg_poss_pron-lex-rule & sg_abs_poss-lex-rule.

3sg_pron_pl_abs-lex-rule := 3sg_poss_pron-lex-rule & pl_abs_poss-lex-rule.

3sg_pron_sg_all-lex-rule := 3sg_poss_pron-lex-rule & sg_all_poss-lex-rule.

1sg_pl_abs-lex-rule := 1sg_possessor-lex-rule & pl_abs_poss-lex-rule.

1sg_pron_pl_abs-lex-rule := 1sg_poss_pron-lex-rule & pl_abs_poss-lex-rule.

3pl_pl_abs-lex-rule := 3pl_possessor-lex-rule & pl_abs_poss-lex-rule.

3sg_sg_erg-lex-rule := 3sg_possessor-lex-rule & sg_erg_poss-lex-rule.

3sg_pron_sg_erg-lex-rule := 3sg_poss_pron-lex-rule & sg_erg_poss-lex-rule.

4sg_pron_sg_loc-lex-rule := 4sg_poss_pron-lex-rule & sg_loc_poss-lex-rule.

4sg_pron_sg_abs-lex-rule := 4sg_poss_pron-lex-rule & sg_abs_poss-lex-rule.

4sg_pron_pl_abs-lex-rule := 4sg_poss_pron-lex-rule & pl_abs_poss-lex-rule.

4sg_pron_sg_erg-lex-rule := 4sg_poss_pron-lex-rule & sg_erg_poss-lex-rule.

4sg_pron_sg_all-lex-rule := 4sg_poss_pron-lex-rule & sg_all_poss-lex-rule.

4sg_pron_pl_all-lex-rule := 4sg_poss_pron-lex-rule & pl_all_poss-lex-rule.

4pl_pron_pl_ins-lex-rule := 4pl_poss_pron-lex-rule & pl_ins_poss-lex-rule.

4pl_pron_sg_abs-lex-rule := 4pl_poss_pron-lex-rule & sg_abs_poss-lex-rule.

sg_all_poss-lex-rule := all_case-lex-rule & sg_possessum-lex-rule.

pl_all_poss-lex-rule := all_case-lex-rule & pl_possessum-lex-rule.

3pl_sg_all-lex-rule := 3pl_possessor-lex-rule & sg_all_poss-lex-rule.

part_num_case-rule-dtr := word-or-lexrule.

part_num_case-lex-rule-super := cat-change-only-lex-rule & 
  [ INFLECTED [ NUM_CASE_END-FLAG +,
                TRANS_ONLY_V-VERB-FLAG #trans_only_v-verb,
                V_END-OR-V_END_NEG-FLAG #v_end-or-v_end_neg,
                ANTIPASS-OR-PASS-FLAG #antipass-or-nnik_null_pass,
                SG_ABS_QUES_NOUN-NOUN-FLAG #sg_abs_ques_noun-noun,
                TRANS_CLAUSE_VERB_NEG-OR-TRANS_VERB_NEG-OR-V_END-OR-V_END_NEG-FLAG #trans_clause_verb_neg-or-trans_verb_neg-or-v_end-or-v_end_neg,
                HAB-FLAG #hab,
                TI_ANTIPASS-OR-NORMAL-OR-TRANS_CAUS_PASS-FLAG #ti_antipass-or-ti_normal-or-trans_caus_pass,
                TRANS_CLAUSE_VERB-OR-TRANS_CLAUSE_VERB_NEG-OR-V_END-OR-V_END_NEG-FLAG #trans_clause_verb-or-trans_clause_verb_neg-or-v_end-or-v_end_neg,
                TRANS_VALCHG-FLAG #trans_valchg,
                CASE_ENDING-FLAG #case_ending,
                NULL_HTR-FLAG #null_htr,
                CL_Q_TRANS_V-VERB-OR-CL_TRANS_V-VERB-FLAG #cl_q_trans_v-verb-or-cl_trans_v-verb,
                INFL_QUES_N-NOUN-FLAG #infl_ques_n-noun,
                PI_V-VERB-FLAG #pi_v-verb,
                NUM_CASE-OR-POSS-FLAG #num_case-or-poss,
                NUM_CASE-FLAG #num_case,
                TENSE-FLAG #tense ],
    DTR [ INFLECTED [ TRANS_ONLY_V-VERB-FLAG #trans_only_v-verb,
                      V_END-OR-V_END_NEG-FLAG #v_end-or-v_end_neg,
                      ANTIPASS-OR-PASS-FLAG #antipass-or-nnik_null_pass,
                      SG_ABS_QUES_NOUN-NOUN-FLAG #sg_abs_ques_noun-noun,
                      TRANS_CLAUSE_VERB_NEG-OR-TRANS_VERB_NEG-OR-V_END-OR-V_END_NEG-FLAG #trans_clause_verb_neg-or-trans_verb_neg-or-v_end-or-v_end_neg,
                      HAB-FLAG #hab,
                      TI_ANTIPASS-OR-NORMAL-OR-TRANS_CAUS_PASS-FLAG #ti_antipass-or-ti_normal-or-trans_caus_pass,
                      TRANS_CLAUSE_VERB-OR-TRANS_CLAUSE_VERB_NEG-OR-V_END-OR-V_END_NEG-FLAG #trans_clause_verb-or-trans_clause_verb_neg-or-v_end-or-v_end_neg,
                      TRANS_VALCHG-FLAG #trans_valchg,
                      CASE_ENDING-FLAG #case_ending,
                      NULL_HTR-FLAG #null_htr,
                      CL_Q_TRANS_V-VERB-OR-CL_TRANS_V-VERB-FLAG #cl_q_trans_v-verb-or-cl_trans_v-verb,
                      INFL_QUES_N-NOUN-FLAG #infl_ques_n-noun,
                      PI_V-VERB-FLAG #pi_v-verb,
                      NUM_CASE-OR-POSS-FLAG #num_case-or-poss,
                      NUM_CASE-FLAG #num_case,
                      TENSE-FLAG #tense ] ] ].

;;; 2025-11-13 CCH
;;; TODO: this is temporary treatment, as -kcaq hasn't been added to the grammar
part-nonposs-lex-rule := same-cat-lex-rule & part_num_case-lex-rule-super & 
  [ DTR part_num_case-rule-dtr, 
    C-CONT.HOOK.INDEX.E.TENSE nonfuture ].

part-poss-lex-rule := part_num_case-lex-rule-super &
  [ SYNSEM.LOCAL.CAT [ HEAD noun &
                            [ MOD < >,
                              POSSESSOR nonpossessive ],
                       POSSESSUM possessum-1,
                       VAL [ SUBJ < >,
                             COMPS #comps, 
                             SPEC < >,
                             SPR < #subj & [ OPT +, LOCAL.CAT [ VAL.SPR < >,
                                                               HEAD.POSSESSOR possessor-1 ] ] > ] ],
    DTR part-poss-rule-dtr & [ SYNSEM.LOCAL.CAT [ POSSESSUM nonpossessive,
                                                  HEAD.PRON -,
                                                  VAL [ SUBJ < #subj >, 
                                                        COMPS #comps, 
                                                        SPR < >, 
                                                        SPEC < > ] ] ] ].

part-pl-lex-rule := infl-lex-rule & part_num_case-lex-rule-super & 
  [ SYNSEM.NON-LOCAL.SLASH.LIST.FIRST.CONT.HOOK.INDEX.PNG.NUM pl ].

part-sg-lex-rule := part_num_case-lex-rule-super & 
  [ SYNSEM.NON-LOCAL.SLASH.LIST.FIRST.CONT.HOOK.INDEX.PNG.NUM sg ].

part-abs-lex-rule := part_num_case-lex-rule-super & 
  [ SYNSEM.NON-LOCAL.SLASH.LIST.FIRST.CAT.HEAD.CASE abs ].

part-erg-lex-rule := part_num_case-lex-rule-super & 
  [ SYNSEM.NON-LOCAL.SLASH.LIST.FIRST.CAT.HEAD.CASE erg ].

part-all-lex-rule := part_num_case-lex-rule-super & 
  [ SYNSEM.NON-LOCAL.SLASH.LIST.FIRST.CAT.HEAD.CASE all ].

part-ins-lex-rule := part_num_case-lex-rule-super & 
  [ SYNSEM.NON-LOCAL.SLASH.LIST.FIRST.CAT.HEAD.CASE ins ].

part-sg-abs-lex-rule := const-lex-rule & part-sg-lex-rule & part-abs-lex-rule & part-nonposs-lex-rule.

part-sg-erg-lex-rule := infl-lex-rule & part-sg-lex-rule & part-erg-lex-rule & part-nonposs-lex-rule.

part-pl-abs-lex-rule := part-pl-lex-rule & part-abs-lex-rule & part-nonposs-lex-rule.

part-sg-all-lex-rule := infl-lex-rule & part-sg-lex-rule & part-all-lex-rule & part-nonposs-lex-rule.

part-sg-ins-lex-rule := infl-lex-rule & part-sg-lex-rule & part-ins-lex-rule & part-nonposs-lex-rule.

part-1sg-poss-sg-abs-lex-rule := infl-lex-rule & part-sg-lex-rule & part-abs-lex-rule & part-nonposs-lex-rule & 
  [ SYNSEM.LOCAL.CAT.VAL.SUBJ < [ LOCAL.CONT.HOOK.INDEX.PNG [ PER 1st, NUM sg ], 
                                  NON-LOCAL.CRF-H.LIST < > ] > ].

part-1sg-poss-sg-erg-lex-rule := infl-lex-rule & part-sg-lex-rule & part-erg-lex-rule & part-nonposs-lex-rule & 
  [ SYNSEM.LOCAL.CAT.VAL.SUBJ < [ LOCAL.CONT.HOOK.INDEX.PNG [ PER 1st, NUM sg ], 
                                  NON-LOCAL.CRF-H.LIST < > ] > ].

part-3sg-poss-pl-abs-lex-rule := part-pl-lex-rule & part-abs-lex-rule & part-nonposs-lex-rule & 
  [ SYNSEM.LOCAL.CAT.VAL.SUBJ < [ LOCAL.CONT.HOOK.INDEX.PNG [ PER 3rd, NUM sg ], 
                                  NON-LOCAL.CRF-H.LIST < > ] > ].

part-3sg-poss-sg-abs-lex-rule := infl-lex-rule & part-sg-lex-rule & part-abs-lex-rule & part-nonposs-lex-rule & 
  [ SYNSEM.LOCAL.CAT.VAL.SUBJ < [ LOCAL.CONT.HOOK.INDEX.PNG [ PER 3rd, NUM sg ], 
                                  NON-LOCAL.CRF-H.LIST < > ] > ].

;;;mod   1. HEAD.PRD na-or-+; 2. change NUM_CASE_END-FLAG for self and DTR
v_end-lex-rule-super := lex-rule & 
  [ INFLECTED [ V_END-OR-V_END_NEG-FLAG +,
                NEG_V_END_FLAG #nv, 
                TRANS_CLAUSE_VERB-OR-TRANS_CLAUSE_VERB_NEG-OR-V_END-OR-V_END_NEG-FLAG +,
                TRANS_CLAUSE_VERB_NEG-OR-TRANS_VERB_NEG-OR-V_END-OR-V_END_NEG-FLAG +,
                TRANS_ONLY_V-VERB-FLAG #trans_only_v-verb,
                ANTIPASS-OR-PASS-FLAG #antipass-or-nnik_null_pass,
                SG_ABS_QUES_NOUN-NOUN-FLAG #sg_abs_ques_noun-noun,
                HAB-FLAG #hab,
                TI_ANTIPASS-OR-NORMAL-OR-TRANS_CAUS_PASS-FLAG #ti_antipass-or-ti_normal-or-trans_caus_pass,
                TRANS_VALCHG-FLAG #trans_valchg,
                CASE_ENDING-FLAG #case_ending,
                NULL_HTR-FLAG #null_htr,
                CL_Q_TRANS_V-VERB-OR-CL_TRANS_V-VERB-FLAG #cl_q_trans_v-verb-or-cl_trans_v-verb,
                INFL_QUES_N-NOUN-FLAG #infl_ques_n-noun,
                PI_V-VERB-FLAG #pi_v-verb,
                NUM_CASE-OR-POSS-FLAG #num_case-or-poss,
                NUM_CASE-FLAG #num_case,
                TENSE-FLAG #tense ],
    DTR v_end-rule-dtr &
        [ INFLECTED [ NEG_V_END_FLAG #nv, 
                      TRANS_ONLY_V-VERB-FLAG #trans_only_v-verb,
                      ANTIPASS-OR-PASS-FLAG #antipass-or-nnik_null_pass,
                      SG_ABS_QUES_NOUN-NOUN-FLAG #sg_abs_ques_noun-noun,
                      HAB-FLAG #hab,
                      TI_ANTIPASS-OR-NORMAL-OR-TRANS_CAUS_PASS-FLAG #ti_antipass-or-ti_normal-or-trans_caus_pass,
                      TRANS_VALCHG-FLAG #trans_valchg,
                      CASE_ENDING-FLAG #case_ending,
                      NULL_HTR-FLAG #null_htr,
                      CL_Q_TRANS_V-VERB-OR-CL_TRANS_V-VERB-FLAG #cl_q_trans_v-verb-or-cl_trans_v-verb,
                      INFL_QUES_N-NOUN-FLAG #infl_ques_n-noun,
                      PI_V-VERB-FLAG #pi_v-verb,
                      NUM_CASE_END-FLAG luk,
                      NUM_CASE-OR-POSS-FLAG #num_case-or-poss,
                      NUM_CASE-FLAG #num_case,
                      TENSE-FLAG #tense & + ] ] ].

v_end-lex-rule-super :+ [ SYNSEM.NON-LOCAL [ CRF.LIST < >, CRF-H.LIST < > ] ].

v_end_neg-lex-rule := v_end-lex-rule-super & [ DTR.INFLECTED [ NEG_V_END_FLAG + ] ].

v_end_pos-lex-rule := v_end-lex-rule-super & [ DTR.INFLECTED [ NEG_V_END_FLAG - ] ].

intrans_verb-lex-rule := infl-lex-rule & v_end-lex-rule-super &
  [ SYNSEM.LOCAL.CAT [ HEAD.PRD na-or-+, 
                       VAL [ SUBJ.FIRST.LOCAL.CAT.HEAD.CASE abs,
                             --KEYCOMP non-synsem ] ], 
    INFLECTED.NUM_CASE_END-FLAG na ].

trans_verb-lex-rule := infl-lex-rule & v_end-lex-rule-super &
  [ SYNSEM.LOCAL.CAT [ HEAD.PRD na-or-+, 
                       VAL.--KEYCOMP.LOCAL.CAT.HEAD.CASE abs], 
    INFLECTED.NUM_CASE_END-FLAG na ].

;;; 2025-03-29 abandon this analysis and merge it into trans_verb-lex-rule
trans_clause_verb-lex-rule := infl-lex-rule & v_end-lex-rule-super &
  [ SYNSEM.LOCAL.CAT.HEAD.PRD na-or-+, 
    INFLECTED.NUM_CASE_END-FLAG na, 
    DTR.INFLECTED [ CL_Q_TRANS_V-VERB-OR-CL_TRANS_V-VERB-FLAG + ],
    INFLECTED.TRANS_CLAUSE_VERB-OR-TRANS_CLAUSE_VERB_NEG-OR-V_END-OR-V_END_NEG-FLAG + ].

participle-lex-rule := infl-lex-rule & part_num_case-rule-dtr & v_end-lex-rule-super & same-cont-lex-rule & same-ctxt-lex-rule & same-agr-lex-rule & same-spr-lex-rule & same-spec-lex-rule & same-modified-lex-rule & same-light-lex-rule & same-head-lex-rule & 
  [ SYNSEM [ LOCAL.CAT [ HEAD verb & [ PRD -, 
                                       REF -, 
                                       DUR - ] ], 
             NON-LOCAL [ QUE #que, 
                         REL #rel, 
                         CONJP #conjp ] ], 
    C-CONT.HOOK.INDEX [ SF prop, 
                        E.MOOD no-mood ], 
    INFLECTED [ NUM_CASE_END-FLAG - ], 
    DTR [ SYNSEM.NON-LOCAL [ QUE #que, 
                             REL #rel, 
                             CONJP #conjp ] ] ].

intrans_participle-lex-rule := participle-lex-rule & same-comps-lex-rule & no-ccont-lex-rule & 
  [ SYNSEM [ LOCAL.CAT.VAL [ SUBJ < >, 
                             --KEYCOMP non-synsem ], 
             NON-LOCAL.SLASH.LIST < #slash > ], 
    DTR [ SYNSEM.LOCAL.CAT.VAL [ SUBJ < gap & [ NON-LOCAL.SLASH.LIST < #slash > ] >, 
                                 --KEYCOMP non-synsem ] ] ].

part-poss-rule-dtr := word-or-lexrule.

patient_participle-lex-rule := participle-lex-rule & same-subj-lex-rule & part-poss-rule-dtr & no-ccont-lex-rule & 
  [ SYNSEM [ LOCAL.CAT.VAL [ SUBJ < [ LOCAL.CAT.HEAD.CASE erg ] >, 
                             COMPS < > ], 
             NON-LOCAL.SLASH.LIST < #slash > ], 
    DTR [ SYNSEM.LOCAL.CAT.VAL.COMPS < gap & [ NON-LOCAL.SLASH.LIST < #slash > ] > ] ].

;;; TODO: this sentence has unexpected identification of indices of speak and see: iglu uqaluk-f^fik-a taku-vara
pp_participle-lex-rule := participle-lex-rule & same-subj-lex-rule & same-comps-lex-rule & 
  [ SYNSEM [ LOCAL [ CAT.VAL [ SUBJ < [ LOCAL.CAT.HEAD.CASE erg ] >, 
                               --KEYCOMP non-synsem ] ], 
             NON-LOCAL.SLASH.LIST < [ CAT.HEAD noun, 
                                      CONT.HOOK [ LTOP #ltop, 
                                                  INDEX #n-ind ] ] > ], 
    C-CONT [ HOOK [ LTOP #ltop, 
                    INDEX #ev ], 
             RELS.LIST < arg12-ev-relation & [ PRED "unk_pp_rel", 
                                               LBL #ltop, 
                                               ARG1 #ev, 
                                               ARG2 #n-ind ] >, 
             HCONS.LIST < >, 
             ICONS.LIST < > ],
    DTR.SYNSEM.LOCAL.CAT.VAL.--KEYCOMP non-synsem ].

sg_obj_verb-lex-rule := infl-lex-rule & v_end-lex-rule-super &
  [ SYNSEM.LOCAL.CAT.VAL.--KEYCOMP.LOCAL.CONT.HOOK.INDEX.PNG.NUM sg ].

pl_obj_verb-lex-rule := infl-lex-rule & v_end-lex-rule-super &
  [ SYNSEM.LOCAL.CAT.VAL.--KEYCOMP.LOCAL.CONT.HOOK.INDEX.PNG.NUM pl ].

;;; 2025-11-13 add [DUR -] to fix -qaq-tət-vuq
;;; 2025-11-13 add SF constraint to prevent it from getting [ SF comm ], as it is the role of either optative or imperative.
neut-ind+int-mood-lex-rule := add-only-no-ccont-rule & infl-lex-rule & v_end-lex-rule-super & 
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX [ E.MOOD indic+inter, 
                                   SF prop-or-ques ], 
    DTR.SYNSEM.LOCAL.CAT.HEAD.DUR - ].

neut-ind_mood-lex-rule := neut-ind+int-mood-lex-rule &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX [ E.MOOD indicative, 
                                   SF prop ] ].

neut-imp_mood-lex-rule := add-only-no-ccont-rule & infl-lex-rule & v_end-lex-rule-super & 
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX [ E.MOOD imperative, 
                                   SF comm ] ].

;;;mod   add SF ques
neut-int_mood-lex-rule := neut-ind+int-mood-lex-rule &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX [E.MOOD interrogative, 
                                  SF ques] ].

neut-cntp_mood-lex-rule := infl-lex-rule & v_end-lex-rule-super &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.E.MOOD contemporative ].

part_mood-lex-rule := add-only-no-ccont-rule & infl-lex-rule & v_end-lex-rule-super &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.E.MOOD participial ].

neut-caus_mood-lex-rule := add-only-no-ccont-rule & infl-lex-rule & v_end-lex-rule-super &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.E.MOOD causative ].

iter_mood-lex-rule := add-only-no-ccont-rule & infl-lex-rule & v_end-lex-rule-super &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.E.MOOD iterative ].

ind+int-mood-lex-rule := neut-ind+int-mood-lex-rule & v_end_pos-lex-rule.

ind+int-mood_neg-lex-rule := neut-ind+int-mood-lex-rule & v_end_neg-lex-rule.

ind_mood-lex-rule := neut-ind_mood-lex-rule & v_end_pos-lex-rule.

ind_mood_neg-lex-rule := neut-ind_mood-lex-rule & v_end_neg-lex-rule.

int_mood-lex-rule := neut-int_mood-lex-rule & v_end_pos-lex-rule.

int_mood_neg-lex-rule := neut-int_mood-lex-rule & v_end_neg-lex-rule.

;;; 2025-11-12 CCH TODO: it seems that imperatives don't need tense affix but imply tense by themselvs, 
;;; so pos cls may need adjustment
imp_mood-lex-rule := neut-imp_mood-lex-rule & v_end_pos-lex-rule.

cntp_mood-lex-rule := add-only-no-ccont-rule & neut-cntp_mood-lex-rule & v_end_pos-lex-rule.

cntp_mood_neg-lex-rule := cont-change-only-lex-rule & neut-cntp_mood-lex-rule & v_end_pos-lex-rule & neg-add-lex-rule & 
  [ DTR.SYNSEM.LOCAL.CAT.HEAD.DBT - ].

caus_mood-lex-rule := neut-caus_mood-lex-rule & v_end_pos-lex-rule.

caus_mood_neg-lex-rule := neut-caus_mood-lex-rule & v_end_neg-lex-rule.

sg_subj_verb-lex-rule := infl-lex-rule & v_end-lex-rule-super &
  [ SYNSEM.LOCAL.CAT.VAL.SUBJ.FIRST.LOCAL.CONT.HOOK.INDEX.PNG.NUM sg ].

pl_subj_verb-lex-rule := infl-lex-rule & v_end-lex-rule-super &
  [ SYNSEM.LOCAL.CAT.VAL.SUBJ.FIRST.LOCAL.CONT.HOOK.INDEX.PNG.NUM pl ].

1p_subj_verb-lex-rule := infl-lex-rule & v_end-lex-rule-super &
  [ SYNSEM.LOCAL.CAT.VAL.SUBJ.FIRST.LOCAL.CONT.HOOK.INDEX.PNG.PER 1st, 
    SYNSEM.LOCAL.CAT.VAL.SUBJ.FIRST.NON-LOCAL.CRF-H.LIST < > ].

1p_obj_verb-lex-rule := infl-lex-rule & no-crf-obj-lex-rule &
  [ SYNSEM.LOCAL.CAT.VAL.--KEYCOMP.LOCAL.CONT.HOOK.INDEX.PNG.PER 1st ].

2p_subj_verb-lex-rule := infl-lex-rule & v_end-lex-rule-super &
  [ SYNSEM.LOCAL.CAT.VAL.SUBJ.FIRST.LOCAL.CONT.HOOK.INDEX.PNG.PER 2nd, 
    SYNSEM.LOCAL.CAT.VAL.SUBJ.FIRST.NON-LOCAL.CRF-H.LIST < > ].

2p_obj_verb-lex-rule := infl-lex-rule & no-crf-obj-lex-rule &
  [ SYNSEM.LOCAL.CAT.VAL.--KEYCOMP.LOCAL.CONT.HOOK.INDEX.PNG.PER 2nd ].

3p_subj_verb-lex-rule := infl-lex-rule & v_end-lex-rule-super &
  [ SYNSEM.LOCAL.CAT.VAL.SUBJ.FIRST.LOCAL.CONT.HOOK.INDEX.PNG.PER 3rd, 
    SYNSEM.LOCAL.CAT.VAL.SUBJ.FIRST.NON-LOCAL.CRF-H.LIST < > ].

3p_obj_verb-lex-rule := infl-lex-rule & no-crf-obj-lex-rule &
  [ SYNSEM.LOCAL.CAT.VAL.--KEYCOMP.LOCAL.CONT.HOOK.INDEX.PNG.PER 3rd, 
    SYNSEM.LOCAL.CAT.VAL.--KEYCOMP.NON-LOCAL.CRF-H.LIST < > ].

no-crf-obj-lex-rule := v_end-lex-rule-super &
  [ SYNSEM.LOCAL.CAT.VAL.--KEYCOMP.NON-LOCAL.CRF-H.LIST < > ].

;4p_obj_verb-lex-rule := infl-lex-rule & v_end-lex-rule-super &
;  [ SYNSEM.LOCAL.CAT.VAL.--KEYCOMP.LOCAL.CONT.HOOK.INDEX.PNG.PER 4th ].

4p_obj_verb-lex-rule := infl-lex-rule & v_end-lex-rule-super &
  [ SYNSEM.LOCAL.CAT.VAL.--KEYCOMP [ LOCAL.CONT.HOOK.INDEX #index & [ PNG.PER 3rd+4th ], 
                                     NON-LOCAL.CRF-H.LIST < #index > ] ].

;4p_subj_verb-lex-rule := infl-lex-rule & v_end-lex-rule-super &
;  [ SYNSEM.LOCAL.CAT.VAL.SUBJ.FIRST.LOCAL.CONT.HOOK.INDEX.PNG.PER 4th ].

4p_subj_verb-lex-rule := infl-lex-rule & v_end-lex-rule-super &
  [ SYNSEM.LOCAL.CAT.VAL.SUBJ.FIRST [ LOCAL.CONT.HOOK.INDEX #index & [ PNG.PER 3rd+4th ], 
                                      NON-LOCAL.CRF-H.LIST < #index > ] ].

4p_obj_verb-lex-rule :+ [ SYNSEM.LOCAL.CRF-UP.BOOL - ].
4p_subj_verb-lex-rule :+ [ SYNSEM.LOCAL.CRF-UP.BOOL - ].

1sg_subj_verb-lex-rule := 1p_subj_verb-lex-rule & sg_subj_verb-lex-rule.

1pl_subj_verb-lex-rule := 1p_subj_verb-lex-rule & pl_subj_verb-lex-rule.

2sg_subj_verb-lex-rule := 2p_subj_verb-lex-rule & sg_subj_verb-lex-rule.

2pl_subj_verb-lex-rule := 2p_subj_verb-lex-rule & pl_subj_verb-lex-rule.

3sg_subj_verb-lex-rule := 3p_subj_verb-lex-rule & sg_subj_verb-lex-rule.

3pl_subj_verb-lex-rule := 3p_subj_verb-lex-rule & pl_subj_verb-lex-rule.

4sg_subj_verb-lex-rule := 4p_subj_verb-lex-rule & sg_subj_verb-lex-rule.

1sg_verb-lex-rule := 1sg_subj_verb-lex-rule & intrans_verb-lex-rule.

2sg_verb-lex-rule := 2sg_subj_verb-lex-rule & intrans_verb-lex-rule.

3sg_verb-lex-rule := 3sg_subj_verb-lex-rule & intrans_verb-lex-rule.

1pl_verb-lex-rule := 1pl_subj_verb-lex-rule & intrans_verb-lex-rule.

2pl_verb-lex-rule := 2pl_subj_verb-lex-rule & intrans_verb-lex-rule.

3pl_verb-lex-rule := 3pl_subj_verb-lex-rule & intrans_verb-lex-rule.

1sg_obj_verb-lex-rule := 1p_obj_verb-lex-rule & sg_obj_verb-lex-rule & trans_verb-lex-rule.

1pl_obj_verb-lex-rule := 1p_obj_verb-lex-rule & pl_obj_verb-lex-rule & trans_verb-lex-rule.

2sg_obj_verb-lex-rule := 2p_obj_verb-lex-rule & sg_obj_verb-lex-rule & trans_verb-lex-rule.

2pl_obj_verb-lex-rule := 2p_obj_verb-lex-rule & pl_obj_verb-lex-rule & trans_verb-lex-rule.

3sg_obj_verb-lex-rule := 3p_obj_verb-lex-rule & sg_obj_verb-lex-rule & trans_verb-lex-rule.

3pl_obj_verb-lex-rule := 3p_obj_verb-lex-rule & pl_obj_verb-lex-rule & trans_verb-lex-rule.

4sg_obj_verb-lex-rule := 4p_obj_verb-lex-rule & sg_obj_verb-lex-rule & trans_verb-lex-rule.

1sg_2sg_verb-lex-rule := 1sg_subj_verb-lex-rule & 2sg_obj_verb-lex-rule.

1sg_3sg_verb-lex-rule := 1sg_subj_verb-lex-rule & 3sg_obj_verb-lex-rule.

4sg_3sg_verb-lex-rule := 4sg_subj_verb-lex-rule & 3sg_obj_verb-lex-rule.

1sg_4sg_verb-lex-rule := 1sg_subj_verb-lex-rule & 4sg_obj_verb-lex-rule.

1p_2pl_verb-lex-rule := 1p_subj_verb-lex-rule & 2pl_obj_verb-lex-rule.

;;;1sg_2pl_verb-lex-rule := 1sg_subj_verb-lex-rule & 2pl_obj_verb-lex-rule.

;;1pl_2pl_verb-lex-rule := 1pl_subj_verb-lex-rule & 2pl_obj_verb-lex-rule.

1sg_3pl_verb-lex-rule := 1sg_subj_verb-lex-rule & 3pl_obj_verb-lex-rule.

1pl_3sg_verb-lex-rule := 1pl_subj_verb-lex-rule & 3sg_obj_verb-lex-rule.

1pl_3pl_verb-lex-rule := 1pl_subj_verb-lex-rule & 3pl_obj_verb-lex-rule.

2sg_1sg_verb-lex-rule := 1sg_obj_verb-lex-rule & 2sg_subj_verb-lex-rule.

2sg_3sg_verb-lex-rule := 2sg_subj_verb-lex-rule & 3sg_obj_verb-lex-rule.

2sg_3pl_verb-lex-rule := 2sg_subj_verb-lex-rule & 3pl_obj_verb-lex-rule.

2pl_3sg_verb-lex-rule := 2pl_subj_verb-lex-rule & 3sg_obj_verb-lex-rule.

3sg_1sg_verb-lex-rule := 1sg_obj_verb-lex-rule & 3sg_subj_verb-lex-rule.

3sg_1pl_verb-lex-rule := 1pl_obj_verb-lex-rule & 3sg_subj_verb-lex-rule.

3sg_2sg_verb-lex-rule := 3sg_obj_verb-lex-rule & 2sg_subj_verb-lex-rule.

3sg_3sg_verb-lex-rule := 3sg_obj_verb-lex-rule & 3sg_subj_verb-lex-rule.

3sg_3pl_verb-lex-rule := 3pl_obj_verb-lex-rule & 3sg_subj_verb-lex-rule.

3pl_3p_verb-lex-rule := 3p_obj_verb-lex-rule & 3pl_subj_verb-lex-rule & trans_verb-lex-rule.

3pl_3sg_verb-lex-rule := 3pl_3p_verb-lex-rule & sg_obj_verb-lex-rule.

;ind_1sg_verb-lex-rule := 1sg_verb-lex-rule & ind_mood-lex-rule.

ind+int_1sg_verb-lex-rule := ind+int-mood-lex-rule & 1sg_verb-lex-rule.

ind_2sg_verb-lex-rule := 2sg_verb-lex-rule & ind_mood-lex-rule.

ind_3sg_verb-lex-rule := 3sg_verb-lex-rule & ind_mood-lex-rule.

ind_3pl_verb-lex-rule := 3pl_verb-lex-rule & ind_mood-lex-rule.

ind+int_1sg_3sg_verb-lex-rule := 1sg_3sg_verb-lex-rule & ind+int-mood-lex-rule.

ind_2sg_1sg_verb-lex-rule := 2sg_1sg_verb-lex-rule & ind_mood-lex-rule.

ind_2sg_3sg_verb-lex-rule := 2sg_3sg_verb-lex-rule & ind_mood-lex-rule.

ind_2sg_3pl_verb-lex-rule := 2sg_3pl_verb-lex-rule & ind_mood-lex-rule.

ind+int_3sg_1sg_verb-lex-rule := 3sg_1sg_verb-lex-rule & ind+int-mood-lex-rule.

ind+int_3sg_1pl_verb-lex-rule := 3sg_1pl_verb-lex-rule & ind+int-mood-lex-rule.

ind+int_3sg_2sg_verb-lex-rule := 3sg_2sg_verb-lex-rule & ind+int-mood-lex-rule.

ind+int_3sg_3sg_verb-lex-rule := 3sg_3sg_verb-lex-rule & ind+int-mood-lex-rule.

3sg_claus_verb-lex-rule := 3sg_subj_verb-lex-rule & trans_clause_verb-lex-rule.

ind+int_3sg_claus_verb-lex-rule := 3sg_claus_verb-lex-rule & ind+int-mood-lex-rule.

part_1sg_verb-lex-rule := 1sg_verb-lex-rule & part_mood-lex-rule.

part_2sg_verb-lex-rule := 2sg_verb-lex-rule & part_mood-lex-rule.

part_3sg_verb-lex-rule := 3sg_verb-lex-rule & part_mood-lex-rule.

part_1sg_3sg_verb-lex-rule := 1sg_3sg_verb-lex-rule & part_mood-lex-rule.

part_1sg_4sg_verb-lex-rule := 1sg_4sg_verb-lex-rule & part_mood-lex-rule.

part_3sg_1sg_verb-lex-rule := 3sg_1sg_verb-lex-rule & part_mood-lex-rule.

iter_3sg_verb-lex-rule := 3sg_verb-lex-rule & iter_mood-lex-rule.

cntp_1sg_subj_verb-lex-rule := 1sg_verb-lex-rule & cntp_mood-lex-rule.

cntp_1pl_subj_verb-lex-rule := 1pl_verb-lex-rule & cntp_mood-lex-rule.

cntp_4sg_subj_verb-lex-rule := 4sg_subj_verb-lex-rule & cntp_mood-lex-rule & intrans_verb-lex-rule.

cntp_3sg_obj_verb-lex-rule := 3sg_obj_verb-lex-rule & cntp_mood-lex-rule & 
  [ SYNSEM.LOCAL.CAT.VAL.SUBJ.FIRST.NON-LOCAL.CRF-H.LIST < > ].

caus_1sg_verb-lex-rule := 1sg_verb-lex-rule & caus_mood-lex-rule.

caus_1pl_verb-lex-rule := 1pl_verb-lex-rule & caus_mood-lex-rule.

caus_2sg_verb-lex-rule := 2sg_verb-lex-rule & caus_mood-lex-rule.

caus_2pl_verb-lex-rule := 2pl_verb-lex-rule & caus_mood-lex-rule.

caus_3sg_verb-lex-rule := 3sg_verb-lex-rule & caus_mood-lex-rule.

caus_3pl_verb-lex-rule := 3pl_verb-lex-rule & caus_mood-lex-rule.

caus_4sg_verb-lex-rule := 4sg_verb-lex-rule & caus_mood-lex-rule.

caus_4pl_verb-lex-rule := 4pl_verb-lex-rule & caus_mood-lex-rule.

3pl_1pl_verb-lex-rule := 3pl_subj_verb-lex-rule & 1pl_obj_verb-lex-rule.

caus_3pl_1pl_verb-lex-rule := 3pl_1pl_verb-lex-rule & caus_mood-lex-rule.

caus_1sg_3sg_verb-lex-rule := 1sg_3sg_verb-lex-rule & caus_mood-lex-rule.

caus_3sg_3sg_verb-lex-rule := 3sg_3sg_verb-lex-rule & caus_mood-lex-rule.

caus_3sg_3pl_verb-lex-rule := 3sg_3pl_verb-lex-rule & caus_mood-lex-rule.

caus_4sg_3sg_verb-lex-rule := 4sg_3sg_verb-lex-rule & caus_mood-lex-rule.

imp_2sg_verb-lex-rule := imp_mood-lex-rule & 2sg_verb-lex-rule.

imp_2pl_verb-lex-rule := imp_mood-lex-rule & 2pl_verb-lex-rule.

imp_2sg_3sg_verb-lex-rule := imp_mood-lex-rule & 2sg_3sg_verb-lex-rule.

imp_2sg_3pl_verb-lex-rule := imp_mood-lex-rule & 2sg_3pl_verb-lex-rule.

itrg-lex-rule := add-only-no-ccont-rule &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.SF ques ].

prop-lex-rule := add-only-no-ccont-rule &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.SF prop ].

polar-lex-rule := itrg-lex-rule &
  [ SYNSEM.LOCAL.CAT.VAL [ SUBJ < [ NON-LOCAL.QUE.LIST < > ] >,
                           COMPS non-wh-list ] ].

int_polar-lex-rule := int_mood-lex-rule & polar-lex-rule.

1sg_claus_verb-lex-rule := 1sg_subj_verb-lex-rule & trans_clause_verb-lex-rule.

ind+int_1sg_claus_verb-lex-rule := 1sg_claus_verb-lex-rule & ind+int-mood-lex-rule.

int_2sg_3sg_verb-lex-rule := 2sg_3sg_verb-lex-rule & int_mood-lex-rule.

int_2sg_1sg_verb-lex-rule := 2sg_1sg_verb-lex-rule & int_mood-lex-rule.

int_2sg_verb-lex-rule := int_mood-lex-rule & 2sg_verb-lex-rule.

int_2pl_verb-lex-rule := int_mood-lex-rule & 2pl_verb-lex-rule.

int_3sg_verb-lex-rule := int_mood-lex-rule & 3sg_verb-lex-rule.

int_3pl_verb-lex-rule := int_mood-lex-rule & 3pl_verb-lex-rule.

int_2pl_3sg_verb-lex-rule := 2pl_3sg_verb-lex-rule & int_mood-lex-rule.

3pl_3pl_verb-lex-rule := 3pl_3p_verb-lex-rule & pl_obj_verb-lex-rule.

part_3pl_3pl_verb-lex-rule := 3pl_3pl_verb-lex-rule & part_mood-lex-rule.

ind_2pl_verb-lex-rule := 2pl_verb-lex-rule & ind_mood-lex-rule.

ind+int_1pl_verb-lex-rule := 1pl_verb-lex-rule & ind+int-mood-lex-rule.

ind+int_1sg_2sg_verb-lex-rule := 1sg_2sg_verb-lex-rule & ind+int-mood-lex-rule.

ind+int_1p_2pl_verb-lex-rule := 1p_2pl_verb-lex-rule & ind+int-mood-lex-rule.

;;;ind+int_1pl_2pl_verb-lex-rule := 1pl_2pl_verb-lex-rule & ind+int-mood-lex-rule.

ind+int_1pl_3pl_verb-lex-rule := 1pl_3pl_verb-lex-rule & ind+int-mood-lex-rule.

part_2sg_3sg_verb-lex-rule := 2sg_3sg_verb-lex-rule & part_mood-lex-rule.

2sg_claus_verb-lex-rule := 2sg_subj_verb-lex-rule & trans_clause_verb-lex-rule.

part_2sg_claus_verb-lex-rule := 2sg_claus_verb-lex-rule & part_mood-lex-rule.

ind+int_3pl_3p_verb-lex-rule := 3pl_3p_verb-lex-rule & ind+int-mood-lex-rule.

wh-subj-lex-rule := itrg-lex-rule &
  [ SYNSEM.LOCAL.CAT.VAL.SUBJ < [ NON-LOCAL.QUE.LIST cons ] > ].

ind+int_1sg_3pl_verb-lex-rule := 1sg_3pl_verb-lex-rule & ind+int-mood-lex-rule.

ind+int_1pl_3sg_verb-lex-rule := 1pl_3sg_verb-lex-rule & ind+int-mood-lex-rule.

ind_2pl_3sg_verb-lex-rule := 2pl_3sg_verb-lex-rule & ind_mood-lex-rule.

ind+int_3sg_3pl_verb-lex-rule := 3sg_3pl_verb-lex-rule & ind+int-mood-lex-rule.

part_3pl_verb-lex-rule := 3pl_verb-lex-rule & part_mood-lex-rule.

4pl_subj_verb-lex-rule := 4p_subj_verb-lex-rule & pl_subj_verb-lex-rule.

4sg_verb-lex-rule := 4sg_subj_verb-lex-rule & intrans_verb-lex-rule.

4pl_verb-lex-rule := 4pl_subj_verb-lex-rule & intrans_verb-lex-rule.

cntp_4pl_verb-lex-rule := 4pl_verb-lex-rule & cntp_mood-lex-rule.

cntp_3pl_obj_verb-lex-rule := 3pl_obj_verb-lex-rule & cntp_mood-lex-rule & 
  [ SYNSEM.LOCAL.CAT.VAL.SUBJ.FIRST.NON-LOCAL.CRF-H.LIST < > ].

;;;The below rule is added as a copy of another wh-rule. The user did not specify it.

wh-obj-lex-rule := itrg-lex-rule &
  [ SYNSEM.LOCAL.CAT.VAL [ SUBJ non-wh-list,
                           COMPS < [ NON-LOCAL.QUE.LIST cons ] > ] ].

wh-pseudo-lex-rule := v_end-lex-rule-super & wh-obj-lex-rule.

tense-lex-rule-super := cont-change-only-lex-rule & evid-rule-dtr & v_neg-rule-dtr & dub-rule-dtr & v_end_neg-rule-dtr & v_end-rule-dtr & 
  [ INFLECTED [ TENSE-FLAG +,
                TI_NNIK_FLAG #pp, 
                NEG_V_END_FLAG #negend, 
                TRANS_ONLY_V-VERB-FLAG #trans_only_v-verb,
                V_END-OR-V_END_NEG-FLAG #v_end-or-v_end_neg,
                ANTIPASS-OR-PASS-FLAG #antipass-or-nnik_null_pass,
                SG_ABS_QUES_NOUN-NOUN-FLAG #sg_abs_ques_noun-noun,
                TRANS_CLAUSE_VERB_NEG-OR-TRANS_VERB_NEG-OR-V_END-OR-V_END_NEG-FLAG #trans_clause_verb_neg-or-trans_verb_neg-or-v_end-or-v_end_neg,
                HAB-FLAG #hab,
                TI_ANTIPASS-OR-NORMAL-OR-TRANS_CAUS_PASS-FLAG #ti_antipass-or-ti_normal-or-trans_caus_pass,
                TRANS_CLAUSE_VERB-OR-TRANS_CLAUSE_VERB_NEG-OR-V_END-OR-V_END_NEG-FLAG #trans_clause_verb-or-trans_clause_verb_neg-or-v_end-or-v_end_neg,
                TRANS_VALCHG-FLAG #trans_valchg,
                CASE_ENDING-FLAG #case_ending,
                NULL_HTR-FLAG #null_htr,
                CL_Q_TRANS_V-VERB-OR-CL_TRANS_V-VERB-FLAG #cl_q_trans_v-verb-or-cl_trans_v-verb,
                INFL_QUES_N-NOUN-FLAG #infl_ques_n-noun,
                PI_V-VERB-FLAG #pi_v-verb,
                NUM_CASE_END-FLAG #num_case_end,
                NUM_CASE-OR-POSS-FLAG #num_case-or-poss,
                NUM_CASE-FLAG #num_case ],
    DTR tense-rule-dtr &
        [ INFLECTED [ TI_NNIK_FLAG #pp,
                      NEG_V_END_FLAG #negend, 
                      TRANS_ONLY_V-VERB-FLAG #trans_only_v-verb,
                      V_END-OR-V_END_NEG-FLAG #v_end-or-v_end_neg,
                      ANTIPASS-OR-PASS-FLAG #antipass-or-nnik_null_pass,
                      SG_ABS_QUES_NOUN-NOUN-FLAG #sg_abs_ques_noun-noun,
                      TRANS_CLAUSE_VERB_NEG-OR-TRANS_VERB_NEG-OR-V_END-OR-V_END_NEG-FLAG #trans_clause_verb_neg-or-trans_verb_neg-or-v_end-or-v_end_neg,
                      HAB-FLAG #hab,
                      TI_ANTIPASS-OR-NORMAL-OR-TRANS_CAUS_PASS-FLAG #ti_antipass-or-ti_normal-or-trans_caus_pass,
                      TRANS_CLAUSE_VERB-OR-TRANS_CLAUSE_VERB_NEG-OR-V_END-OR-V_END_NEG-FLAG #trans_clause_verb-or-trans_clause_verb_neg-or-v_end-or-v_end_neg,
                      TRANS_VALCHG-FLAG #trans_valchg,
                      CASE_ENDING-FLAG #case_ending,
                      NULL_HTR-FLAG #null_htr,
                      CL_Q_TRANS_V-VERB-OR-CL_TRANS_V-VERB-FLAG #cl_q_trans_v-verb-or-cl_trans_v-verb,
                      INFL_QUES_N-NOUN-FLAG #infl_ques_n-noun,
                      PI_V-VERB-FLAG #pi_v-verb,
                      NUM_CASE_END-FLAG #num_case_end,
                      NUM_CASE-OR-POSS-FLAG #num_case-or-poss,
                      NUM_CASE-FLAG #num_case ] ] ].

future-lex-rule := same-cont-lex-rule & no-ccont-lex-rule & infl-lex-rule & tense-lex-rule-super &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.E.TENSE future ].

nonfuture-lex-rule := same-cont-lex-rule & no-ccont-lex-rule & const-lex-rule & tense-lex-rule-super &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.E.TENSE nonfuture ].

;;; TODO: the position of this should be BEFORE aspectual morphemes -ðaq- and -liq- (and definitely tense morpheme -ssa)
;;; it might be better named as "be able to"
;;; TODO: should LARG of non-focus ICONS really be that of can_v_rel rather than the real verb?
;;; TODO: now aspect and tense will come after modal-lex-rule-super. how should it assign aspect and tense to the underlying verb?
modal-rule-dtr := word-or-lexrule.

modal-lex-rule-super := cont-change-only-lex-rule & tense-rule-dtr & aspect-rule-dtr & 
  [ INFLECTED #inflected,
    DTR modal-rule-dtr &
        [ INFLECTED #inflected ] ].

;;; TODO: should INDEX be that of modal or of the base verb?
base-modal-lex-rule := infl-lex-rule & modal-lex-rule-super & 
  [ C-CONT [ HOOK [ LTOP #lbl,
                    XARG #xarg,
                    INDEX #ind, 
                    CLAUSE-KEY #clause ],
             RELS.LIST < arg12-ev-relation &
                  [ LBL #lbl,
                    ARG0 #ind,
                    ARG1 #harg,
                    ARG2 #arg2 ] >,
             HCONS.LIST < qeq & [ HARG #harg, LARG #larg ] >,
             ICONS.LIST < > ], 
    DTR.SYNSEM.LOCAL [ CONT.HOOK [ LTOP #larg, 
                                 XARG #xarg, 
                                 INDEX #arg2, 
                                 CLAUSE-KEY #clause,
                                 ICONS-KEY.IARG1 #clause ], 
                       CAT.VAL.SUBJ.FIRST.LOCAL.CONT.HOOK [ ICONS-KEY.IARG1 #clause,
				                                                    CLAUSE-KEY #clause ] ] ].

can-lex-rule := base-modal-lex-rule & 
  [ C-CONT.RELS.LIST.FIRST.PRED "_can_v_rel" ].

must-lex-rule := base-modal-lex-rule & 
  [ C-CONT.RELS.LIST.FIRST.PRED "_must_v_rel" ].

be-supposed-to-lex-rule := base-modal-lex-rule & 
  [ C-CONT.RELS.LIST.FIRST.PRED "_be+supposed+to_v_rel" ].

;;; 2025-11-12 CCH: TODO: this is only temporary; they might not be in the same position class
want-to-lex-rule := base-modal-lex-rule & 
  [ C-CONT.RELS.LIST.FIRST.PRED "_want+to_v_rel" ].

desire-to-lex-rule := base-modal-lex-rule & 
  [ C-CONT.RELS.LIST.FIRST.PRED "_desire+to_v_rel" ].

;;; 2025-11-12 CCH: TODO: this is only temporary; they might not be in the same position class
intend-to-lex-rule := base-modal-lex-rule & 
  [ C-CONT.RELS.LIST.FIRST.PRED "_intend+to-or-try+to_v_rel" ].

;;; 2025-11-12 CCH: TODO: this is only temporary; they might not be in the same position class
;;; and the meaning might not be quite correct
go-and-lex-rule := base-modal-lex-rule & 
  [ C-CONT.RELS.LIST.FIRST.PRED "_go+and_v_rel" ].

;;; 2025-11-12 CCH: note that -laaq-sinnau but -yunnaaq-l^luaq and -sinnau-yunnaaq
;;; also relax the DTR constraint to accept adjectives (but is that wanted? e.g. for -lluaq)
adv_incorporation-lex-rule := add-only-rule &
  [ C-CONT [ RELS.LIST < arg1-ev-relation &
                         [ LBL #ltop,
                           ARG1 #event ] >,
             HOOK #hook ],
    DTR.SYNSEM.LOCAL [ CAT.HEAD +vj,
                       CONT.HOOK #hook &
                                 [ LTOP #ltop,
                                   INDEX #event ] ] ].

incorp-adv-rule-dtr := word-or-lexrule.

incorp-adv-lex-rule-super := adv_incorporation-lex-rule & modal-rule-dtr & aspect-rule-dtr & tense-rule-dtr &
  [ INFLECTED #infl,
    DTR incorp-adv-rule-dtr & [ INFLECTED #infl ] ].

;;; 2025-11-14 Temporary solution, but its real position class should not be here
qatigiik-lex-rule := infl-lex-rule & incorp-adv-lex-rule-super & 
  [ C-CONT.RELS.LIST.FIRST.PRED "_together_a_rel" ].

;;; 2025-11-12
laaq-lex-rule := infl-lex-rule & incorp-adv-lex-rule-super & 
  [ C-CONT.RELS.LIST.FIRST.PRED "_a+little_a_rel" ].

ngaaq-lex-rule := infl-lex-rule & incorp-adv-lex-rule-super & 
  [ C-CONT.RELS.LIST.FIRST.PRED "_great_a_rel" ].

innaq-lex-rule := infl-lex-rule & incorp-adv-lex-rule-super & 
  [ C-CONT.RELS.LIST.FIRST.PRED "_only_a_rel" ].

lluaq-lex-rule := infl-lex-rule & incorp-adv-lex-rule-super & 
  [ C-CONT.RELS.LIST.FIRST.PRED "_good_a_rel" ].

vallaaq-lex-rule := infl-lex-rule & incorp-adv-lex-rule-super & 
  [ C-CONT.RELS.LIST.FIRST.PRED "_too_a_rel" ].

nqik-lex-rule := infl-lex-rule & incorp-adv-lex-rule-super & 
  [ C-CONT.RELS.LIST.FIRST.PRED "_again_a_rel" ].

vik-v-lex-rule := infl-lex-rule & incorp-adv-lex-rule-super & 
  [ C-CONT.RELS.LIST.FIRST.PRED "_real-or-complete_a_rel" ].

aspect-lex-rule-super := add-only-no-ccont-rule & tense-rule-dtr &
  [ INFLECTED #infl,
    DTR aspect-rule-dtr & [ INFLECTED #infl ] ].

same-hab-flag-lex-rule := lex-rule & 
  [ INFLECTED.HAB-FLAG #hab,
    DTR.INFLECTED.HAB-FLAG #hab ].

hab-lex-rule := aspect-lex-rule-super & infl-lex-rule &
  [ INFLECTED.HAB-FLAG +,
    SYNSEM.LOCAL.CONT.HOOK.INDEX.E.ASPECT habitual ].

cont-lex-rule := aspect-lex-rule-super & infl-lex-rule &
  [ INFLECTED.HAB-FLAG +,
    SYNSEM.LOCAL.CONT.HOOK.INDEX.E.ASPECT continuative ].

yunnaaq-lex-rule := aspect-lex-rule-super & infl-lex-rule &
  [ INFLECTED.HAB-FLAG +,
    SYNSEM.LOCAL.CONT.HOOK.INDEX.E.ASPECT terminative ].

pfv-lex-rule := aspect-lex-rule-super & infl-lex-rule & same-hab-flag-lex-rule & 
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.E.ASPECT perfective ].

incep-lex-rule := aspect-lex-rule-super & infl-lex-rule & same-hab-flag-lex-rule & 
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.E.ASPECT inceptive ].

pfv_tord-lex-rule := aspect-lex-rule-super & infl-lex-rule & same-hab-flag-lex-rule & 
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.E.ASPECT perfective ].

v_neg-lex-rule-super := cont-change-only-lex-rule & dub-rule-dtr & v_end-rule-dtr & v_end_neg-rule-dtr & 
  [ INFLECTED [ TI_NNIK_FLAG #pp,
                TRANS_ONLY_V-VERB-FLAG #trans_only_v-verb,
                V_END-OR-V_END_NEG-FLAG #v_end-or-v_end_neg,
                ANTIPASS-OR-PASS-FLAG #antipass-or-nnik_null_pass,
                SG_ABS_QUES_NOUN-NOUN-FLAG #sg_abs_ques_noun-noun,
                TRANS_CLAUSE_VERB_NEG-OR-TRANS_VERB_NEG-OR-V_END-OR-V_END_NEG-FLAG #trans_clause_verb_neg-or-trans_verb_neg-or-v_end-or-v_end_neg,
                HAB-FLAG #hab,
                TI_ANTIPASS-OR-NORMAL-OR-TRANS_CAUS_PASS-FLAG #ti_antipass-or-ti_normal-or-trans_caus_pass,
                TRANS_CLAUSE_VERB-OR-TRANS_CLAUSE_VERB_NEG-OR-V_END-OR-V_END_NEG-FLAG #trans_clause_verb-or-trans_clause_verb_neg-or-v_end-or-v_end_neg,
                TRANS_VALCHG-FLAG #trans_valchg,
                CASE_ENDING-FLAG #case_ending,
                NULL_HTR-FLAG #null_htr,
                CL_Q_TRANS_V-VERB-OR-CL_TRANS_V-VERB-FLAG #cl_q_trans_v-verb-or-cl_trans_v-verb,
                INFL_QUES_N-NOUN-FLAG #infl_ques_n-noun,
                PI_V-VERB-FLAG #pi_v-verb,
                NUM_CASE_END-FLAG #num_case_end,
                NUM_CASE-OR-POSS-FLAG #num_case-or-poss,
                NUM_CASE-FLAG #num_case,
                TENSE-FLAG #tense ],
    DTR v_neg-rule-dtr &
        [ INFLECTED [ TI_NNIK_FLAG #pp,
                      TRANS_ONLY_V-VERB-FLAG #trans_only_v-verb,
                      V_END-OR-V_END_NEG-FLAG #v_end-or-v_end_neg,
                      ANTIPASS-OR-PASS-FLAG #antipass-or-nnik_null_pass,
                      SG_ABS_QUES_NOUN-NOUN-FLAG #sg_abs_ques_noun-noun,
                      TRANS_CLAUSE_VERB_NEG-OR-TRANS_VERB_NEG-OR-V_END-OR-V_END_NEG-FLAG #trans_clause_verb_neg-or-trans_verb_neg-or-v_end-or-v_end_neg,
                      HAB-FLAG #hab,
                      TI_ANTIPASS-OR-NORMAL-OR-TRANS_CAUS_PASS-FLAG #ti_antipass-or-ti_normal-or-trans_caus_pass,
                      TRANS_CLAUSE_VERB-OR-TRANS_CLAUSE_VERB_NEG-OR-V_END-OR-V_END_NEG-FLAG #trans_clause_verb-or-trans_clause_verb_neg-or-v_end-or-v_end_neg,
                      TRANS_VALCHG-FLAG #trans_valchg,
                      CASE_ENDING-FLAG #case_ending,
                      NULL_HTR-FLAG #null_htr,
                      CL_Q_TRANS_V-VERB-OR-CL_TRANS_V-VERB-FLAG #cl_q_trans_v-verb-or-cl_trans_v-verb,
                      INFL_QUES_N-NOUN-FLAG #infl_ques_n-noun,
                      PI_V-VERB-FLAG #pi_v-verb,
                      NUM_CASE_END-FLAG #num_case_end,
                      NUM_CASE-OR-POSS-FLAG #num_case-or-poss,
                      NUM_CASE-FLAG #num_case,
                      TENSE-FLAG #tense ] ] ].

; This adds negative semantics to the verb's
; RELS list.

;;; March 6th, 2025: isolate the effect of negation to add this to cntp_neg as well
neg-add-lex-rule := lex-rule & 
  [ C-CONT [ HOOK [ XARG #xarg,
                    LTOP #ltop,
                    INDEX #ind ],
             RELS.LIST < event-relation &
                         [ PRED "neg_rel",
                           LBL #ltop,
                           ARG1 #harg ] >,
             HCONS.LIST < qeq &
                          [ HARG #harg,
                            LARG #larg ] > ], 
    SYNSEM.LKEYS #lkeys,
    DTR.SYNSEM [ LKEYS #lkeys,
                 LOCAL [ CONT.HOOK [ XARG #xarg,
                                     INDEX #ind,
                                     LTOP #larg ],
                         CAT.HEAD +vj ] ] ].

neg-lex-rule := infl-lex-rule & neg-add-lex-rule & v_neg-lex-rule-super & 
  [ INFLECTED.NEG_V_END_FLAG +,
    DTR.INFLECTED.HAB-FLAG na ].


ind+int_1sg_verb_neg-lex-rule := 1sg_verb-lex-rule & ind+int-mood_neg-lex-rule.

ind+int_1pl_verb_neg-lex-rule := 1pl_verb-lex-rule & ind+int-mood_neg-lex-rule.

ind_3sg_verb_neg-lex-rule := 3sg_verb-lex-rule & ind_mood_neg-lex-rule.

ind+int_3pl_verb_neg-lex-rule := 3pl_verb-lex-rule & ind+int-mood_neg-lex-rule.

;;;int_3pl_verb_neg-lex-rule := 3pl_verb-lex-rule & int_mood_neg-lex-rule.

ind+int_1sg_2sg_verb_neg-lex-rule := 1sg_2sg_verb-lex-rule & ind+int-mood_neg-lex-rule.

ind+int_1sg_3sg_verb_neg-lex-rule := 1sg_3sg_verb-lex-rule & ind+int-mood_neg-lex-rule.

ind+int_1sg_3pl_verb_neg-lex-rule := 1sg_3pl_verb-lex-rule & ind+int-mood_neg-lex-rule.

ind_3sg_3sg_verb_neg-lex-rule := 3sg_3sg_verb-lex-rule & ind_mood_neg-lex-rule.

ind+int_1pl_3pl_verb_neg-lex-rule := 1pl_3pl_verb-lex-rule & ind+int-mood_neg-lex-rule.

ind_2pl_3sg_verb_neg-lex-rule := 2pl_3sg_verb-lex-rule & ind_mood_neg-lex-rule.

ind_3sg_3pl_verb_neg-lex-rule := 3sg_3pl_verb-lex-rule & ind_mood_neg-lex-rule.

ind+int_3sg_claus_verb_neg-lex-rule := 3sg_claus_verb-lex-rule & ind+int-mood_neg-lex-rule.

ind+int_1sg_claus_verb_neg-lex-rule := 1sg_claus_verb-lex-rule & ind+int-mood_neg-lex-rule.

int_3sg_verb_neg-lex-rule := 3sg_verb-lex-rule & int_mood_neg-lex-rule.

ind+int_2sg_verb_neg-lex-rule := 2sg_verb-lex-rule & ind+int-mood_neg-lex-rule.

;;;ind_2sg_verb_neg-lex-rule := 2sg_verb-lex-rule & ind_mood_neg-lex-rule.

int_2pl_3sg_verb_neg-lex-rule := 2pl_3sg_verb-lex-rule & int_mood_neg-lex-rule.

int_2sg_3sg_verb_neg-lex-rule := 2sg_3sg_verb-lex-rule & int_mood_neg-lex-rule.

int_2sg_3pl_verb_neg-lex-rule := 2sg_3pl_verb-lex-rule & int_mood_neg-lex-rule.

caus_3sg_verb_neg-lex-rule := 3sg_verb-lex-rule & caus_mood_neg-lex-rule.

caus_3pl_verb_neg-lex-rule := 3pl_verb-lex-rule & caus_mood_neg-lex-rule.

caus_2sg_3sg_verb_neg-lex-rule := 2sg_3sg_verb-lex-rule & caus_mood_neg-lex-rule.

cntp_1sg_subj_verb_neg-lex-rule := 1sg_verb-lex-rule & cntp_mood_neg-lex-rule.

cntp_3sg_subj_verb_neg-lex-rule := 3sg_verb-lex-rule & cntp_mood_neg-lex-rule.

cntp_3sg_obj_verb_neg-lex-rule := 3sg_obj_verb-lex-rule & cntp_mood_neg-lex-rule & 
  [ SYNSEM.LOCAL.CAT.VAL.SUBJ.FIRST.NON-LOCAL.CRF-H.LIST < > ].

ind+int_3pl_3p_verb_neg-lex-rule := 3pl_3p_verb-lex-rule & ind+int-mood_neg-lex-rule.

;;;part_2sg_claus_verb_neg-lex-rule := 2sg_claus_verb-lex-rule & part_mood_neg-lex-rule.

null_htr-lex-rule-super := modal-rule-dtr & aspect-rule-dtr & tense-rule-dtr & val-change-with-ccont-lex-rule & incorp-adv-rule-dtr &
  [ INFLECTED [ NEG_V_END_FLAG #negvend, 
                NULL_HTR-FLAG +,
                TRANS_ONLY_V-VERB-FLAG #trans_only_v-verb,
                V_END-OR-V_END_NEG-FLAG #v_end-or-v_end_neg,
                SG_ABS_QUES_NOUN-NOUN-FLAG #sg_abs_ques_noun-noun,
                TRANS_CLAUSE_VERB_NEG-OR-TRANS_VERB_NEG-OR-V_END-OR-V_END_NEG-FLAG #trans_clause_verb_neg-or-trans_verb_neg-or-v_end-or-v_end_neg,
                HAB-FLAG #hab,
                TRANS_CLAUSE_VERB-OR-TRANS_CLAUSE_VERB_NEG-OR-V_END-OR-V_END_NEG-FLAG #trans_clause_verb-or-trans_clause_verb_neg-or-v_end-or-v_end_neg,
                TRANS_VALCHG-FLAG #trans_valchg,
                CASE_ENDING-FLAG #case_ending,
                CL_Q_TRANS_V-VERB-OR-CL_TRANS_V-VERB-FLAG #cl_q_trans_v-verb-or-cl_trans_v-verb,
                INFL_QUES_N-NOUN-FLAG #infl_ques_n-noun,
                PI_V-VERB-FLAG #pi_v-verb,
                NUM_CASE_END-FLAG #num_case_end,
                NUM_CASE-OR-POSS-FLAG #num_case-or-poss,
                NUM_CASE-FLAG #num_case,
                TENSE-FLAG #tense ],
    DTR [ INFLECTED [ NEG_V_END_FLAG #negvend, 
                      TRANS_ONLY_V-VERB-FLAG #trans_only_v-verb,
                      V_END-OR-V_END_NEG-FLAG #v_end-or-v_end_neg,
                      SG_ABS_QUES_NOUN-NOUN-FLAG #sg_abs_ques_noun-noun,
                      TRANS_CLAUSE_VERB_NEG-OR-TRANS_VERB_NEG-OR-V_END-OR-V_END_NEG-FLAG #trans_clause_verb_neg-or-trans_verb_neg-or-v_end-or-v_end_neg,
                      HAB-FLAG #hab,
                      TRANS_CLAUSE_VERB-OR-TRANS_CLAUSE_VERB_NEG-OR-V_END-OR-V_END_NEG-FLAG #trans_clause_verb-or-trans_clause_verb_neg-or-v_end-or-v_end_neg,
                      TRANS_VALCHG-FLAG #trans_valchg,
                      CASE_ENDING-FLAG #case_ending,
                      CL_Q_TRANS_V-VERB-OR-CL_TRANS_V-VERB-FLAG #cl_q_trans_v-verb-or-cl_trans_v-verb,
                      INFL_QUES_N-NOUN-FLAG #infl_ques_n-noun,
                      PI_V-VERB-FLAG #pi_v-verb,
                      NUM_CASE_END-FLAG #num_case_end,
                      NUM_CASE-OR-POSS-FLAG #num_case-or-poss,
                      NUM_CASE-FLAG #num_case,
                      TENSE-FLAG #tense ] ] ].

no-crt-h-contrib-lex-rule := null_htr-lex-rule-super & 
  [ SYNSEM.LOCAL.CAT.VAL.COMPS.FIRST.NON-LOCAL [ CRF-H.LIST < > ] ].

antipass-lex-rule := no-crt-h-contrib-lex-rule & val-change-only-lex-rule & 
  [ SYNSEM.LOCAL.CAT.VAL [ SUBJ #subj,
                           SPR #spr, 
                           SPEC #spec, 
                           COMPS #comps & [ FIRST [ LOCAL.CAT.HEAD.CASE ins, 
                                                    NON-LOCAL.CRF-H.LIST < > ] ], 
                           --KEYCOMP non-synsem ], 
    DTR.SYNSEM.LOCAL.CAT.VAL [ SUBJ #subj, 
                               SPR #spr, 
                               SPEC #spec, 
                               COMPS #comps, 
                               --KEYCOMP synsem-min ] ].

null_antipass-lex-rule := const-lex-rule & antipass-lex-rule & 
  [ DTR null_antipass-rule-dtr & [ INFLECTED [ TRANS_ONLY_V-VERB-FLAG na, 
                                               TI_ANTIPASS-OR-NORMAL-OR-TRANS_CAUS_PASS-FLAG #ti_antipass-or-ti_normal-or-trans_caus_pass ] ],
    INFLECTED [ ANTIPASS-OR-PASS-FLAG +, 
                TI_ANTIPASS-OR-NORMAL-OR-TRANS_CAUS_PASS-FLAG #ti_antipass-or-ti_normal-or-trans_caus_pass ] ].

;;; 2025-03-31 add intransitives to here for participles
intrans-active-lex-rule := add-only-no-ccont-rule & const-lex-rule & null_htr-lex-rule-super &
  [ INFLECTED [ TI_ANTIPASS-OR-NORMAL-OR-TRANS_CAUS_PASS-FLAG +,
                ANTIPASS-OR-PASS-FLAG #antipass-or-nnik_null_pass ],
    DTR.INFLECTED [ PI_V-VERB-FLAG na,
                    ANTIPASS-OR-PASS-FLAG #antipass-or-nnik_null_pass ],
    DTR null_htr-rule-dtr, 
    SYNSEM.LOCAL.CAT.VAL [ COMPS < >, 
                           --KEYCOMP non-synsem ] ].

clitic-active-rule-dtr := word-or-lexrule.

clitic-active-lex-rule := add-only-no-ccont-rule & const-lex-rule & null_htr-lex-rule-super &
  [ INFLECTED [ TI_ANTIPASS-OR-NORMAL-OR-TRANS_CAUS_PASS-FLAG +,
                ANTIPASS-OR-PASS-FLAG #antipass-or-nnik_null_pass ],
    DTR.INFLECTED [ PI_V-VERB-FLAG na,
                    ANTIPASS-OR-PASS-FLAG #antipass-or-nnik_null_pass ],
    DTR clitic-active-rule-dtr, 
    SYNSEM.LOCAL.CAT.VAL [ COMPS cons, 
                           --KEYCOMP non-synsem ] ].

active-lex-rule := add-only-no-ccont-rule & const-lex-rule & null_htr-lex-rule-super &
  [ INFLECTED [ TI_ANTIPASS-OR-NORMAL-OR-TRANS_CAUS_PASS-FLAG +,
                ANTIPASS-OR-PASS-FLAG #antipass-or-nnik_null_pass ],
    DTR.INFLECTED [ PI_V-VERB-FLAG na,
                    ANTIPASS-OR-PASS-FLAG #antipass-or-nnik_null_pass ],
    DTR null_htr-rule-dtr, 
    SYNSEM.LOCAL.CAT.VAL [ SUBJ.FIRST.LOCAL.CAT.HEAD.CASE erg,
                           COMPS.FIRST #keycomp, 
                           --KEYCOMP #keycomp ] ].

;;;2025-09-23 atorpoq = atuq-vuq
;;; maybe we should have obj-prom-from-arg1of2-op-lex-rule??? 
;;; not really, it requires a nonempty COMPS in SYNSEM, but here we can't
;;; 2025-11-09 it is now unclear which element in COMPS should be deleted for double-transitive
patient-pass-lex-rule := val-change-only-lex-rule & const-lex-rule & null_htr-lex-rule-super & subj-and-comps-change-only-lex-rule &
  [ INFLECTED [ TI_ANTIPASS-OR-NORMAL-OR-TRANS_CAUS_PASS-FLAG +,
                ANTIPASS-OR-PASS-FLAG #antipass-or-nnik_null_pass ],
    DTR.INFLECTED [ PI_V-VERB-FLAG na,
                    ANTIPASS-OR-PASS-FLAG #antipass-or-nnik_null_pass ],
    DTR patient-pass-lex-rule-dtr & [ SYNSEM.LOCAL.CAT.VAL.--KEYCOMP.LOCAL #local ], 
    SYNSEM.LOCAL.CAT.VAL [ SUBJ.FIRST.LOCAL #local, 
                           --KEYCOMP non-synsem ] ].

patient-pass-1st-lex-rule := patient-pass-lex-rule & 
  [ SYNSEM.LOCAL.CAT.VAL.COMPS #comps,
    DTR.SYNSEM.LOCAL.CAT.VAL [ COMPS < #keycomp . #comps >, 
                               --KEYCOMP #keycomp ] ].

;;; TODO: this unexpectedly identifies first and second COMPS element when they intend to be different.
;;; NOTE: maybe this is a reason for reflexive???
;;; Currently for -tət, COMPS.FIRST is --KEYCOMP and COMPS.REST.FIRST is the -mut "demoted" subj
;;; 2025-11-10 temporarily remove this from lrules.tdl to prevent further issues
patient-pass-2nd-lex-rule := patient-pass-lex-rule & 
  [ SYNSEM.LOCAL.CAT.VAL.COMPS < #first >,
    DTR.SYNSEM.LOCAL.CAT.VAL[ COMPS < #first, #keycomp >, 
                              --KEYCOMP #keycomp ] ].

both_p_reflex-lex-rule-dtr := word-or-lexrule.

;;; 2025-09-27: the reflexive `imminut` hasn't been allowed yet
both_p_reflex-lex-rule := val-change-only-lex-rule & const-lex-rule & null_htr-lex-rule-super & subj-and-comps-change-only-lex-rule &
  [ INFLECTED [ TI_ANTIPASS-OR-NORMAL-OR-TRANS_CAUS_PASS-FLAG +,
                ANTIPASS-OR-PASS-FLAG #antipass-or-nnik_null_pass ],
    DTR.INFLECTED [ PI_V-VERB-FLAG na,
                    ANTIPASS-OR-PASS-FLAG #antipass-or-nnik_null_pass ],
    DTR both_p_reflex-lex-rule-dtr & [SYNSEM.LOCAL.CAT.VAL [ SUBJ < #subj & [LOCAL.CONT.HOOK #hook] >,
                                                             COMPS < [LOCAL.CONT.HOOK #hook] > ] ], 
    SYNSEM.LOCAL.CAT.VAL [ SUBJ < #subj >,
                           COMPS < >, 
                           --KEYCOMP non-synsem ] ].

ditrans-active-lex-rule := add-only-no-ccont-rule & const-lex-rule & null_htr-lex-rule-super &
  [ INFLECTED [ TI_ANTIPASS-OR-NORMAL-OR-TRANS_CAUS_PASS-FLAG +,
                ANTIPASS-OR-PASS-FLAG #antipass-or-nnik_null_pass ],
    DTR.INFLECTED [ PI_V-VERB-FLAG na,
                    ANTIPASS-OR-PASS-FLAG #antipass-or-nnik_null_pass ],
    DTR ditrans-null_htr-rule-dtr, 
    SYNSEM.LOCAL.CAT.VAL [ SUBJ.FIRST.LOCAL.CAT.HEAD.CASE erg,
                           COMPS [ FIRST [ LOCAL.CAT.HEAD.CASE ins, 
                                           NON-LOCAL.CRF-H.LIST < > ] ], 
                           COMPS.REST.FIRST #keycomp, 
                           --KEYCOMP #keycomp ] ].

ditrans-active-pp-lex-rule := add-only-no-ccont-rule & const-lex-rule & null_htr-lex-rule-super &
  [ INFLECTED [ TI_ANTIPASS-OR-NORMAL-OR-TRANS_CAUS_PASS-FLAG +,
                ANTIPASS-OR-PASS-FLAG #antipass-or-nnik_null_pass ],
    DTR.INFLECTED [ PI_V-VERB-FLAG na,
                    ANTIPASS-OR-PASS-FLAG #antipass-or-nnik_null_pass ],
    DTR ditrans-pp-null_htr-rule-dtr, 
    SYNSEM.LOCAL.CAT.VAL [ SUBJ.FIRST.LOCAL.CAT.HEAD.CASE erg,
                           COMPS.REST [ FIRST [ LOCAL.CAT.HEAD.CASE all, 
                                                NON-LOCAL.CRF-H.LIST < > ] ], 
                           COMPS.FIRST #keycomp, 
                           --KEYCOMP #keycomp ] ].

; active-no-case-lex-rule := add-only-no-ccont-rule & const-lex-rule & null_htr-lex-rule-super &
;   [ INFLECTED [ TI_ANTIPASS-OR-NORMAL-OR-TRANS_CAUS_PASS-FLAG +,
;                 ANTIPASS-OR-PASS-FLAG #antipass-or-nnik_null_pass,
;                 ANTIPASS-OR-PASS-OR-TRANS_CAUS_PASS-FLAG #antipass-or-pass-or-trans_caus_pass,
;                 
;                 ARG_CASE-FLAG - ],
;     DTR.INFLECTED [ PI_V-VERB-FLAG na,
;                     ANTIPASS-OR-PASS-FLAG #antipass-or-nnik_null_pass,
;                     ANTIPASS-OR-PASS-OR-TRANS_CAUS_PASS-FLAG #antipass-or-pass-or-trans_caus_pass,
;                     ],
;     DTR null_htr-rule-dtr, 
;     SYNSEM.LOCAL.CAT.VAL.--KEYCOMP non-synsem ].

passive-lex-rule := subj-dem-to-arg1of2-op-lex-rule & obj-prom-from-arg1of2-op-lex-rule & infl-lex-rule & local-change-only-lex-rule & no-crt-h-contrib-lex-rule & same-cont-lex-rule & xarg-change-only-ccont-lex-rule &
  [ DTR pass-rule-dtr & [ INFLECTED [ PI_V-VERB-FLAG na, 
                                      TI_ANTIPASS-OR-NORMAL-OR-TRANS_CAUS_PASS-FLAG #ti_antipass-or-ti_normal-or-trans_caus_pass ] ],
    INFLECTED [ ANTIPASS-OR-PASS-FLAG +, 
                TI_ANTIPASS-OR-NORMAL-OR-TRANS_CAUS_PASS-FLAG #ti_antipass-or-ti_normal-or-trans_caus_pass ],
    SYNSEM.LOCAL.CAT.VAL [ COMPS.FIRST.LOCAL.CAT.HEAD.CASE abl, 
                           --KEYCOMP non-synsem ] ].


ti_antipass-lex-rule := infl-lex-rule & antipass-lex-rule & 
  [ INFLECTED [ ANTIPASS-OR-PASS-FLAG +,
                TI_ANTIPASS-OR-NORMAL-OR-TRANS_CAUS_PASS-FLAG + ],
    DTR ti_antipass-rule-dtr & [ INFLECTED [ TI_NNIK_FLAG + ] ] ].

trans_caus_pass-lex-rule := subj-dem-to-arg3of3-op-lex-rule & obj-prom-from-arg3of3-op-lex-rule & infl-lex-rule & local-change-only-lex-rule & same-cont-lex-rule & no-crt-h-contrib-lex-rule & xarg-change-only-ccont-lex-rule &
  [ INFLECTED [ TI_ANTIPASS-OR-NORMAL-OR-TRANS_CAUS_PASS-FLAG +,
                ANTIPASS-OR-PASS-FLAG #antipass-or-nnik_null_pass ],
    DTR ditrans_pass-rule-dtr & 
      [ INFLECTED [ TRANS_VALCHG-FLAG +,
                    ANTIPASS-OR-PASS-FLAG #antipass-or-nnik_null_pass ] ],
    SYNSEM.LOCAL.CAT.VAL [ COMPS.REST.FIRST.LOCAL.CAT.HEAD.CASE abl, 
                           --KEYCOMP non-synsem ] ].

;;;antipass-obj-lex-rule := lex-rule & [ SYNSEM.LOCAL.CAT.VAL.COMPS.FIRST.LOCAL.CONT.HOOK.INDEX.COG-ST type-id ].

nnik_antipass-lex-rule := infl-lex-rule & antipass-lex-rule & 
  [ INFLECTED [ ANTIPASS-OR-PASS-FLAG +, 
                TI_ANTIPASS-OR-NORMAL-OR-TRANS_CAUS_PASS-FLAG #ti_antipass-or-ti_normal-or-trans_caus_pass ],
    DTR nnik_antipass-rule-dtr & [ INFLECTED [ TI_NNIK_FLAG +, 
                                               TI_ANTIPASS-OR-NORMAL-OR-TRANS_CAUS_PASS-FLAG #ti_antipass-or-ti_normal-or-trans_caus_pass ] ] ].

intrans_valchg-lex-rule-super := infl-lex-rule & null_htr-rule-dtr & ti_antipass-rule-dtr & val-change-with-ccont-lex-rule & pass-rule-dtr & 
    [ SYNSEM.LOCAL.CAT.VAL.--KEYCOMP.LOCAL #keycomp, 
      INFLECTED [ TI_NNIK_FLAG +,
                NEG_V_END_FLAG #neg_v_end, 
                TRANS_ONLY_V-VERB-FLAG #trans_only_v-verb,
                V_END-OR-V_END_NEG-FLAG #v_end-or-v_end_neg,
                ANTIPASS-OR-PASS-FLAG #antipass-or-nnik_null_pass,
                SG_ABS_QUES_NOUN-NOUN-FLAG #sg_abs_ques_noun-noun,
                TRANS_CLAUSE_VERB_NEG-OR-TRANS_VERB_NEG-OR-V_END-OR-V_END_NEG-FLAG #trans_clause_verb_neg-or-trans_verb_neg-or-v_end-or-v_end_neg,
                HAB-FLAG #hab,
                TI_ANTIPASS-OR-NORMAL-OR-TRANS_CAUS_PASS-FLAG #ti_antipass-or-ti_normal-or-trans_caus_pass,
                TRANS_CLAUSE_VERB-OR-TRANS_CLAUSE_VERB_NEG-OR-V_END-OR-V_END_NEG-FLAG #trans_clause_verb-or-trans_clause_verb_neg-or-v_end-or-v_end_neg,
                TRANS_VALCHG-FLAG #trans_valchg,
                CASE_ENDING-FLAG #case_ending,
                NULL_HTR-FLAG #null_htr,
                CL_Q_TRANS_V-VERB-OR-CL_TRANS_V-VERB-FLAG #cl_q_trans_v-verb-or-cl_trans_v-verb,
                INFL_QUES_N-NOUN-FLAG #infl_ques_n-noun,
                PI_V-VERB-FLAG #pi_v-verb,
                NUM_CASE_END-FLAG #num_case_end,
                NUM_CASE-OR-POSS-FLAG #num_case-or-poss,
                NUM_CASE-FLAG #num_case,
                TENSE-FLAG #tense ],
      DTR intrans_v-verb-lex &
        [ SYNSEM.LOCAL.CAT.VAL.SUBJ.FIRST.LOCAL #keycomp, 
          INFLECTED [ NEG_V_END_FLAG #neg_v_end, 
                      TRANS_ONLY_V-VERB-FLAG #trans_only_v-verb,
                      V_END-OR-V_END_NEG-FLAG #v_end-or-v_end_neg,
                      ANTIPASS-OR-PASS-FLAG #antipass-or-nnik_null_pass,
                      SG_ABS_QUES_NOUN-NOUN-FLAG #sg_abs_ques_noun-noun,
                      TRANS_CLAUSE_VERB_NEG-OR-TRANS_VERB_NEG-OR-V_END-OR-V_END_NEG-FLAG #trans_clause_verb_neg-or-trans_verb_neg-or-v_end-or-v_end_neg,
                      HAB-FLAG #hab,
                      TI_ANTIPASS-OR-NORMAL-OR-TRANS_CAUS_PASS-FLAG #ti_antipass-or-ti_normal-or-trans_caus_pass,
                      TRANS_CLAUSE_VERB-OR-TRANS_CLAUSE_VERB_NEG-OR-V_END-OR-V_END_NEG-FLAG #trans_clause_verb-or-trans_clause_verb_neg-or-v_end-or-v_end_neg,
                      TRANS_VALCHG-FLAG #trans_valchg,
                      CASE_ENDING-FLAG #case_ending,
                      NULL_HTR-FLAG #null_htr,
                      CL_Q_TRANS_V-VERB-OR-CL_TRANS_V-VERB-FLAG #cl_q_trans_v-verb-or-cl_trans_v-verb,
                      INFL_QUES_N-NOUN-FLAG #infl_ques_n-noun,
                      PI_V-VERB-FLAG #pi_v-verb,
                      NUM_CASE_END-FLAG #num_case_end,
                      NUM_CASE-OR-POSS-FLAG #num_case-or-poss,
                      NUM_CASE-FLAG #num_case,
                      TENSE-FLAG #tense ] ] ].

caus_valchg-lex-rule := causative-to-arg2-itr-op-lex-rule & intrans_valchg-lex-rule-super & same-non-local-lex-rule & patient-pass-lex-rule-dtr & 
  [ C-CONT.RELS.LIST < [ PRED "_let_v_rel" ] > ].
  
ask_valchg-lex-rule := causative-to-arg2-itr-op-lex-rule & intrans_valchg-lex-rule-super & same-non-local-lex-rule &
  [ C-CONT.RELS.LIST < [ PRED "_bid_v_rel" ] > ].

evid-lex-rule-super := cont-change-only-lex-rule & infl-lex-rule & v_neg-rule-dtr & dub-rule-dtr & v_end_neg-rule-dtr & v_end-rule-dtr & 
  [ INFLECTED #infl,
    DTR evid-rule-dtr &
        [ INFLECTED #infl ] ].

evidential-lex-rule := cont-change-only-lex-rule & same-spr-lex-rule & same-spec-lex-rule &
  [ C-CONT [ RELS.LIST < event-relation &
                         [ LBL #ltop,
                           ARG0 event,
                           ARG1 #harg ] >,
             HCONS.LIST < qeq &
                          [ HARG #harg,
                            LARG #larg ] >,
             HOOK [ LTOP #ltop,
                    INDEX #mainev,
                    XARG #mainagent ] ],
    DTR.SYNSEM.LOCAL.CONT.HOOK [ LTOP #larg,
                                 XARG #mainagent,
                                 INDEX #mainev ] ].

nonfirsthand-evidential-lex-rule := evidential-lex-rule &
  [ C-CONT.RELS.LIST < [ PRED "ev_nonfirsthand_rel" ] > ].

sima-lex-rule := evid-lex-rule-super & nonfirsthand-evidential-lex-rule.

trans_valchg-lex-rule-super := infl-lex-rule & null_htr-rule-dtr & ditrans_pass-rule-dtr & val-change-with-ccont-lex-rule &
  [ SYNSEM.LOCAL.CAT.VAL.--KEYCOMP #keycomp, 
    INFLECTED [ TI_NNIK_FLAG +,
                TRANS_VALCHG-FLAG +,
                TRANS_ONLY_V-VERB-FLAG #trans_only_v-verb,
                V_END-OR-V_END_NEG-FLAG #v_end-or-v_end_neg,
                ANTIPASS-OR-PASS-FLAG #antipass-or-nnik_null_pass,
                SG_ABS_QUES_NOUN-NOUN-FLAG #sg_abs_ques_noun-noun,
                TRANS_CLAUSE_VERB_NEG-OR-TRANS_VERB_NEG-OR-V_END-OR-V_END_NEG-FLAG #trans_clause_verb_neg-or-trans_verb_neg-or-v_end-or-v_end_neg,
                HAB-FLAG #hab,
                TI_ANTIPASS-OR-NORMAL-OR-TRANS_CAUS_PASS-FLAG #ti_antipass-or-ti_normal-or-trans_caus_pass,
                TRANS_CLAUSE_VERB-OR-TRANS_CLAUSE_VERB_NEG-OR-V_END-OR-V_END_NEG-FLAG #trans_clause_verb-or-trans_clause_verb_neg-or-v_end-or-v_end_neg,
                CASE_ENDING-FLAG #case_ending,
                NULL_HTR-FLAG #null_htr,
                CL_Q_TRANS_V-VERB-OR-CL_TRANS_V-VERB-FLAG #cl_q_trans_v-verb-or-cl_trans_v-verb,
                INFL_QUES_N-NOUN-FLAG #infl_ques_n-noun,
                PI_V-VERB-FLAG #pi_v-verb,
                NUM_CASE_END-FLAG #num_case_end,
                NUM_CASE-OR-POSS-FLAG #num_case-or-poss,
                NUM_CASE-FLAG #num_case,
                TENSE-FLAG #tense ],
    DTR trans_valchg-rule-dtr &
        [ SYNSEM.LOCAL.CAT.VAL.--KEYCOMP #keycomp, 
          INFLECTED [ TRANS_ONLY_V-VERB-FLAG #trans_only_v-verb,
                      V_END-OR-V_END_NEG-FLAG #v_end-or-v_end_neg,
                      ANTIPASS-OR-PASS-FLAG #antipass-or-nnik_null_pass,
                      SG_ABS_QUES_NOUN-NOUN-FLAG #sg_abs_ques_noun-noun,
                      TRANS_CLAUSE_VERB_NEG-OR-TRANS_VERB_NEG-OR-V_END-OR-V_END_NEG-FLAG #trans_clause_verb_neg-or-trans_verb_neg-or-v_end-or-v_end_neg,
                      HAB-FLAG #hab,
                      TI_ANTIPASS-OR-NORMAL-OR-TRANS_CAUS_PASS-FLAG #ti_antipass-or-ti_normal-or-trans_caus_pass,
                      TRANS_CLAUSE_VERB-OR-TRANS_CLAUSE_VERB_NEG-OR-V_END-OR-V_END_NEG-FLAG #trans_clause_verb-or-trans_clause_verb_neg-or-v_end-or-v_end_neg,
                      CASE_ENDING-FLAG #case_ending,
                      NULL_HTR-FLAG #null_htr,
                      CL_Q_TRANS_V-VERB-OR-CL_TRANS_V-VERB-FLAG #cl_q_trans_v-verb-or-cl_trans_v-verb,
                      INFL_QUES_N-NOUN-FLAG #infl_ques_n-noun,
                      PI_V-VERB-FLAG #pi_v-verb,
                      NUM_CASE_END-FLAG #num_case_end,
                      NUM_CASE-OR-POSS-FLAG #num_case-or-poss,
                      NUM_CASE-FLAG #num_case,
                      TENSE-FLAG #tense ] ] ].

trans_caus_valchg-lex-rule := causative-to-arg2-tr-op-lex-rule & same-non-local-lex-rule & trans_valchg-lex-rule-super & patient-pass-lex-rule-dtr & 
  [ INFLECTED.TI_ANTIPASS-OR-NORMAL-OR-TRANS_CAUS_PASS-FLAG -,
    C-CONT.RELS.LIST < [ PRED "causative_rel" ] >,
    SYNSEM.LOCAL.CAT.VAL.COMPS.REST.FIRST [ LOCAL.CAT.HEAD.CASE all, 
                                            NON-LOCAL.CRF-H.LIST < > ], 
    DTR.SYNSEM.LOCAL.CAT.VAL [ --KEYCOMP #mark-obj, 
                               COMPS.FIRST #mark-obj ] ].

trans_ask_valchg-lex-rule := causative-to-arg2-tr-op-lex-rule & same-non-local-lex-rule & trans_valchg-lex-rule-super & patient-pass-lex-rule-dtr & 
  [ INFLECTED.TI_ANTIPASS-OR-NORMAL-OR-TRANS_CAUS_PASS-FLAG -,
    C-CONT.RELS.LIST < [ PRED "ask_v_rel" ] >,
    SYNSEM.LOCAL.CAT.VAL.COMPS.REST.FIRST [ LOCAL.CAT.HEAD.CASE all, 
                                            NON-LOCAL.CRF-H.LIST < > ], 
    DTR.SYNSEM.LOCAL.CAT.VAL [ --KEYCOMP #mark-obj, 
                               COMPS.FIRST #mark-obj ] ].

;;; TODO: it seems that the head type will be lost, if we do like this
dub-lex-rule-super := head-change-only-lex-rule & 
  [ INFLECTED [ NEG_V_END_FLAG -,
                TRANS_ONLY_V-VERB-FLAG #trans_only_v-verb,
                V_END-OR-V_END_NEG-FLAG #v_end-or-v_end_neg,
                ANTIPASS-OR-PASS-FLAG #antipass-or-nnik_null_pass,
                SG_ABS_QUES_NOUN-NOUN-FLAG #sg_abs_ques_noun-noun,
                TRANS_CLAUSE_VERB_NEG-OR-TRANS_VERB_NEG-OR-V_END-OR-V_END_NEG-FLAG #trans_clause_verb_neg-or-trans_verb_neg-or-v_end-or-v_end_neg,
                HAB-FLAG #hab,
                TI_ANTIPASS-OR-NORMAL-OR-TRANS_CAUS_PASS-FLAG #ti_antipass-or-ti_normal-or-trans_caus_pass,
                TRANS_CLAUSE_VERB-OR-TRANS_CLAUSE_VERB_NEG-OR-V_END-OR-V_END_NEG-FLAG #trans_clause_verb-or-trans_clause_verb_neg-or-v_end-or-v_end_neg,
                TRANS_VALCHG-FLAG #trans_valchg,
                CASE_ENDING-FLAG #case_ending,
                NULL_HTR-FLAG #null_htr,
                CL_Q_TRANS_V-VERB-OR-CL_TRANS_V-VERB-FLAG #cl_q_trans_v-verb-or-cl_trans_v-verb,
                INFL_QUES_N-NOUN-FLAG #infl_ques_n-noun,
                PI_V-VERB-FLAG #pi_v-verb,
                NUM_CASE_END-FLAG #num_case_end,
                NUM_CASE-OR-POSS-FLAG #num_case-or-poss,
                NUM_CASE-FLAG #num_case,
                TENSE-FLAG #tense ],
    SYNSEM.LOCAL.CAT.HEAD +vj & [ MOD #mod,
                            PRD #prd,
                            KEYS #keys,
                            PRON #pron,
                            POSSESSOR #possessor,
                            SPEC-INIT #specinit,
                            INIT #init,
                            INCORP #incorp ],
    DTR dub-rule-dtr &
        [ INFLECTED [ TRANS_ONLY_V-VERB-FLAG #trans_only_v-verb,
                      V_END-OR-V_END_NEG-FLAG #v_end-or-v_end_neg,
                      ANTIPASS-OR-PASS-FLAG #antipass-or-nnik_null_pass,
                      SG_ABS_QUES_NOUN-NOUN-FLAG #sg_abs_ques_noun-noun,
                      TRANS_CLAUSE_VERB_NEG-OR-TRANS_VERB_NEG-OR-V_END-OR-V_END_NEG-FLAG #trans_clause_verb_neg-or-trans_verb_neg-or-v_end-or-v_end_neg,
                      HAB-FLAG #hab,
                      TI_ANTIPASS-OR-NORMAL-OR-TRANS_CAUS_PASS-FLAG #ti_antipass-or-ti_normal-or-trans_caus_pass,
                      TRANS_CLAUSE_VERB-OR-TRANS_CLAUSE_VERB_NEG-OR-V_END-OR-V_END_NEG-FLAG #trans_clause_verb-or-trans_clause_verb_neg-or-v_end-or-v_end_neg,
                      TRANS_VALCHG-FLAG #trans_valchg,
                      CASE_ENDING-FLAG #case_ending,
                      NULL_HTR-FLAG #null_htr,
                      CL_Q_TRANS_V-VERB-OR-CL_TRANS_V-VERB-FLAG #cl_q_trans_v-verb-or-cl_trans_v-verb,
                      INFL_QUES_N-NOUN-FLAG #infl_ques_n-noun,
                      PI_V-VERB-FLAG #pi_v-verb,
                      NUM_CASE_END-FLAG #num_case_end,
                      NUM_CASE-OR-POSS-FLAG #num_case-or-poss,
                      NUM_CASE-FLAG #num_case,
                      TENSE-FLAG #tense ],
          SYNSEM.LOCAL.CAT.HEAD +vj & [ MOD #mod,
                            PRD #prd,
                            KEYS #keys,
                            PRON #pron,
                            POSSESSOR #possessor,
                            SPEC-INIT #specinit,
                            INIT #init,
                            INCORP #incorp ] ] ].

;;;mod
niq-lex-rule := dub-lex-rule-super & infl-lex-rule & v_end-rule-dtr &
  [ SYNSEM.LOCAL [ CAT [ MC -,
                         HEAD.DBT + ],
                   CONT.HOOK.INDEX.SF ques ] ].

tit-lex-rule := dub-lex-rule-super & infl-lex-rule & v_end-rule-dtr &
  [ SYNSEM.LOCAL.CAT [ MC -, 
                       HEAD.DUR + ] ].

case_ending-lex-rule-super := add-only-no-ccont-rule & infl-lex-rule &
  [ INFLECTED [ CASE_ENDING-FLAG +,
                TRANS_ONLY_V-VERB-FLAG #trans_only_v-verb,
                V_END-OR-V_END_NEG-FLAG #v_end-or-v_end_neg,
                ANTIPASS-OR-PASS-FLAG #antipass-or-nnik_null_pass,
                SG_ABS_QUES_NOUN-NOUN-FLAG #sg_abs_ques_noun-noun,
                TRANS_CLAUSE_VERB_NEG-OR-TRANS_VERB_NEG-OR-V_END-OR-V_END_NEG-FLAG #trans_clause_verb_neg-or-trans_verb_neg-or-v_end-or-v_end_neg,
                HAB-FLAG #hab,
                TI_ANTIPASS-OR-NORMAL-OR-TRANS_CAUS_PASS-FLAG #ti_antipass-or-ti_normal-or-trans_caus_pass,
                TRANS_CLAUSE_VERB-OR-TRANS_CLAUSE_VERB_NEG-OR-V_END-OR-V_END_NEG-FLAG #trans_clause_verb-or-trans_clause_verb_neg-or-v_end-or-v_end_neg,
                TRANS_VALCHG-FLAG #trans_valchg,
                NULL_HTR-FLAG #null_htr,
                CL_Q_TRANS_V-VERB-OR-CL_TRANS_V-VERB-FLAG #cl_q_trans_v-verb-or-cl_trans_v-verb,
                INFL_QUES_N-NOUN-FLAG #infl_ques_n-noun,
                PI_V-VERB-FLAG #pi_v-verb,
                NUM_CASE_END-FLAG #num_case_end,
                NUM_CASE-OR-POSS-FLAG #num_case-or-poss,
                NUM_CASE-FLAG #num_case,
                TENSE-FLAG #tense ],
    DTR ques-determiner-lex &
        [ INFLECTED [ TRANS_ONLY_V-VERB-FLAG #trans_only_v-verb,
                      V_END-OR-V_END_NEG-FLAG #v_end-or-v_end_neg,
                      ANTIPASS-OR-PASS-FLAG #antipass-or-nnik_null_pass,
                      SG_ABS_QUES_NOUN-NOUN-FLAG #sg_abs_ques_noun-noun,
                      TRANS_CLAUSE_VERB_NEG-OR-TRANS_VERB_NEG-OR-V_END-OR-V_END_NEG-FLAG #trans_clause_verb_neg-or-trans_verb_neg-or-v_end-or-v_end_neg,
                      HAB-FLAG #hab,
                      TI_ANTIPASS-OR-NORMAL-OR-TRANS_CAUS_PASS-FLAG #ti_antipass-or-ti_normal-or-trans_caus_pass,
                      TRANS_CLAUSE_VERB-OR-TRANS_CLAUSE_VERB_NEG-OR-V_END-OR-V_END_NEG-FLAG #trans_clause_verb-or-trans_clause_verb_neg-or-v_end-or-v_end_neg,
                      TRANS_VALCHG-FLAG #trans_valchg,
                      NULL_HTR-FLAG #null_htr,
                      CL_Q_TRANS_V-VERB-OR-CL_TRANS_V-VERB-FLAG #cl_q_trans_v-verb-or-cl_trans_v-verb,
                      INFL_QUES_N-NOUN-FLAG #infl_ques_n-noun,
                      PI_V-VERB-FLAG #pi_v-verb,
                      NUM_CASE_END-FLAG #num_case_end,
                      NUM_CASE-OR-POSS-FLAG #num_case-or-poss,
                      NUM_CASE-FLAG #num_case,
                      TENSE-FLAG #tense ] ] ].

erg_ques-lex-rule := case_ending-lex-rule-super &
  [ SYNSEM.LOCAL.CAT.VAL.SPEC.FIRST.LOCAL.CAT.HEAD.CASE erg ].

sg_ques-lex-rule := case_ending-lex-rule-super &
  [ SYNSEM.LOCAL.CAT.VAL.SPEC.FIRST.LOCAL.CONT.HOOK.INDEX.PNG.NUM sg ].

sg_erg_ques-lex-rule := erg_ques-lex-rule & sg_ques-lex-rule.

;;;mod
attr-affix-dtr := word-or-lexrule.

attr_affix-lex-rule-super := add-only-no-ccont-rule & infl-lex-rule & num_case_end-rule-dtr &
  [ INFLECTED [ NUM_CASE_END-FLAG #nce ],
    DTR attr-affix-dtr &
        [ INFLECTED.NUM_CASE_END-FLAG #nce ] ].

common_attr-lex-rule := attr_affix-lex-rule-super & 
  [ DTR common_verby_adj-adj-lex ].

suuq_adj-lex-rule := attr_affix-lex-rule-super & 
  [ DTR suuq_verby_adj-adj-lex ].

tu_adj-lex-rule := attr_affix-lex-rule-super & 
  [ DTR tu_verby_adj-adj-lex ].

empty-slash-list := olist.

empty-slash-cons := empty-slash-list & ocons &
[ FIRST [ NON-LOCAL.SLASH.LIST < > ],
  REST empty-slash-list ].

empty-slash-null := empty-slash-list & onull.

;;;mod   PRD -
;;;temporary fix to avoid decl-opt-subj for attributive adjectives
;;; 2025-03-31 add no-case to SUBJ's HEAD to prevent attributive adjs from getting any subjects
num_case_end-lex-rule-super := head-change-only-lex-rule & 
  [ SYNSEM.LOCAL.CAT [ HEAD.PRD -, 
                       VAL.SUBJ empty-slash-list ], 
    INFLECTED [ NUM_CASE_END-FLAG +,
                TRANS_ONLY_V-VERB-FLAG #trans_only_v-verb,
                V_END-OR-V_END_NEG-FLAG #v_end-or-v_end_neg,
                ANTIPASS-OR-PASS-FLAG #antipass-or-nnik_null_pass,
                SG_ABS_QUES_NOUN-NOUN-FLAG #sg_abs_ques_noun-noun,
                TRANS_CLAUSE_VERB_NEG-OR-TRANS_VERB_NEG-OR-V_END-OR-V_END_NEG-FLAG #trans_clause_verb_neg-or-trans_verb_neg-or-v_end-or-v_end_neg,
                HAB-FLAG #hab,
                TI_ANTIPASS-OR-NORMAL-OR-TRANS_CAUS_PASS-FLAG #ti_antipass-or-ti_normal-or-trans_caus_pass,
                TRANS_CLAUSE_VERB-OR-TRANS_CLAUSE_VERB_NEG-OR-V_END-OR-V_END_NEG-FLAG #trans_clause_verb-or-trans_clause_verb_neg-or-v_end-or-v_end_neg,
                TRANS_VALCHG-FLAG #trans_valchg,
                CASE_ENDING-FLAG #case_ending,
                NULL_HTR-FLAG #null_htr,
                CL_Q_TRANS_V-VERB-OR-CL_TRANS_V-VERB-FLAG #cl_q_trans_v-verb-or-cl_trans_v-verb,
                INFL_QUES_N-NOUN-FLAG #infl_ques_n-noun,
                PI_V-VERB-FLAG #pi_v-verb,
                NUM_CASE-OR-POSS-FLAG #num_case-or-poss,
                NUM_CASE-FLAG #num_case,
                TENSE-FLAG #tense ],
    DTR num_case_end-rule-dtr &
        [ INFLECTED [ TRANS_ONLY_V-VERB-FLAG #trans_only_v-verb,
                      V_END-OR-V_END_NEG-FLAG #v_end-or-v_end_neg,
                      ANTIPASS-OR-PASS-FLAG #antipass-or-nnik_null_pass,
                      SG_ABS_QUES_NOUN-NOUN-FLAG #sg_abs_ques_noun-noun,
                      TRANS_CLAUSE_VERB_NEG-OR-TRANS_VERB_NEG-OR-V_END-OR-V_END_NEG-FLAG #trans_clause_verb_neg-or-trans_verb_neg-or-v_end-or-v_end_neg,
                      HAB-FLAG #hab,
                      TI_ANTIPASS-OR-NORMAL-OR-TRANS_CAUS_PASS-FLAG #ti_antipass-or-ti_normal-or-trans_caus_pass,
                      TRANS_CLAUSE_VERB-OR-TRANS_CLAUSE_VERB_NEG-OR-V_END-OR-V_END_NEG-FLAG #trans_clause_verb-or-trans_clause_verb_neg-or-v_end-or-v_end_neg,
                      TRANS_VALCHG-FLAG #trans_valchg,
                      CASE_ENDING-FLAG #case_ending,
                      NULL_HTR-FLAG #null_htr,
                      CL_Q_TRANS_V-VERB-OR-CL_TRANS_V-VERB-FLAG #cl_q_trans_v-verb-or-cl_trans_v-verb,
                      INFL_QUES_N-NOUN-FLAG #infl_ques_n-noun,
                      PI_V-VERB-FLAG #pi_v-verb,
                      NUM_CASE-OR-POSS-FLAG #num_case-or-poss,
                      NUM_CASE-FLAG #num_case,
                      TENSE-FLAG #tense ] ] ].

posthead-plus-lex-rule := num_case_end-lex-rule-super & 
  [ SYNSEM.LOCAL.CAT.POSTHEAD + ].

sg_attr_adj-lex-rule := num_case_end-lex-rule-super &
  [ SYNSEM.LOCAL.CONT.HOOK.XARG.PNG.NUM sg ].

pl_attr_adj-lex-rule := infl-lex-rule & num_case_end-lex-rule-super &
  [ SYNSEM.LOCAL.CONT.HOOK.XARG.PNG.NUM pl ].

abs_attr_adj-lex-rule := same-head-lex-rule & posthead-plus-lex-rule &
  [ SYNSEM.LOCAL.CAT.HEAD.MOD.FIRST.LOCAL.CAT.HEAD.CASE abs ].

sg_abs_attr_adj-lex-rule := abs_attr_adj-lex-rule & const-lex-rule & sg_attr_adj-lex-rule.

pl_abs_attr_adj-lex-rule := abs_attr_adj-lex-rule & pl_attr_adj-lex-rule.

erg_attr_adj-lex-rule := same-head-lex-rule & infl-lex-rule & posthead-plus-lex-rule &
  [ SYNSEM.LOCAL.CAT.HEAD.MOD.FIRST.LOCAL.CAT.HEAD.CASE erg ].

sg_erg_attr_adj-lex-rule := erg_attr_adj-lex-rule & sg_attr_adj-lex-rule.

pl_erg_attr_adj-lex-rule := erg_attr_adj-lex-rule & pl_attr_adj-lex-rule.

ins_attr_adj-lex-rule := same-head-lex-rule & infl-lex-rule & posthead-plus-lex-rule &
  [ SYNSEM.LOCAL.CAT.HEAD.MOD.FIRST.LOCAL.CAT.HEAD.CASE ins ].

sg_ins_attr_adj-lex-rule := ins_attr_adj-lex-rule & sg_attr_adj-lex-rule.

pl_ins_attr_adj-lex-rule := ins_attr_adj-lex-rule & pl_attr_adj-lex-rule.

;;;mod
loc_attr_adj-lex-rule := same-head-lex-rule & infl-lex-rule & posthead-plus-lex-rule &
  [ SYNSEM.LOCAL.CAT.HEAD.MOD.FIRST.LOCAL.CAT.HEAD.CASE loc ].

incorp_attr_adj-lex-rule := num_case_end-lex-rule-super &
  [ SYNSEM.LOCAL.CAT.HEAD adj & [ INCORP +, 
                            MOD #mod, 
                            PRD #prd, 
                            KEYS #keys, 
                            PRON #pron, 
                            POSSESSOR #possessor,
                            SPEC-INIT #specinit, 
                            INIT #init ], 
    DTR.SYNSEM.LOCAL.CAT.HEAD [ MOD #mod, 
                                PRD #prd, 
                                KEYS #keys, 
                                PRON #pron, 
                                POSSESSOR #possessor,
                                SPEC-INIT #specinit, 
                                INIT #init ] ].

sg_incorp_attr_adj-lex-rule := incorp_attr_adj-lex-rule & sg_attr_adj-lex-rule.

pl_incorp_attr_adj-lex-rule := incorp_attr_adj-lex-rule & pl_attr_adj-lex-rule.

sg_incorp_real_v_attr_adj-lex-rule := infl-lex-rule & sg_incorp_attr_adj-lex-rule & 
  [ SYNSEM.LOCAL.CAT.POSTHEAD - ]. 

pl_incorp_real_v_attr_adj-lex-rule := pl_incorp_attr_adj-lex-rule & 
  [ SYNSEM.LOCAL.CAT.POSTHEAD - ]. 

sg_incorp_npred_attr_adj-lex-rule := const-lex-rule & sg_incorp_attr_adj-lex-rule & posthead-plus-lex-rule.

pl_incorp_npred_attr_adj-lex-rule := pl_incorp_attr_adj-lex-rule & posthead-plus-lex-rule.

sg_loc_attr_adj-lex-rule := loc_attr_adj-lex-rule & sg_attr_adj-lex-rule.

pl_loc_attr_adj-lex-rule := loc_attr_adj-lex-rule & pl_attr_adj-lex-rule.
;;;endmod

;;;mod
nouny_adj_pred_affix-lex-rule-super := add-only-no-ccont-rule & infl-lex-rule & tense-rule-dtr & 
  [ INFLECTED #inflected,
    DTR nouny_adj-adj-lex & [ INFLECTED #inflected ] ].

adj_pred_u-lex-rule := nouny_adj_pred_affix-lex-rule-super.

;;;mod   COMPS.FIRST now has empty SPR and noun HEAD
subj-dem-to-arg1of2-op-lex-rule := subj-and-comps-change-only-lex-rule &
  [ SYNSEM.LOCAL.CAT.VAL [ COMPS < [ LOCAL [ CONT.HOOK.INDEX #sidx, 
                                             CAT [ VAL.SPR < >, 
                                                   HEAD noun] ] ] > ],
    DTR.SYNSEM.LOCAL.CAT.VAL [ SUBJ < [ LOCAL.CONT.HOOK.INDEX #sidx ] >,
                               COMPS < [ ] > ] ].

subj-dem-to-arg3of3-op-lex-rule := subj-and-comps-change-only-lex-rule &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS < #oarg,
                                 [ LOCAL.CONT.HOOK.INDEX #sidx ] >,
    DTR.SYNSEM.LOCAL.CAT.VAL [ SUBJ < [ LOCAL.CONT.HOOK.INDEX #sidx ] >,
                               COMPS < [ ], 
                                       #oarg > ] ].

scopal-rel-lex-rule := lex-rule &
  [ C-CONT [ RELS.LIST < event-relation &
                         [ LBL #ltop,
                           ARG0 #hidx,
                           ARG1 #arg1,
                           ARG2 #arg2,
                           ARG3 #harg ] >,
             HOOK [ LTOP #ltop,
                    INDEX #hidx,
                    XARG #arg1 ],
             HCONS.LIST < qeq &
                          [ HARG #harg,
                            LARG #scoped ] > ],
    SYNSEM.LOCAL.CAT.VAL.SUBJ < [ LOCAL.CONT.HOOK.INDEX #arg1 ] >,
    DTR.SYNSEM.LOCAL [ CAT.VAL.SUBJ < [ LOCAL.CONT.HOOK.INDEX #arg2 ] >,
                       CONT.HOOK.LTOP #scoped ] ].

;;;mod   SUBJ and COMPS.FIRST now has noun HEAD
causative-to-arg2-itr-op-lex-rule := scopal-rel-lex-rule & same-spr-lex-rule & same-spec-lex-rule &
  [ SYNSEM.LOCAL.CAT.VAL [ SUBJ < [ LOCAL.CAT [ VAL [ SPR < >,
                                                      COMPS < > ], 
                                                HEAD noun ] ] >,
                           COMPS < [ LOCAL [ CONT.HOOK.INDEX #arg2,
                                             CAT [ HEAD noun & [ MOD #mod,
                                                          KEYS #keys ],
                                                   VAL #val ] ],
                                     NON-LOCAL #nl ] > ],
    DTR.SYNSEM.LOCAL.CAT.VAL [ SUBJ < [ LOCAL [ CONT.HOOK.INDEX #arg2,
                                                CAT [ HEAD [ MOD #mod,
                                                             KEYS #keys ],
                                                      VAL #val ] ],
                                        NON-LOCAL #nl ] >,
                               COMPS < > ] ].

;;;mod   SUBJ now has empty SPR and noun HEAD
obj-prom-from-arg1of2-op-lex-rule := subj-and-comps-change-only-lex-rule &
  [ SYNSEM.LOCAL.CAT.VAL [ SUBJ < [ LOCAL [ CONT.HOOK.INDEX #sidx , 
                                            CAT [ VAL.SPR < >, 
                                                  HEAD noun] ] ] >,
                           COMPS < [ ] > ], 
    DTR.SYNSEM.LOCAL.CAT.VAL.COMPS < [ LOCAL.CONT.HOOK.INDEX #sidx ] > ].

;;;mod   SUBJ and COMPS.FIRST now has noun HEAD
; causative-to-arg2-tr-op-lex-rule := scopal-rel-lex-rule & same-spr-lex-rule & same-spec-lex-rule &
;   [ SYNSEM.LOCAL.CAT.VAL [ SUBJ < [ LOCAL.CAT [ VAL [ SPR < >,
;                                                       COMPS < > ], 
;                                                 HEAD noun ] ] >,
;                            COMPS < [ LOCAL [ CONT.HOOK.INDEX #arg2,
;                                              CAT [ HEAD noun & [ MOD #mod,
;                                                           KEYS #keys ],
;                                                    VAL #val ] ],
;                                      NON-LOCAL #nl ],
;                                    #comp > ],
;     DTR.SYNSEM.LOCAL.CAT.VAL [ SUBJ < [ LOCAL [ CONT.HOOK.INDEX #arg2,
;                                                 CAT [ HEAD [ MOD #mod,
;                                                              KEYS #keys ],
;                                                       VAL #val ] ],
;                                         NON-LOCAL #nl ] >,
;                                COMPS < #comp > ] ].

causative-to-arg2-tr-op-lex-rule := scopal-rel-lex-rule & same-spr-lex-rule & same-spec-lex-rule &
  [ SYNSEM.LOCAL.CAT.VAL [ SUBJ < [ LOCAL.CAT [ VAL [ SPR < >,
                                                      COMPS < > ], 
                                                HEAD noun ] ] >,
                           COMPS < #comp, [ LOCAL [ CONT.HOOK.INDEX #arg2,
                                             CAT [ HEAD noun & [ MOD #mod,
                                                          KEYS #keys ],
                                                   VAL #val ] ],
                                     NON-LOCAL #nl ] > ],
    DTR.SYNSEM.LOCAL.CAT.VAL [ SUBJ < [ LOCAL [ CONT.HOOK.INDEX #arg2,
                                                CAT [ HEAD [ MOD #mod,
                                                             KEYS #keys ],
                                                      VAL #val ] ],
                                        NON-LOCAL #nl ] >,
                               COMPS < #comp > ] ].

;;; March 6th, 2025: add empty SPR to new SUBJ
obj-prom-from-arg3of3-op-lex-rule := subj-and-comps-change-only-lex-rule &
  [ SYNSEM.LOCAL.CAT.VAL [ SUBJ < [ LOCAL [ CAT.VAL.SPR < >, 
                                            CONT.HOOK.INDEX #sidx ] ] >,
                           COMPS < #oarg,
                                   [ ] > ],
    DTR.SYNSEM.LOCAL.CAT.VAL.COMPS < [ LOCAL.CONT.HOOK.INDEX #sidx ],
                                      #oarg > ].

;;;;;;;;;;;;;;;;;;;
;;; Phrasal Types
;;;;;;;;;;;;;;;;;;;

;Constraint on MC used to be part of matrix.tdl
;;it applies to all wo implementations, except for v2

comp-head-phrase := basic-head-1st-comp-phrase & head-final &
  [ HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.INIT - ].

basic-head-comp-phrase :+ [ SYNSEM.LOCAL.CAT.VAL [ INCORP-N #incorp, 
                                                   --KEYCOMP #keycomp ], 
                            HEAD-DTR.SYNSEM.LOCAL.CAT.VAL [INCORP-N #incorp, 
                                                           --KEYCOMP #keycomp ] ].

head-mod-phrase :+ [ SYNSEM.LOCAL.CAT.VAL.INCORP-N #incorp, 
   HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.INCORP-N #incorp ].

basic-head-subj-phrase :+ [ SYNSEM.LOCAL.CAT.VAL.INCORP-N < > ].

basic-head-opt-subj-phrase :+ [ SYNSEM.LOCAL.CAT.VAL.INCORP-N < > ].

;;;decl-head-opt-subj-phrase :+ [ SYNSEM.LOCAL.CAT.HEAD.PRD na-or-+ ].

subj-head-phrase := decl-head-subj-phrase & head-final & 
  [ SYNSEM.LOCAL.CAT [ MC #mc ], 
    HEAD-DTR.SYNSEM.LOCAL.CAT [ MC #mc, VAL.COMPS < > ] ].

quote-subj-head-phrase := decl-head-subj-phrase & head-final & 
  [ SYNSEM.LOCAL.CAT [ MC #mc ], 
    HEAD-DTR.SYNSEM.LOCAL.CAT [ MC #mc, VAL.COMPS < root-synsem & [ PUNCT [ LPUNCT quote-punct, 
                                                                    RPUNCT quote-punct ] ] > ] ].

;;; 2025-03-25 CCH
;;; Add head-subj for verb-initial sentence for:
;;; 1. Intransitive verbs
;;; NOTE: Abusing SPEC-INIT (subj to the left means [ SPEC-INIT + ])
;;; NOTE: it MUST be indefinite; MUST be real verb (not adj or noun predicates)
;;; temporal fix: the noun should NOT be a question verb (is this correct???)
head-subj-phrase := decl-head-subj-phrase & head-initial & 
  [ SYNSEM.LOCAL [ CAT [ MC #mc, 
                       HEAD verb & [ PRD na, 
                                     SPEC-INIT - ] ], 
                   CONT.HOOK.XARG.COG-ST type-id ], 
    HEAD-DTR.SYNSEM.LOCAL.CAT [ MC #mc, 
                                VAL.COMPS < > ], 
    NON-HEAD-DTR.SYNSEM.NON-LOCAL non-local-none ].

subj-head-phrase :+ [ SYNSEM.LOCAL.CAT.HEAD.SPEC-INIT + ].

poss-unary-phrase-1 := poss-unary-phrase &
  [ ARGS < [ SYNSEM.LOCAL [ CAT [ POSSESSUM nonpossessive,
                                  HEAD [ POSSESSOR nonpossessive,
                                         CASE erg ] ],
                            CONT.HOOK.INDEX.PNG #png-um ] ] >,
    SYNSEM.LOCAL.CAT [ HEAD.SPEC-INIT +,
                       VAL.SPEC.FIRST.LOCAL.CAT.POSSESSUM possessum-1 &
                                                          [ POSS-AGR #png-um ] ] ].

spec-head-phrase := basic-head-spec-phrase & head-final &
  [ NON-HEAD-DTR.SYNSEM.LOCAL.CAT [ HEAD.SPEC-INIT +,
                                    VAL.SPEC < [ LOCAL.CAT.POSSESSUM #poss ] > ],
    HEAD-DTR.SYNSEM.LOCAL.CAT [ HEAD noun, 
                                POSSESSUM #poss ] ].

adj-spec-head-phrase := basic-head-spec-phrase & head-final &
  [ NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.SPEC-INIT +,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD adj ].

;;;mod
poss-unary-phrase := basic-unary-phrase &
  [ SYNSEM [ NON-LOCAL #nonloc,
             LOCAL.CAT [ HEAD det &
                              [ MOD < >,
                                POSSESSOR possessor ],
                         VAL [ SPR < >,
                               COMPS < >,
                               SUBJ < >,
                               SPEC < [ LOCAL.CAT [ VAL.COMPS < >,
                                                    HEAD noun &
                                                         [ PRON - ] ] ] > ] ] ],
    ARGS < [ INFLECTED infl-satisfied,
             SYNSEM [ LOCAL [ COORD -,
                              CAT [ VAL [ SPR < >,
                                          COMPS < >,
                                          SUBJ < >,
                                          SPEC < > ],
                                    HEAD +np &
                                         [ MOD < > ] ] ],
                      NON-LOCAL #nonloc ] ] > ].


;;; Feb 27, 2025: change uniq-id of SPEC.FIRST.LOCAL.CONT.HOOK.INDEX.COG-ST to activ-or-more.
noun-poss-unary-phrase-1 := poss-unary-phrase-1 &
  [ SYNSEM.LOCAL [ CONT.HOOK #hook,
                   CAT.VAL.SPEC < [ LOCAL.CONT.HOOK #hook &
                                                    [ INDEX #possessum &
                                                            [ COG-ST activ-or-more ],
                                                      LTOP #lbl ] ] > ],
    C-CONT [ HCONS.LIST < qeq &
                          [ HARG #harg,
                            LARG #lbl ] >,
             ICONS.LIST < >,
             RELS.LIST < quant-relation &
                         [ PRED "exist_q_rel",
                           ARG0 #possessum,
                           RSTR #harg ],
                         arg12-ev-relation &
                         [ PRED "poss_rel",
                           LBL #lbl,
                           ARG1 #possessum,
                           ARG2 #possessor ] > ],
    ARGS < [ SYNSEM.LOCAL.CONT.HOOK.INDEX #possessor ] > ].

;Constraint on MC used to be part of matrix.tdl
;;it applies to all wo implementations, except for v2

; Bare NP phrase.  Consider modifying the PRED value of the quantifier relation
; introduced to match the semantic effect of bare NPs in your language.

bare-np-phrase := basic-bare-np-phrase &
  [ C-CONT.RELS.LIST < [ PRED "exist_q_rel" ] >,
    SYNSEM.LOCAL [ CAT.HEAD.CASE #case,
                   CONT.HOOK.INDEX.PNG #png ],
    HEAD-DTR.SYNSEM.LOCAL [ CAT.HEAD.CASE #case,
                            CONT.HOOK.INDEX.PNG #png ] ].

;;; 2025-03-31 add [ ARGS.FIRST.SYNSEM.LOCAL.CAT.HEAD.MOD < > ] for both.
;;; 2025-11-13 remove SPR < > to allow predicative adjectives (their SPRs are degree modifiers)
;;; 2025-11-13 add [ ARGS.FIRST.SYNSEM.LOCAL.CONT.HOOK.INDEX.SF prop ] to avoid imp-head-opt-subj
morphological-subord-clause-phrase := unary-phrase & unary-nonloc-phrase &
  [ SYNSEM.LOCAL [ CAT [ MC -,
                         VAL [ SUBJ #subj,
                              ;  SPR < >,
                               SPEC < >,
                               COMPS < > ],
                         HEAD adp &
                              [ MOD < [ LOCAL scopal-mod &
                                              [ CAT [ HEAD verb,
                                                      VAL [ SPR < >,
                                                            COMPS < > ] ],
                                                CONT.HOOK [ LTOP #mcl,
                                                            INDEX #index ] ] ] > ] ],
                   COORD - ],
    C-CONT [ RELS.LIST < [ ARG1 #mch,
                           ARG2 #sch ] >,
             HCONS.LIST < qeq &
                          [ HARG #mch,
                            LARG #mcl ],
                          qeq &
                          [ HARG #sch,
                            LARG #scl ] >,
             ICONS.LIST < >,
             HOOK.INDEX #index ],
    ARGS < [ SYNSEM.LOCAL [ CAT [ HEAD +vj & [ 
                                              ;  MOD < >,
                                               PRD na-or-+ ],
                                  MC na-or-+,
                                  VAL [ SUBJ #subj,
                                        ; SPR < >,
                                        COMPS < > ] ],
                            CONT.HOOK [ LTOP #scl, 
                                        INDEX.SF prop ],
                            COORD - ] ] > ].

morphological-subord-clause-phrase-1 := unary-phrase & unary-nonloc-phrase &
  [ SYNSEM.LOCAL [ CAT [ MC #mc,
                         VAL [ SUBJ #subj,
                               SPR < >,
                               SPEC < >,
                               COMPS < > ],
                         HEAD adp &
                              [ MOD < [ LOCAL scopal-mod &
                                              [ CAT [ HEAD verb,
                                                      VAL [ SPR < >,
                                                            COMPS < > ] ],
                                                CONT.HOOK [ LTOP #mcl,
                                                            INDEX #index ] ] ] > ] ],
                   COORD - ],
    C-CONT [ RELS.LIST < [ ARG1 #mch,
                           ARG2 #sch ] >,
             HCONS.LIST < qeq &
                          [ HARG #mch,
                            LARG #mcl ],
                          qeq &
                          [ HARG #sch,
                            LARG #scl ] >,
             ICONS.LIST < >,
             HOOK.INDEX #index ],
    ARGS < [ SYNSEM.LOCAL [ CAT [ HEAD verb & [ MOD < > ],
                                  MC #mc & -,
                                  VAL [ SUBJ #subj,
                                        SPR < >,
                                        COMPS < > ] ],
                            CONT.HOOK.LTOP #scl,
                            COORD - ] ] > ].

;;;mod   delete #feat
causative-prehead-s-attach-modifying-clause-phrase := morphological-subord-clause-phrase & same-crf-unary-phrase &
  [ ARGS < [ SYNSEM.LOCAL [ CAT.VAL.SUBJ < >,
                            CONT.HOOK.INDEX.E.MOOD causative ] ] >,
    SYNSEM.LOCAL [ CAT [ HEAD.MOD < [ LOCAL.CAT.VAL.SUBJ < > ] >,
                         POSTHEAD - ] ],
    C-CONT.RELS.LIST < [ PRED "_because_subord_rel" ] > ].

;;; CCH 2025-11-15 add constraint on the mood of its modifee to avoid cntp modification clain explosion
cntp-prehead-s-attach-modifying-clause-phrase := morphological-subord-clause-phrase &
  [ ARGS < [ SYNSEM.LOCAL [ CAT.VAL.SUBJ < >,
                            CONT.HOOK.INDEX.E.MOOD contemporative ] ] >,
    SYNSEM.LOCAL [ CAT [ HEAD.MOD < [ LOCAL.CAT.VAL.SUBJ < >, 
                                      LOCAL.CONT.HOOK.INDEX.E.MOOD non-cntp-mood ] >,
                         POSTHEAD - ] ],
    C-CONT.RELS.LIST < [ PRED "_general_subord_rel" ] > ].

while-cntp-prehead-s-attach-modifying-clause-phrase := morphological-subord-clause-phrase-1 &
  [ ARGS < [ SYNSEM.LOCAL [ CAT [ VAL.SUBJ < >, 
                                  HEAD.DUR + ],
                            CONT.HOOK.INDEX.E.MOOD contemporative ] ] >,
    SYNSEM.LOCAL [ CAT [ HEAD [ MOD < [ LOCAL.CAT.VAL.SUBJ < > ] > ],
                         POSTHEAD - ] ],
    C-CONT.RELS.LIST < [ PRED "_while_subord_rel" ] > ].

;;;mod   del CONT.HOOK.INDEX.E.MOOD
head-comp-phrase := basic-head-1st-comp-phrase & head-initial &
  [ HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD verb &
                                   [ INIT + ] ].

;;; Wh-question-related phrasal types

; In-situ interrogative clause.

;;;mod   copy MC, constrain mood
;;; March 7th 2025:
;;; TODO: relax the interrogative mood constraint to include the subordinate moods, 
;;; when how the subordinate questions are formed have been understood
insitu-int-cl := interrogative-clause & head-only &
  [ C-CONT [ RELS.LIST < >,
             HCONS.LIST < > ],
    HEAD-DTR.SYNSEM [ LOCAL [ CAT [ MC #mc,
                                    HEAD verb,
                                    VAL #val &
                                      [ SUBJ < >,
                                        COMPS < > ] ], 
                              CONT.HOOK.INDEX.E.MOOD interrogative ],
                      NON-LOCAL [ SLASH.LIST < >,
                                  REL.LIST < >,
                                  QUE.LIST.FIRST ref-ind ] ],
    SYNSEM [ MODIFIED hasmod,
             NON-LOCAL [ SLASH.LIST < >,
                         QUE.LIST < >,
                         REL.LIST < > ],
             LOCAL.CAT [ VAL #val,
                         MC #mc & bool,
                         WH.BOOL + ] ] ].

;;;;;;;;;;;;;;;;;;
;;; Coordination
;;;;;;;;;;;;;;;;;;

;;; Feature Resolution Rules

any-any-pl-num-coord-rule := coord-phrase &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NUM pl ].

pass-up-png-coord-rule := bottom-coord-phrase &
  [ SYNSEM.LOCAL [ CAT.HEAD.CASE #case,
                   CONT.HOOK.INDEX.PNG #png ],
    NONCONJ-DTR.SYNSEM.LOCAL [ CAT.HEAD.CASE #case,
                               CONT.HOOK.INDEX.PNG #png ] ].

same-same-same-case-coord-rule := coord-phrase &
  [ SYNSEM.LOCAL.CAT.HEAD.CASE #case,
    LCOORD-DTR.SYNSEM.LOCAL.CAT.HEAD.CASE #case,
    RCOORD-DTR.SYNSEM.LOCAL.CAT.HEAD.CASE #case ].

1st-any-1st-per-coord-rule := coord-phrase &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.PER 1st,
    LCOORD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.PER 1st ].

;;; Feb 27, 2025: combine coord rules
2nd+3rd-1st-1st-per-coord-rule := coord-phrase &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.PER 1st,
    LCOORD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.PER 2nd+3rd,
    RCOORD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.PER 1st ].

2nd-3rd-2nd-per-coord-rule := coord-phrase &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.PER 2nd,
    LCOORD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.PER 2nd,
    RCOORD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.PER 3rd ].

3rd-2nd-2nd-per-coord-rule := coord-phrase &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.PER 2nd,
    LCOORD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.PER 3rd,
    RCOORD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.PER 2nd ].

3rd-3rd-3rd-per-coord-rule := coord-phrase &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.PER 3rd,
    LCOORD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.PER 3rd,
    RCOORD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.PER 3rd ].

;;; Coordination Strategy 1

;;; for unexpressed noun
head :+ [ UXP bool ]. 
basic-head-comp-phrase :+ [ NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.UXP - ].
head-mod-phrase :+ [ NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.UXP - ].

unexpr-np-top-coord-rule := base-basic-np-top-coord-rule & unexpressed-coord-phrase.
unexpr-apoly-top-coord-rule := base-apoly-top-coord-rule & unexpressed-coord-phrase.

unexpr-3rd-np-top-coord-rule := unexpr-np-top-coord-rule & unexpr-apoly-top-coord-rule & same-crf-unary-phrase & 
  [ SYNSEM.LOCAL [ COORD-STRAT "1", 
                   CONT.HOOK.INDEX.PNG [ PER 1st, NUM pl ], 
                   CAT.HEAD [ MIN nontime-noun-relation, 
                              CASE #case, 
                              UXP + ] ], 
    C-CONT.ICONS.LIST < #ikey & non-focus & [ IARG1 #ckey,
					                                    IARG2 #index ] >,
    LCOORD-DTR.SYNSEM.LOCAL.CONT.HOOK [ INDEX #index & [ PNG [ PER 1st, NUM sg ], 
                                                         COG-ST in-foc ], 
                                        ICONS-KEY #ikey,
		                                    CLAUSE-KEY #ckey ],
    RCOORD-DTR.SYNSEM.LOCAL [ CONT.HOOK.INDEX.PNG [ PER 3rd, NUM sg ], 
                              CAT.HEAD.CASE #case ] ].

np1-any-any-pl-same-same-same-1st-any-1st-top-coord-rule := basic-np-top-coord-rule & apoly-top-coord-rule & any-any-pl-num-coord-rule & same-same-same-case-coord-rule & 1st-any-1st-per-coord-rule &
  [ SYNSEM.LOCAL.COORD-STRAT "1" ].

np1-any-any-pl-same-same-same-2nd+3rd-1st-1st-top-coord-rule := basic-np-top-coord-rule & apoly-top-coord-rule & any-any-pl-num-coord-rule & same-same-same-case-coord-rule & 2nd+3rd-1st-1st-per-coord-rule &
  [ SYNSEM.LOCAL.COORD-STRAT "1" ].

np1-any-any-pl-same-same-same-2nd-3rd-2nd-top-coord-rule := basic-np-top-coord-rule & apoly-top-coord-rule & any-any-pl-num-coord-rule & same-same-same-case-coord-rule & 2nd-3rd-2nd-per-coord-rule &
  [ SYNSEM.LOCAL.COORD-STRAT "1" ].

np1-any-any-pl-same-same-same-3rd-2nd-2nd-top-coord-rule := basic-np-top-coord-rule & apoly-top-coord-rule & any-any-pl-num-coord-rule & same-same-same-case-coord-rule & 3rd-2nd-2nd-per-coord-rule &
  [ SYNSEM.LOCAL.COORD-STRAT "1" ].

np1-any-any-pl-same-same-same-3rd-3rd-3rd-top-coord-rule := basic-np-top-coord-rule & apoly-top-coord-rule & any-any-pl-num-coord-rule & same-same-same-case-coord-rule & 3rd-3rd-3rd-per-coord-rule &
  [ SYNSEM.LOCAL.COORD-STRAT "1" ].

;;;March 6th, 2025: add mid-coord-rules in kalaallisut.tdl and rules.tdl
np1-any-any-pl-same-same-same-1st-any-1st-mid-coord-rule := basic-np-mid-coord-rule & apoly-mid-coord-rule & any-any-pl-num-coord-rule & same-same-same-case-coord-rule & 1st-any-1st-per-coord-rule &
  [ SYNSEM.LOCAL.COORD-STRAT "1" ].

np1-any-any-pl-same-same-same-2nd+3rd-1st-1st-mid-coord-rule := basic-np-mid-coord-rule & apoly-mid-coord-rule & any-any-pl-num-coord-rule & same-same-same-case-coord-rule & 2nd+3rd-1st-1st-per-coord-rule &
  [ SYNSEM.LOCAL.COORD-STRAT "1" ].

np1-any-any-pl-same-same-same-2nd-3rd-2nd-mid-coord-rule := basic-np-mid-coord-rule & apoly-mid-coord-rule & any-any-pl-num-coord-rule & same-same-same-case-coord-rule & 2nd-3rd-2nd-per-coord-rule &
  [ SYNSEM.LOCAL.COORD-STRAT "1" ].

np1-any-any-pl-same-same-same-3rd-2nd-2nd-mid-coord-rule := basic-np-mid-coord-rule & apoly-mid-coord-rule & any-any-pl-num-coord-rule & same-same-same-case-coord-rule & 3rd-2nd-2nd-per-coord-rule &
  [ SYNSEM.LOCAL.COORD-STRAT "1" ].

np1-any-any-pl-same-same-same-3rd-3rd-3rd-mid-coord-rule := basic-np-mid-coord-rule & apoly-mid-coord-rule & any-any-pl-num-coord-rule & same-same-same-case-coord-rule & 3rd-3rd-3rd-per-coord-rule &
  [ SYNSEM.LOCAL.COORD-STRAT "1" ].

apoly-mid-coord-rule := mid-coord-rule &
  [ LCOORD-DTR.SYNSEM.LOCAL.COORD -,
    RCOORD-DTR.SYNSEM.LOCAL.COORD + ].

;;;mod   add NON-LOCAL.CONJP.LIST < *top* >
;;; CCH 2025-11-16 add [ HEAD.UXP - ] to prevent further participating the unexpressed rule
np1-bottom-coord-rule := unary-bottom-coord-rule & np-bottom-coord-phrase & pass-up-png-coord-rule &
  [ SYNSEM.LOCAL [ COORD-STRAT "1",
                   COORD-REL.PRED "_and_coord_rel" ], 
    NONCONJ-DTR.SYNSEM [ NON-LOCAL.CONJP.LIST < *top* >,
                         LOCAL.CAT.HEAD.UXP - ] ].

; np1-bottom-coord-rule :+ [ SYNSEM.NON-LOCAL.CONJP.LIST < > ].

; np1-bottom-coord-rule :+ 
;   [ SYNSEM.LOCAL.CAT.HEAD.TIME #time, 
;     NONCONJ-DTR.SYNSEM.LOCAL.CAT.HEAD.TIME #time ].
np1-bottom-coord-rule :+ 
  [ SYNSEM.LOCAL.CAT.HEAD.MIN #rel, 
    NONCONJ-DTR.SYNSEM.LOCAL.CAT.HEAD.MIN #rel ].

;;; TODO: relax these
; basic-np-top-coord-rule :+ [ SYNSEM.LOCAL.CAT.HEAD.TIME - ].
; basic-np-mid-coord-rule :+ [ SYNSEM.LOCAL.CAT.HEAD.TIME - ].
basic-np-top-coord-rule :+ [ SYNSEM.LOCAL.CAT.HEAD.MIN nontime-noun-relation ].
basic-np-mid-coord-rule :+ [ SYNSEM.LOCAL.CAT.HEAD.MIN nontime-noun-relation ].

;;; Coordination Strategy 1

;;; CCH 2025-11-15 constrain mood of LCOORD-DTR to avoid explosion
vp1-top-coord-rule := basic-vp-top-coord-rule & apoly-top-coord-rule &
  [ SYNSEM.LOCAL.COORD-STRAT "1", 
    LCOORD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.E.MOOD non-cntp-mood ].

;;;mod   add NON-LOCAL.CONJP.LIST < *top* >
;;; 2025-03-31 relax unary-bottom-coord in this case
;;; 2025-11-12 remove the requirement of CONJP as long as contemporative is there
;;; however, note that 
vp1-bottom-coord-rule := unique-subj-relax-unary-bottom-coord-rule & vp-bottom-coord-phrase &
  [ SYNSEM.LOCAL [ COORD-STRAT "1",
                   COORD-REL.PRED "_and_coord_rel", 
                   CONT.HOOK.INDEX.E.MOOD contemporative ]
    ; NONCONJ-DTR.SYNSEM.NON-LOCAL.CONJP.LIST < *top* >  
    ].

; vp-runon-bottom-coord-rule := unique-subj-relax-unary-bottom-coord-rule & vp-bottom-coord-phrase &
;   [ SYNSEM.LOCAL [ COORD-STRAT "1",
;                    COORD-REL.PRED "_implicit_coord_rel", 
;                    CONT.HOOK.INDEX.E.MOOD indicative ]  ].

;;; Coordination Strategy 1

;;; 2025-03-31 It seems that I can claim [ PRD na-or-+ ] for all the args.
;;; this also ensures that rel-mod will be performed AFTER S coordination.
;;; requiring =lu
s1-top-coord-rule := basic-s-top-coord-rule & apoly-top-coord-rule &
  [ SYNSEM.LOCAL.COORD-STRAT "1" ].

;;; not caring about =lu
s2-top-coord-rule := basic-s-top-coord-rule & apoly-top-coord-rule &
  [ SYNSEM.LOCAL.COORD-STRAT "2" ].

; s1-top-coord-rule :+ [ SYNSEM.NON-LOCAL.CONJP.LIST < > ].

;;; 2025-11-14 CCH let CNTP inherit the SF of the "main" clause to prevent imp-head-opt-subj in declarative
;;; 2025-11-15 CCH contrains LCOORD-DTR to be non-cntp-mood to avoid explosion
right-cntp-s2-top-coord-rule := s2-top-coord-rule & 
  [ LCOORD-DTR.SYNSEM [ PUNCT.MPUNCT no-punct, 
                        LOCAL.CONT.HOOK.INDEX [ E.MOOD non-cntp-mood, 
                                                SF #sf ] ], 
    RCOORD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX [ E.MOOD contemporative,
                                              SF #sf ] ].

both-ind-s1-top-coord-rule := s1-top-coord-rule & 
  [ SYNSEM.PUNCT.MPUNCT #rpunct,
    LCOORD-DTR.SYNSEM [ LOCAL.CONT.HOOK.INDEX.E.MOOD indicative, 
                        PUNCT.RPUNCT #rpunct ], 
    RCOORD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.E.MOOD indicative ].

;;; must be without =lu
runon-top-coord-rule := basic-s-top-coord-rule & apoly-top-coord-rule &
  [ SYNSEM.PUNCT.MPUNCT comma-punct,
    SYNSEM.LOCAL.COORD-STRAT "runon", 
    LCOORD-DTR.SYNSEM [ LOCAL.CONT.HOOK.INDEX.E.MOOD matrix_mood, 
                        PUNCT.RPUNCT comma-punct ], 
    RCOORD-DTR.SYNSEM [ LOCAL.CONT.HOOK.INDEX.E.MOOD matrix_mood, 
                        PUNCT.LPUNCT no-punct ] ].

;;; CCH 2025-11-15 banning DUR explosion
basic-s-top-coord-rule :+ [ SYNSEM.LOCAL.CAT.HEAD.DUR - ].

; s1-bottom-coord-rule := conj-first-bottom-coord-rule & s-bottom-coord-phrase &
;   [ SYNSEM.LOCAL [ CAT.HEAD.FORM #form,
; 		   COORD-STRAT "1" ],
;     NONCONJ-DTR.SYNSEM.LOCAL.CAT.HEAD.FORM #form ].

;;;mod   add NON-LOCAL.CONJP.LIST < *top* >, AND new s-bottom-coord-phrase type
s1-bottom-coord-rule := unary-bottom-coord-rule & s-bottom-coord-phrase_2 &
  [ SYNSEM [ LOCAL [ COORD-STRAT "1", 
                     COORD-REL.PRED #pred-name ] ], 
    NONCONJ-DTR.SYNSEM.NON-LOCAL.CONJP.LIST < #pred-name > ].

s1-and-bottom-coord-rule := s1-bottom-coord-rule & 
  [ SYNSEM.LOCAL.COORD-REL.PRED "_and_coord_rel" ].

s1-but-bottom-coord-rule := s1-bottom-coord-rule & 
  [ SYNSEM.LOCAL.COORD-REL.PRED "_but_coord_rel" ].

s1-bottom-coord-rule :+ [ SYNSEM.NON-LOCAL [ CRF-H #crf-h, CRF.LIST < > ],
                             ARGS < [ SYNSEM.NON-LOCAL [ CRF-H #crf-h, CRF.LIST < > ] ] > ].

;;; not caring about =lu; indeed here the default will be _and_coord_rel
s2-bottom-coord-rule := unary-bottom-coord-rule & s-bottom-coord-phrase_2 &
  [ SYNSEM [ LOCAL [ COORD-STRAT "2",
                     COORD-REL.PRED "_and_coord_rel" ] ] ].

s2-bottom-coord-rule :+ [ SYNSEM.NON-LOCAL [ CRF-H #crf-h, CRF.LIST < > ],
                             ARGS < [ SYNSEM.NON-LOCAL [ CRF-H #crf-h, CRF.LIST < > ] ] > ].

s-runon-bottom-coord-rule := unary-bottom-coord-rule & s-bottom-coord-phrase_2 &
  [ SYNSEM [ LOCAL [ COORD-STRAT "runon",
                     COORD-REL.PRED "_implicit_coord_rel" ] ], 
    NONCONJ-DTR.SYNSEM.NON-LOCAL.CONJP.LIST < > ].

s-runon-bottom-coord-rule :+ [ SYNSEM.NON-LOCAL [ CRF-H #crf-h, CRF.LIST < > ],
                             ARGS < [ SYNSEM.NON-LOCAL [ CRF-H #crf-h, CRF.LIST < > ] ] > ].

;;;mod   new s-bottom-coord-phrase type for NON-LOCAL
;;; 2025-03-25 move cntp constraint to top-coord-rule
;;; 2025-11-13 add [ PRD na-or-+ ] to avoid numeral-adj with case ending to participate
s-bottom-coord-phrase_2 := bottom-coord-phrase &
  [ SYNSEM [ LOCAL [CAT [ HEAD #head,
                       VAL.SUBJ < > ] ],
             NON-LOCAL non-local-sqr-none ],
    NONCONJ-DTR.SYNSEM [ LOCAL.CAT [ HEAD #head & +vj & [ PRD na-or-+ ],
                                   VAL.SUBJ < > ],
                         NON-LOCAL non-local-sqr-none ]].

;;; March 7, 2025 fix R-HNDL not identified with the LTOP of daughter verb predication
s-bottom-coord-phrase_2 :+ 
  [ SYNSEM.LOCAL.COORD-REL.R-HNDL #ltop, 
    NONCONJ-DTR.SYNSEM.LOCAL.CONT.HOOK.LTOP #ltop ].

vp1-bottom-coord-rule :+ 
  [ SYNSEM.LOCAL.COORD-REL.R-HNDL #ltop, 
    NONCONJ-DTR.SYNSEM.LOCAL.CONT.HOOK.LTOP #ltop ].

;;;mod adj coord
adj1-top-coord-rule := basic-adj-top-coord-rule & apoly-top-coord-rule &
  [ SYNSEM.LOCAL [ CAT.HEAD.PRD #prd, 
                   COORD-STRAT "1" ], 
    LCOORD-DTR.SYNSEM.LOCAL.CAT.HEAD.PRD #prd, 
    RCOORD-DTR.SYNSEM.LOCAL.CAT.HEAD.PRD #prd ].

;;;mod   add NON-LOCAL.CONJP.LIST < *top* >
adj1-bottom-coord-rule := unique-spr-relax-unary-bottom-coord-rule & adj-bottom-coord-phrase &
  [ SYNSEM.LOCAL [ COORD-STRAT "1",
                   COORD-REL.PRED "_and_coord_rel", 
                   CONT.HOOK.INDEX.E.MOOD contemporative ], 
    NONCONJ-DTR.SYNSEM.NON-LOCAL.CONJP.LIST < *top* >  ].

adj1-bottom-coord-rule :+ 
  [ SYNSEM.LOCAL.CAT.HEAD [ PRD #prd, INCORP #incorp ], 
    NONCONJ-DTR.SYNSEM.LOCAL.CAT.HEAD [ PRD #prd, INCORP #incorp ] ].

adj1-top-coord-rule :+ 
  [ SYNSEM.LOCAL.CAT.HEAD [ PRD #prd, INCORP #incorp ], 
    LCOORD-DTR.SYNSEM.LOCAL.CAT.HEAD [ PRD #prd, INCORP #incorp ], 
    RCOORD-DTR.SYNSEM.LOCAL.CAT.HEAD [ PRD #prd, INCORP #incorp ] ].

;;;mod    ALL BELOW
;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Conjunction particle
;;;;;;;;;;;;;;;;;;;;;;;;;;;

base-conj-lex := no-hcons-lex-item & zero-arg-conjp &
  [ SYNSEM [ LOCAL [ CAT [ VAL [ SPR < >,
                                COMPS < >,
                                SUBJ < >,
                                SPEC < > ],
                          HEAD adv ],
                    CONT.RELS.LIST < > ],
            NON-LOCAL [ CONJP.LIST < string >, 
                        CRF.LIST < >, 
                        CRF-H.LIST < > ] ] ].

conj-clitic-lex := base-conj-lex &
  [ SYNSEM.LOCAL.CAT [ POSTHEAD +, 
                       HEAD.MOD < [ LIGHT +,
                                    LOCAL intersective-mod &
                                        [ CAT.HEAD +nvjr ],
                                  L-PERIPH +,
                                  L-QUE - ] > ] ].

;;; 2025-11-12 There can be bettter formulation; maybe referring to the English and, as (usually) it is in the same position
conj-particle-lex := base-conj-lex & 
  [ SYNSEM.LOCAL.CAT [ POSTHEAD -,
                       HEAD.MOD < [ LOCAL intersective-mod &
                                        [ CAT [ HEAD +vj & [ MOD < > ], 
                                                VAL [ SUBJ < >, 
                                                      COMPS < >, 
                                                      SPR < >, 
                                                      SPEC < > ] ] ],
                                  L-QUE - ] > ] ].

non-local :+ [ CONJP append-list ].

non-local-none :+ [ CONJP.LIST < > ].

basic-filler-phrase :+ [ SYNSEM.NON-LOCAL [ CONJP.LIST < >,
                                            SLASH.LIST < > ],
    ARGS < [ SYNSEM [ LOCAL #slash,
                      NON-LOCAL.SLASH.LIST < > ] ],
           [ SYNSEM.NON-LOCAL.SLASH.LIST < #slash > ] > ].

basic-extracted-adj-phrase :+ [ SYNSEM.NON-LOCAL.CONJP #conjp,
                                HEAD-DTR.SYNSEM.NON-LOCAL.CONJP #conjp ].

coord-phrase :+ 
  [ SYNSEM.NON-LOCAL.CONJP.APPEND < #conjp1, #conjp2 >,
    LCOORD-DTR.SYNSEM.NON-LOCAL.CONJP #conjp1,
    RCOORD-DTR.SYNSEM.NON-LOCAL.CONJP #conjp2 ].

basic-binary-phrase :+ 
  [ SYNSEM [ L-PERIPH #periph,
             NON-LOCAL.CONJP.APPEND < #conjp1, #conjp2 > ],
    ARGS < [ SYNSEM [ L-PERIPH #periph,
                      NON-LOCAL.CONJP #conjp1 ] ],
           [ SYNSEM [ L-PERIPH -,
                      NON-LOCAL.CONJP #conjp2 ] ] > ].

zero-arg-nonconjp := basic-zero-arg &
  [ SYNSEM.NON-LOCAL.CONJP.LIST < > ].

zero-arg-conjp := zero-arg-nonrel & zero-arg-nonque & zero-arg-nonslash.

norm-zero-arg :+ zero-arg-nonconjp.

zero-arg-rel :+ zero-arg-nonconjp.

zero-arg-que :+ zero-arg-nonconjp.

zero-arg-slash :+ zero-arg-nonconjp.

non-conjp-word := word-or-lexrule &
  [ SYNSEM.NON-LOCAL.CONJP.LIST < > ].

non-local-none-lex-item :+ non-conjp-word.

intersective-mod-lex :+ non-conjp-word.

same-periph-unary-phrase := unary-phrase &
  [ SYNSEM.L-PERIPH #periph,
    ARGS < [ SYNSEM.L-PERIPH #periph ] > ].

same-conjp-unary-phrase := unary-phrase &
  [ SYNSEM.NON-LOCAL.CONJP #conjp,
    ARGS < [ SYNSEM.NON-LOCAL.CONJP #conjp ] > ].

bare-np-phrase :+ same-periph-unary-phrase & same-conjp-unary-phrase &
  [ SYNSEM.LIGHT - ].

;;;non-verbal predicates
;;; 2025-03-26 TODO: you need to avoid pp-phrase modifying the following stuff:
;;; [ HEAD.PRD +, VAL [ COMPS cons, INCORP-N cons ] ]
;;; 2025-10-27 relax this to be HEAD +vj.
pp-phrase := unary-phrase &
[ SYNSEM [ NON-LOCAL #nl & [ CRF-H.LIST < > ],
           LOCAL.CAT [ HEAD adp & [ MOD < [ LOCAL intersective-mod &
                                                    [ CAT.HEAD +vj,
                                                      CONT.HOOK.INDEX #xarg ] ] > ],
                       VAL [ COMPS < >,
                             SUBJ < >,
                             SPEC < >,
                             SPR < > ],
                       POSTHEAD - ], 
           LIGHT - ],
    C-CONT [ HOOK [ LTOP #ltop,
		    INDEX #index,
		    XARG #xarg ],
	  RELS.LIST < arg12-ev-relation &
		   [ LBL #ltop,
		     ARG0 #index,
		     ARG1 #xarg,
		     ARG2 #dtr ] >,
	     HCONS.LIST < >  ],
	  ARGS < [ SYNSEM [ NON-LOCAL #nl,
		                  LOCAL [ CAT [ HEAD noun & [ MOD < > ],
		                                VAL.SPR < > ],
			                        CONT.HOOK.INDEX #dtr, 
                              COORD - ] ] ] > ]
"""Mother type of prepositional phrases that turns nouns with oblique cases into verb-modifying PPs.""".

pp-phrase :+ [ ARGS.FIRST.SYNSEM.LOCAL.CAT.HEAD.UXP - ].

; possessum-lex-rule-1 :+ 
;   [ SYNSEM.LOCAL.CAT.HEAD.TIME #time, 
;     DTR.SYNSEM.LOCAL.CAT.HEAD.TIME #time ].
possessum-lex-rule-1 :+ 
  [ SYNSEM.LOCAL.CAT.HEAD.MIN #rel, 
    DTR.SYNSEM.LOCAL.CAT.HEAD.MIN #rel ].

abs-time-pp-phrase := pp-phrase & 
  [ C-CONT.RELS.LIST.FIRST.PRED "_abs_p_rel", 
    ARGS.FIRST.SYNSEM [ LOCAL.CAT [ HEAD [ CASE abs, 
                                        ;  TIME +, 
                                         MIN time-relation,
                                         PRON -, 
                                         NMZ - ] ],
                        NON-LOCAL non-local-none ] ].

locative-pp-phrase := pp-phrase & 
  [ C-CONT.RELS.LIST.FIRST.PRED "_loc_p_rel", 
    ARGS.FIRST.SYNSEM.LOCAL.CAT.HEAD.CASE loc ].

instrumental-pp-phrase := pp-phrase & 
  [ C-CONT.RELS.LIST.FIRST.PRED "_instr_p_rel", 
    ARGS.FIRST.SYNSEM.LOCAL.CAT.HEAD.CASE ins ].

allative-pp-phrase := pp-phrase & 
  [ C-CONT.RELS.LIST.FIRST.PRED "_allative_p_rel", 
    ARGS.FIRST.SYNSEM.LOCAL.CAT.HEAD.CASE all ].

ablative-pp-phrase := pp-phrase & 
  [ C-CONT.RELS.LIST.FIRST.PRED "_ablative_p_rel", 
    ARGS.FIRST.SYNSEM.LOCAL.CAT.HEAD.CASE abl ].

equative-pp-phrase := pp-phrase & 
  [ C-CONT.RELS.LIST.FIRST.PRED "_equative_p_rel", 
    ARGS.FIRST.SYNSEM.LOCAL.CAT.HEAD.CASE equ ].

vialis-pp-phrase := pp-phrase & 
  [ C-CONT.RELS.LIST.FIRST.PRED "_vialis_p_rel", 
    ARGS.FIRST.SYNSEM.LOCAL.CAT.HEAD.CASE via ].

;;;mod
;;; For: adj mods, rel-cl mods =lu
head-adj-int-phrase2 := head-adj-int-phrase & 
  [ SYNSEM.LOCAL.CAT.POSSESSUM #possessum, 
    HEAD-DTR.SYNSEM [ LOCAL.CAT.POSSESSUM #possessum, 
                      NON-LOCAL.CONJP.LIST < > ], 
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD [ PRD na-or--, 
                                         INCORP na-or--, 
                                         DBT na-or--, 
                                         DUR na-or-- ] ].

head-adj-int-phrase2 :+ [ HEAD-DTR.SYNSEM.L-PERIPH #periph,
                          NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.MOD < [ L-PERIPH #periph ] > ].

head-adj-int-phrase2 :+ [ SYNSEM.LOCAL.CAT.POSTHEAD #pthd, 
                          HEAD-DTR.SYNSEM.LOCAL.CAT.POSTHEAD #pthd ].

;;; March 7th, 2025: relative clause LR temporary constraint 
;;; March 11th, 2025: now already removed
;;;head-adj-int-phrase2 :+ [ NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS < > ].

base-unary-bottom-coord-rule :+ [ SYNSEM.NON-LOCAL.CONJP.LIST < > ].

;;;unary-bottom-coord-rule :+ [ SYNSEM.NON-LOCAL.CONJP #conjp, 
;;;                             ARGS.FIRST.SYNSEM.NON-LOCAL.CONJP #conjp ].

;;;top-coord-rule :+ [ SYNSEM.NON-LOCAL.CONJP.LIST < > ].

;;; 2025-11-12 add phr-synsem because we want [LIGHT -] for punct-phrase
adj-head-int-phrase2 := adj-head-int-phrase & 
  [ SYNSEM phr-synsem, 
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD [ INCORP na-or--, 
                                         PRD na-or--, 
                                         DBT na-or--,
                                         DUR na-or-- ] ].

;;; Noun incorporation and Adjective modification

;;;mod NP Pred  & non-local-none
noun_pred_affix-lex-rule-super := same-non-local-lex-rule & infl-lex-rule & tense-rule-dtr & 
  [ INFLECTED [ TENSE-FLAG -,
                NEG_V_END_FLAG na-or--, 
                V_END-OR-V_END_NEG-FLAG -,
                CL_Q_TRANS_V-VERB-OR-CL_TRANS_V-VERB-FLAG na ],
    SYNSEM [ LOCAL.CAT [ HEAD verb & [ MOD null, 
                                       PRD +,
                                       SPEC-INIT +, 
                                       DUR - ], 
                         VAL [ --KEYCOMP non-synsem, 
                               SPR < >, 
                               COMPS #comps, 
                               SPEC < >,
                               INCORP-N < [ LOCAL [ CAT [ HEAD #n-hd, 
                                                                    VAL [ SUBJ #subj, 
                                                                          COMPS < >, 
                                                                          SPR #spr, 
                                                                          SPEC #spec ] ], 
                                                              CONT #n-cont ],
                                            NON-LOCAL #nl ] >, 
                               SUBJ < [ LOCAL [ CAT cat-sat & [ HEAD noun & [ CASE abs ], 
                                                                VAL.SPR < > ],
                                                CONT.HOOK.INDEX #xarg ] ] > ] ],
             NON-LOCAL #nl ],
    C-CONT [ HOOK [ LTOP #lbl,
                    XARG #xarg,
                    INDEX #ind ],
             RELS.LIST < arg1-ev-relation &
                  [ LBL #lbl,
                    ARG0 #ind,
                    ARG1 #xarg,
                    ARG2 #arg2],
              quant-relation & [ PRED "exist_q_rel",
                                 ARG0 #arg2,
                                 RSTR #harg ] >,
             HCONS.LIST < qeq & [ HARG #harg, LARG #larg ] >,
             ICONS.LIST < > ], 
    DTR noun_pred_affix-lex-rule-dtr &
          [ SYNSEM [ LOCAL [ CAT [ HEAD #n-hd, 
                                   VAL [ SUBJ #subj, 
                                         COMPS #comps, 
                                         SPR #spr, 
                                         SPEC #spec ] ], 
                             CONT #n-cont & [ HOOK [LTOP #larg, INDEX #arg2 ] ] ],
                     NON-LOCAL #nl ] ] ].

noun_pred_u-lex-rule := noun_pred_affix-lex-rule-super & 
  [ C-CONT.RELS.LIST.FIRST.PRED "_be_v_id_rel" ].

noun_pred_nnguq-lex-rule := noun_pred_affix-lex-rule-super & 
  [ C-CONT.RELS.LIST.FIRST.PRED "_become_v_rel" ].

;;; 2025-11-12 CCH: temporarily added, but this may not be a typical example of a "linking verb"
noun_pred_irute-lex-rule := noun_pred_affix-lex-rule-super & 
  [ C-CONT.RELS.LIST.FIRST.PRED "_be+no+more_v_rel" ].

incorp-verb-dtr := word-or-lexrule.

;;; 2025-11-13 add [PRD na-or--]
incorp-lex-rule := lex-rule & 
  [ SYNSEM [ LOCAL [ CAT [ HEAD verb & [ INCORP +, 
                                         MOD null, 
                                         SPEC-INIT +, 
                                         PRD na-or--, 
                                         DUR - ], 
                           VAL [ SPR < >, 
                                 SPEC < >,
                                 INCORP-N < [ LOCAL [ CAT [ HEAD #n-hd, 
                                                            VAL [ SUBJ #subj, 
                                                                  SPR #spr, 
                                                                  SPEC #spec ] ], 
                                                      CONT #n-cont & [ HOOK [LTOP #larg, INDEX #arg2 ] ] ],
                                              NON-LOCAL #nl ] > ] ] ] ], 
    DTR noun_incorp-rule-dtr & [ SYNSEM [ LOCAL [ CAT [ HEAD #n-hd, 
                                                        VAL [ SUBJ #subj, 
                                                              SPR #spr, 
                                                              SPEC #spec ] ], 
                                                  CONT #n-cont & [ HOOK [LTOP #larg, INDEX #arg2 ] ] ],
                                          NON-LOCAL #nl ] ] ].

;;2025-11-10 add COMPS from noun
common-incorp-lex-rule := incorp-lex-rule & 
  [ SYNSEM.LOCAL.CAT.VAL [ COMPS #comps, 
                           INCORP-N < [ LOCAL.CAT.VAL.COMPS < > ] >,
                           --KEYCOMP non-synsem ], 
    C-CONT [  HOOK [ LTOP #lbl,
                     XARG #xarg,
                     INDEX #ind ],
              RELS.LIST < arg12-ev-relation &
                  [ LBL #lbl,
                    ARG0 #ind,
                    ARG1 #xarg,
                    ARG2 #arg2],
                  quant-relation & [ PRED "exist_q_rel",
                                     ARG0 #arg2,
                                     RSTR #harg ] >,
              HCONS.LIST < qeq & [ HARG #harg, LARG #larg ] >,
              ICONS.LIST < > ], 
    DTR.SYNSEM.LOCAL [ CONT.HOOK [ LTOP #larg, INDEX #arg2 ], 
                       CAT.VAL.COMPS #comps ] ].

;;; 2025-03-25 this [ SPEC-INIT + ] should be temporary
incorp-lex-rule-super := infl-lex-rule & incorp-lex-rule & 
  [ INFLECTED [ NEG_V_END_FLAG na-or--, 
                CL_Q_TRANS_V-VERB-OR-CL_TRANS_V-VERB-FLAG na ] ].

incorp-verb-lex-rule := incorp-lex-rule-super & tense-rule-dtr & same-non-local-lex-rule & aspect-rule-dtr & modal-rule-dtr & 
  [ SYNSEM [ LOCAL.CAT [ HEAD [ DBT -, 
                                DUR - ], 
                         VAL.INCORP-N.FIRST.NON-LOCAL.QUE #que ], 
             NON-LOCAL [ SLASH.LIST < >,
                         REL.LIST < >,    
                         QUE #que,                      
                         CONJP.LIST < > ] ], 
    INFLECTED [ TENSE-FLAG -, 
                V_END-OR-V_END_NEG-FLAG - ] ].

incorp-part-lex-rule := incorp-lex-rule-super & common-incorp-lex-rule & part_num_case-rule-dtr & 
  [ INFLECTED.NUM_CASE_END-FLAG -, 
    SYNSEM [ LOCAL.CAT.HEAD.PRD -, 
             NON-LOCAL [ QUE #que, 
                         REL #rel, 
                         CRF.LIST #crf, 
                         CRF-H.LIST #crf-h ] ],
    C-CONT.HOOK.INDEX.SF prop, 
    DTR.SYNSEM.NON-LOCAL [ QUE #que, 
                           REL #rel, 
                           CRF.LIST #crf & < >, 
                           CRF-H.LIST #crf-h & < > ] ].

intrans-part-like-incorp-lex-rule := incorp-part-lex-rule & 
  [ SYNSEM [ LOCAL.CAT [ HEAD.REF -, 
                         VAL.SUBJ < > ], 
             NON-LOCAL [ SLASH.LIST < [ CAT cat-sat & [ HEAD noun, 
                                                        VAL.SPR < > ],
                                        CONT.HOOK.INDEX #xarg ] >, 
                         CONJP #conjp ] ], 
    C-CONT.HOOK.XARG #xarg, 
    DTR [ SYNSEM [ NON-LOCAL [ SLASH.LIST < >, 
                               CONJP #conjp ] ] ] ].

pass-part-like-incorp-lex-rule := incorp-part-lex-rule & 
  [ SYNSEM [ LOCAL.CAT [ HEAD.REF +, 
                         VAL.SUBJ < [ LOCAL [ CAT cat-sat & [ HEAD noun & [ CASE erg ], 
                                                            VAL.SPR < > ],
                                            CONT.HOOK.INDEX #xarg ] ] > ], 
             NON-LOCAL [ SLASH.LIST < [ CAT cat-sat & [ HEAD noun, 
                                                        VAL.SPR < > ],
                                        CONT.HOOK.INDEX #arg2 ] >, 
                         CONJP #conjp ] ], 
    C-CONT.HOOK.XARG #xarg, 
    DTR [ SYNSEM [ LOCAL.CONT.HOOK.INDEX #arg2, 
                   NON-LOCAL [ SLASH.LIST < >, 
                               CONJP #conjp ] ] ] ].

lik-part-lex-rule := intrans-part-like-incorp-lex-rule & 
  [ C-CONT.RELS.LIST.FIRST.PRED "_have_v_rel" ].

siaq-part-lex-rule := pass-part-like-incorp-lex-rule & 
  [ C-CONT.RELS.LIST.FIRST.PRED "_buy_v_rel" ].

lijaq-part-lex-rule := pass-part-like-incorp-lex-rule & 
  [ C-CONT.RELS.LIST.FIRST.PRED "_make_v_rel" ].

common-incorp-verb-lex-rule := incorp-verb-lex-rule & common-incorp-lex-rule & 
  [ SYNSEM.LOCAL.CAT.VAL [ SUBJ < [ LOCAL [ CAT cat-sat & [ HEAD noun & [ CASE abs ], 
                                                            VAL.SPR < > ],
                                            CONT.HOOK [ INDEX #xarg, 
                                                        ICONS-KEY.IARG1 #ind, 
                                                        CLAUSE-KEY #ind ]  ] ] > ], 
    C-CONT.HOOK [ XARG #xarg, 
                  INDEX #ind ] ].

trans-incorp-verb-lex-rule := incorp-verb-lex-rule & 
  [ SYNSEM.LOCAL.CAT [ VAL [ SUBJ < [ LOCAL [ CAT cat-sat & [ HEAD noun & [ CASE erg ], 
                                                              VAL.SPR < > ] ] ] >, 
                             COMPS < #mark-obj & 
                                        [ LOCAL [ CAT cat-sat & [ HEAD noun & [ CASE abs ], 
                                                                  VAL.SPR < > ],
                                                  CONT.HOOK [ ICONS-KEY.IARG1 #ind, 
                                                              CLAUSE-KEY #ind ] ] ] >, 
                             --KEYCOMP #mark-obj ] ],
    C-CONT [  HOOK.INDEX #ind,
              RELS.LIST.REST.FIRST quant-relation & [ PRED "exist_q_rel",
                                                          ARG0 #incorp-n,
                                                          RSTR #harg ], 
              HCONS.LIST < qeq & [ HARG #harg, LARG #larg ] >,
              ICONS.LIST < > ], 
    DTR.SYNSEM.LOCAL.CONT.HOOK [ LTOP #larg, 
                                 INDEX #incorp-n ] ].

;;; TODO: incorporating complements of rel-noun or not?
;;; Alternative: adj must MOD noun with COMPS < >. this ensures first complementing.
;;; for incorp, there is a special case of head-complement and head-opt-comp (???)
incorp-poss-verb-lex-rule := trans-incorp-verb-lex-rule & 
  [ SYNSEM.LOCAL.CAT [ VAL [ SUBJ < [ LOCAL.CONT.HOOK [ INDEX #subj-arg, 
                                                        ICONS-KEY.IARG1 #poss-e,
                                                        CLAUSE-KEY #poss-e ] ] >, 
                             COMPS < [ LOCAL.CONT.HOOK [ INDEX #comps-arg, 
                                                         ICONS-KEY.IARG1 #ind, 
                                                         CLAUSE-KEY #ind ] ] > ] ],
    C-CONT [  HOOK [ LTOP #lbl,
                     XARG #comps-arg,
                     INDEX #ind ],
              RELS.LIST < arg12-ev-relation &
                  [ PRED "_be_v_id_rel", 
                    LBL  #lbl,
                    ARG0 #ind,
                    ARG1 #comps-arg,
                    ARG2 #possessum ],
                  [ ], 
                  arg12-ev-relation &
                  [ PRED "poss_rel",
                    LBL  #larg,
                    ARG0 #poss-e, 
                    ARG1 #possessum,
                    ARG2 #subj-arg ] > ], 
    DTR.SYNSEM.LOCAL.CONT.HOOK [ LTOP #larg, 
                                 INDEX #possessum ] ].

normal-trans-incorp-verb-lex-rule := trans-incorp-verb-lex-rule & 
  [ SYNSEM.LOCAL.CAT.VAL [ SUBJ < [ LOCAL.CONT.HOOK[ INDEX #subj-arg,
                                                     ICONS-KEY.IARG1 #ind,
                                                     CLAUSE-KEY #ind] ] >, 
                           COMPS < [ LOCAL.CONT.HOOK.INDEX #comps-arg ] > ],
    C-CONT [ HOOK [ LTOP #lbl, INDEX #ind ], 
             RELS.LIST < arg123-ev-relation & 
                    [ LBL #lbl, 
                      ARG0 #ind, 
                      ARG1 #subj-arg, 
                      ARG2 #incorp-arg,
                      ARG3 #comps-arg ], 
                    [ ] > ], 
    DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #incorp-arg ].

liq-provide-lex-rule := normal-trans-incorp-verb-lex-rule & 
 [ C-CONT.RELS.LIST.FIRST.PRED "_provide+with_v_rel" ].

qaq-incorp-lex-rule := common-incorp-verb-lex-rule & 
 [ C-CONT.RELS.LIST.FIRST.PRED "_have_v_rel" ].

tuq-incorp-lex-rule := common-incorp-verb-lex-rule & 
 [ C-CONT.RELS.LIST.FIRST.PRED "_consume_v_rel" ].

siuq-incorp-lex-rule := common-incorp-verb-lex-rule & 
 [ C-CONT.RELS.LIST.FIRST.PRED "_search+for_v_rel" ].

si-incorp-lex-rule := common-incorp-verb-lex-rule & 
 [ C-CONT.RELS.LIST.FIRST.PRED "_buy_v_rel" ].

t-catch-incorp-lex-rule := common-incorp-verb-lex-rule & 
 [ C-CONT.RELS.LIST.FIRST.PRED "_catch_v_rel" ].

liaq-incorp-lex-rule := common-incorp-verb-lex-rule & 
 [ C-CONT.RELS.LIST.FIRST.PRED "_travel+to_v_rel" ].

liuq-incorp-lex-rule := common-incorp-verb-lex-rule & 
 [ C-CONT.RELS.LIST.FIRST.PRED "_make_v_rel" ].

;;; INCORP-N is the incorporated noun to be exposed to modification.
;;; It does NOT always represent the incorporated noun;
;;; There can be cases when there is an incorporated noun with [ LOCAL.CAT.VAL.INCORP-N < > ].
valence :+ [ INCORP-N 0-1-list ].
lex-item :+ [ SYNSEM.LOCAL.CAT.VAL.INCORP-N < > ].
verb-lex :+ [ SYNSEM.LOCAL.CAT.HEAD [ INCORP -, DUR - ] ].
adj-lex :+ [ SYNSEM.LOCAL.CAT.HEAD.INCORP - ].

incorp-head-mod-phrase := headed-phrase & 
  [ SYNSEM [ LOCAL.CAT.VAL [ SUBJ #subj,
                             SPR #spr,
                             COMPS #comps, SPEC #spec ],
             MODIFIED hasmod,
             NON-LOCAL.REL.LIST < > ],
    HEAD-DTR.SYNSEM [ LOCAL.CAT.VAL [ SUBJ #subj,
                                      SPR #spr,
                                      COMPS #comps, SPEC #spec ],
                      NON-LOCAL.REL.LIST < > ] ].

incorp-head-mod-phrase-simple := incorp-head-mod-phrase & binary-nonloc-phrase & binary-headed-phrase & 
  [ 
    SYNSEM.LOCAL.CAT.VAL.INCORP-N.FIRST [ LOCAL [ CAT [ 
                            HEAD #head, 
                            VAL #val, 
                            MKG #mkg, 
                            WH [ OR < #or1, #or2 > ] ], 
                        CONT.HOOK #hdhook, 
                        AGR #agr ], 
                    NON-LOCAL #nonloc, 
                    LIGHT #light, 
                    MODIFIED #modif ],
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.INCORP-N.FIRST
           [ LOCAL [ CAT [ WH #or1,
                           HEAD #head,
                           VAL #val,
                           POSTHEAD #ph,
                           MC #hmc,
                           HC-LIGHT - ],
                     CONT.HOOK #hdhook & [ ICONS-KEY.IARG1 #clause,
                                           CLAUSE-KEY #clause ],
                     AGR #agr ],
             NON-LOCAL #nonloc,
             LIGHT #light,
             MODIFIED #modif ],
    NON-HEAD-DTR.SYNSEM
           [ LOCAL [ CAT [ WH #or2, HEAD [ MOD < [ LOCAL local &
                                              [ CAT [ HEAD #head,
                                                      VAL #val,
                                                      POSTHEAD #ph,
                                                      MC #hmc ],
                                                AGR #agr,
                                                CONT.HOOK #hdhook ],
                                          NON-LOCAL #nonloc,
                                          LIGHT #light,
                                          MODIFIED #modif,
                                          OPT - ] > ],
                           VAL [ COMPS olist,
                                 SPR olist ],
                           MKG #mkg ],
                     CONT.HOOK [ ICONS-KEY.IARG1 #clause,
                     CLAUSE-KEY #clause ] ] ],
    C-CONT [ RELS.LIST < >, ICONS.LIST < > ] ].

incorp-adj-head-phrase := incorp-head-mod-phrase-simple & head-final &
  [ SYNSEM.LOCAL.CAT.VAL.INCORP-N.FIRST [ LOCAL.CAT.POSTHEAD #ph,
	     MODIFIED lmod & [ PERIPH #periph ] ],
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.INCORP-N.FIRST [ LOCAL.CAT.POSTHEAD #ph ],
    NON-HEAD-DTR.SYNSEM [ LOCAL.CAT [ VAL [ SPR olist,
    			  	      	    COMPS < > ] ],
			  NON-LOCAL [ SLASH.LIST < >,
				      REL.LIST < > ],
                          MODIFIED.PERIPH #periph ] ].

incorp-isect-mod-phrase := incorp-head-mod-phrase-simple & head-compositional &
  [ HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.INCORP-N.FIRST.LOCAL [ CAT [ MKG #mkg, WH #wh ], CONT.HOOK.LTOP #hand ],
    NON-HEAD-DTR.SYNSEM.LOCAL [ CAT [ VAL.SPR adv-list,
                                      HEAD.MOD < [ LOCAL intersective-mod & [ CAT [ MKG #mkg, WH #wh ] ] ] > ],
                                CONT.HOOK.LTOP #hand ],
    C-CONT [ HCONS.LIST < >,
             ICONS.LIST < > ] ].

incorp-head-adj-phrase := incorp-head-mod-phrase-simple & head-initial & phrasal &
  [ SYNSEM.MODIFIED rmod,
    NON-HEAD-DTR.SYNSEM [ LOCAL.CAT [ VAL.SPR olist,
                                      POSTHEAD + ] ] ].

incorp-adj-head-int-phrase := incorp-adj-head-phrase & incorp-isect-mod-phrase &
  [ HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD verb & [ INCORP +, PRD na-or-- ], 
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT [ POSTHEAD -, 
                                    HEAD +nvj & [ INCORP + ] ] ].

incorp-head-adj-int-phrase := incorp-head-adj-phrase & incorp-isect-mod-phrase &
  [ HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD verb & [ INCORP +, PRD + ], 
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT [ POSTHEAD +, 
                                    HEAD adj & [ INCORP + ] ] ].

ext-rel-mod-phrase := rel-mod-phrase &
  [ SYNSEM.LOCAL.CAT [ HEAD.INCORP -, 
                       POSTHEAD + ] ].

incorp-rel-mod-phrase := rel-mod-phrase & 
  [ SYNSEM.LOCAL.CAT [ HEAD.INCORP +, 
                       POSTHEAD - ] ].

rel-mod-phrase := unary-slash-phrase & same-crf-unary-phrase &
  [ SYNSEM [ LOCAL.CAT [ HEAD verb & [ PRD -, 
                                       INIT #init, 
                                       MOD < [ LOCAL [ CONT.HOOK [ LTOP #m-ltop, 
                                                                   INDEX #m-index, 
                                                                   XARG #m-xarg ], 
                                                         CAT [ HEAD noun & #m-head, 
                                                               VAL [ SUBJ < >, 
                                                                     COMPS < >, 
                                                                     SPR < [ LOCAL.CAT.HEAD det ] >, 
                                                                     SPEC < > ] ] ], 
                                               NON-LOCAL non-local-none ] > ], 
                         VAL [ SUBJ #subj & < >, 
                               COMPS #comps & < >, 
                               SPR #spr, 
                               SPEC #spec, 
                               INCORP-N #incorp-n ] ], 
             NON-LOCAL [ SLASH.LIST < >, 
                         CONJP #conjp ] ], 
    INFLECTED infl-satisfied, 
    C-CONT [ HOOK [ LTOP #ltop, 
                    INDEX #index, 
                    XARG #xarg ],
             RELS.LIST < >, 
             HCONS.LIST < >, 
             ICONS.LIST < > ], 
    ARGS < [ INFLECTED infl-satisfied, 
             SYNSEM.LOCAL.CONT.HOOK [ LTOP #ltop, 
                                      INDEX #index, 
                                      XARG #xarg ],
             SYNSEM [ LOCAL.CAT [ HEAD verb & [ PRD - , 
                                                INIT #init ], 
                                  VAL [ SUBJ #subj, 
                                        COMPS #comps, 
                                        SPR #spr, 
                                        SPEC #spec, 
                                        INCORP-N #incorp-n ] ], 
                      NON-LOCAL [ SLASH.LIST < [ CONT.HOOK [ LTOP #m-ltop, 
                                                             INDEX #m-index, 
                                                             XARG #m-xarg ], 
                                                 CAT.HEAD #m-head ] >, 
                                  CONJP #conjp ] ] ] > ].

;;; TODO: this part-to-noun-phrase can be incorporated, so must be a lexical rule, or parallel forms must exist (?!)
;;; another: for -(v)vik, the possessor can "penetrate" through the noun to the prior verb; how is that possible?
;;; if we allow XARG to denote the subject/ARG1 of "the most prominent" relation
;;; how about -kcaq? it sometimes refer to the futureness of existence (being), but it sometimes might refer to
;;; the futureness of possession or inalienable relation (true?)
part-to-noun-phrase := unary-slash-phrase & same-crf-unary-phrase & phrasal & 
  [ SYNSEM [ LOCAL [ COORD #coord, 
                     CAT [ HEAD #head & noun & [ MIN nontime-noun-relation, 
                                                 MOD < > ], 
                            VAL [ SUBJ < >, 
                                  COMPS < >, 
                                  SPEC < > ], 
                           POSSESSUM nonpossessive ], 
                     CONT.HOOK #hook & [ INDEX.PNG.PER 3rd ] ], 
             NON-LOCAL [ SLASH.LIST < >, 
                         CONJP #conjp ] ], 
    C-CONT [ HOOK #hook, 
             HCONS.LIST < >, 
             ICONS.LIST < > ],
    ARGS < [ SYNSEM [ LOCAL [ CAT [ HEAD verb & [ PRD - ],
                                    VAL [ SUBJ < >, 
                                          COMPS < > ] ], 
                              COORD #coord ], 
                      NON-LOCAL [ SLASH.LIST < [ CAT.HEAD #head, 
                                                 CONT.HOOK #hook ] >, 
                                  CONJP #conjp ] ] ] > ].

part-to-noun-with-rel-phrase := part-to-noun-phrase & 
  [ SYNSEM.LOCAL [ CAT.VAL.SPR < [ LOCAL.CAT.HEAD det ] >, 
                   CONT.HOOK.INDEX #index ], 
    C-CONT [ HOOK.LTOP #ltop, 
              RELS.LIST < noun-relation &
                          [ PRED "_entity_n_rel",
                            LBL #ltop, 
                            ARG0 #index ] > ], 
    ARGS < [ SYNSEM.LOCAL.CAT.HEAD.REF - ] > ].

part-to-noun-no-ccont-phrase := part-to-noun-phrase & 
  [ SYNSEM.LOCAL.CAT.VAL.SPR < >, 
    C-CONT.RELS.LIST < >, 
    ARGS < [ SYNSEM.LOCAL.CAT.HEAD.REF + ] > ].

;;; abstract participle

abs-participle-lex-rule-super := infl-lex-rule & 
  [ INFLECTED.NUM_CASE-OR-POSS-FLAG -, 
    DTR v_end-rule-dtr & [ SYNSEM.LOCAL.CAT.HEAD [ DBT -, DUR - ] ] ].

;abs_part-lex-rule := abs-participle-lex-rule-super & trans-poss-acc-lex-rule & 
;  [ SYNSEM.LOCAL.CAT.VAL.COMPS < [ OPT +, 
;                                   LOCAL.CAT.HEAD.CASE ins ] > ].

;abs_part-intrans-lex-rule := abs-participle-lex-rule-super & non-sent-anc-intrans-lex-rule & poss-rule-dtr.

abs-part-anc-lex-rule := anc-low-nmz-lex-rule & abs-participle-lex-rule-super & num_case-rule-dtr & 
  [ SYNSEM.LOCAL.CAT.VAL [ SPR < >,
                           COMPS #comps ],
    DTR.SYNSEM.LOCAL.CAT.VAL.COMPS #comps & oins-list ].

pat-pres-abs-part-anc-lex-rule := anc-low-nmz-lex-rule & abs-participle-lex-rule-super & num_case-rule-dtr & 
  [ SYNSEM.LOCAL.CAT.VAL [ SPR < >,
                           COMPS < > ], 
    DTR.INFLECTED.TI_NNIK_FLAG + ].

poss-abs-part-anc-lex-rule := anc-low-nmz-lex-rule & abs-participle-lex-rule-super & poss-rule-dtr &
  [ SYNSEM.LOCAL.CAT.VAL [ SPR < [ LOCAL.CAT.VAL.SPR < > ] >,
                           COMPS #comps ],
    DTR.SYNSEM.LOCAL.CAT.VAL.COMPS #comps & oins-list ].

poss-abs-part-anc-lex-rule :+ 
  [ SYNSEM.LOCAL.CAT.VAL.SPR < [ LOCAL [ CONT.HOOK.INDEX #subj,
                                         CAT.HEAD.POSSESSOR possessive ] ] >, 
    DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ < [ LOCAL.CONT.HOOK.INDEX #subj ] > ].

pat-pres-poss-abs-part-anc-lex-rule := anc-low-nmz-lex-rule & abs-participle-lex-rule-super & poss-rule-dtr &
  [ SYNSEM.LOCAL.CAT.VAL [ SPR < [ LOCAL.CAT.VAL.SPR < > ] >,
                           COMPS < > ],
    DTR.SYNSEM.LOCAL.CAT.VAL.COMPS cons, 
    DTR.INFLECTED.TI_NNIK_FLAG + ].

pat-pres-poss-abs-part-anc-lex-rule :+ 
  [ SYNSEM.LOCAL.CAT.VAL.SPR < [ LOCAL [ CONT.HOOK.INDEX #subj,
                                         CAT.HEAD.POSSESSOR possessive ] ] >, 
    DTR.SYNSEM.LOCAL.CAT.VAL.COMPS < [ LOCAL.CONT.HOOK.INDEX #subj ] > ].


anc-lex-rule := cat-change-with-ccont-lex-rule & same-non-local-lex-rule &
  [ SYNSEM.LOCAL.CAT [ VAL.SPEC #spec,
                       MKG #mkg,
                       HC-LIGHT #hc-light,
                       POSTHEAD #posthead,
                       HEAD noun &
                            [ NMZ +,
                              MOD #mod,
                              POSSESSOR #possessor ],
                       POSSESSUM #possessum ],
    DTR.SYNSEM.LOCAL.CAT [ VAL.SPEC #spec,
                           MKG #mkg,
                           HC-LIGHT #hc-light,
                           POSTHEAD #posthead,
                           HEAD verb &
                                [ MOD #mod,
                                  POSSESSOR #possessor & nonpossessive ],
                           POSSESSUM #possessum & nonpossessive ] ].

anc-low-nmz-lex-rule := anc-lex-rule &
  [ SYNSEM.LOCAL.CAT.VAL.SUBJ < >,
    C-CONT [ RELS.LIST < [ PRED "nominalized_rel",
                           LBL #ltop,
                           ARG0 ref-ind & #arg0,
                           ARG1 #arg1 ] >,
             HCONS.LIST < qeq &
                          [ HARG #arg1,
                            LARG #larg ] >,
             HOOK [ XARG #xarg,
                    INDEX #arg0,
                    LTOP #ltop ] ],
    DTR.SYNSEM.LOCAL.CONT.HOOK [ XARG #xarg,
                                 LTOP #larg ] ].

anc-low-nmz-lex-rule :+
  ; [ SYNSEM.LOCAL.CAT.HEAD.TIME - ].
  [ SYNSEM.LOCAL.CAT.HEAD.MIN nontime-noun-relation ].

non-sent-anc-intrans-lex-rule_supertype := anc-low-nmz-lex-rule &
  [ SYNSEM.LOCAL.CAT.VAL [ SPR < [ LOCAL.CAT.VAL.SPR < > ] >,
                           COMPS #comps ],
    DTR.SYNSEM.LOCAL.CAT.VAL.COMPS #comps & null ].

subj-anc-low-nmz-lex-rule := anc-lex-rule &
  [ SYNSEM.LOCAL.CAT.VAL.SPR < >,
    C-CONT [ RELS.LIST < [ PRED "nominalized_rel",
                           LBL #ltop,
                           ARG0 ref-ind & #arg0,
                           ARG1 #arg1 ] >,
             HCONS.LIST < qeq &
                          [ HARG #arg1,
                            LARG #larg ] >,
             HOOK [ XARG #xarg,
                    INDEX #arg0,
                    LTOP #ltop ] ],
    DTR.SYNSEM.LOCAL.CONT.HOOK [ XARG #xarg,
                                 LTOP #larg ] ].

oins-list := olist.

oins-cons := oins-list & ocons &
[ FIRST [ LOCAL.CAT.HEAD noun & [ CASE ins ] ],
  REST oins-null ].

oins-null := oins-list & onull.

;neq-nonpossessive-intrans-lex-rule := subj-anc-low-nmz-lex-rule & abs-participle-lex-rule-super & 
;  [ SYNSEM.LOCAL.CAT.VAL [ SUBJ #subj, COMPS #comps ],
;    DTR.SYNSEM.LOCAL.CAT.VAL [ SUBJ #subj, COMPS #comps & oins-list ] ].

;;;want this?
non-sent-anc-intrans-lex-rule := non-sent-anc-intrans-lex-rule_supertype &
  [ SYNSEM.LOCAL.CAT.VAL.SPR < [ LOCAL [ CONT.HOOK.INDEX #subj,
                                         CAT.HEAD.POSSESSOR possessive ] ] >, 
    DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ < [ LOCAL.CONT.HOOK.INDEX #subj ] > ].

trans-poss-acc-lex-rule_supertype := anc-low-nmz-lex-rule &
  [ SYNSEM.LOCAL.CAT.VAL [ SPR < [ LOCAL.CAT.VAL.SPR < > ] >,
                           COMPS #comps ],
    DTR.SYNSEM.LOCAL.CAT.VAL.COMPS #comps & cons ].

;;; want this?
trans-poss-acc-lex-rule := trans-poss-acc-lex-rule_supertype &
  [ DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ < [ LOCAL.CONT.HOOK.INDEX #subj ] >,
    SYNSEM.LOCAL.CAT.VAL.SPR < [ LOCAL [ CONT.HOOK.INDEX #subj,
                                         CAT.HEAD.POSSESSOR possessive ] ] > ].

sentential-lex-rule := anc-lex-rule & same-cont-lex-rule &
  [ DTR.SYNSEM.LOCAL.CAT.VAL.SPR #spr,
    C-CONT [ RELS.LIST < >,
             HCONS.LIST < > ],
    SYNSEM.LOCAL.CAT.VAL [ SPR #spr,
                           SUBJ < [ LOCAL.CAT [ HEAD.POSSESSOR nonpossessive,
                                                POSSESSUM nonpossessive ] ] > ] ].

intrans-sent-lex-rule := sentential-lex-rule &
  [ SYNSEM.LOCAL.CAT.VAL [ SUBJ #subj,
                           COMPS #comps ],
    DTR.SYNSEM.LOCAL.CAT.VAL [ SUBJ #subj,
                               COMPS #comps & null ] ].

trans-sent-lex-rule := sentential-lex-rule &
  [ SYNSEM.LOCAL.CAT.VAL [ SUBJ #subj,
                           COMPS #comps ],
    DTR.SYNSEM.LOCAL.CAT.VAL [ SUBJ #subj,
                               COMPS #comps & cons ] ].

intrans+trans-sent-lex-rule := sentential-lex-rule &
  [ SYNSEM.LOCAL.CAT.VAL [ SUBJ #subj,
                           COMPS #comps ],
    DTR.SYNSEM.LOCAL.CAT.VAL [ SUBJ #subj,
                               COMPS #comps ] ].

;;; 2025-03-10 abandon this analysis for -neq
high-nominalized-clause-phrase := unary-phrase &
  [ C-CONT [ RELS.LIST < [ PRED "nominalized_rel",
                           LBL #ltop,
                           ARG0 ref-ind & #arg0 & [ PNG.PER 3rd ],
                           ARG1 #arg1 ] >,
             HCONS.LIST < qeq &
                          [ HARG #arg1,
                            LARG #larg ] >,
             HOOK [ XARG #xarg,
                    INDEX #arg0,
                    LTOP #ltop ] ],
    ARGS < [ SYNSEM [ NON-LOCAL #nl,
                      LOCAL [ CAT [ HEAD #head,
                                    VAL [ COMPS < >,
                                          SUBJ < >,
                                          SPR < >,
                                          SPEC < > ] ],
                              CONT.HOOK [ INDEX event,
                                          XARG #xarg,
                                          LTOP #larg ],
                              COORD - ] ] ] >,
    SYNSEM [ NON-LOCAL #nl,
             LOCAL [ COORD -,
                     CAT [ HEAD #head & noun &
                                [ NMZ +,
                                  MOD < > ],
                           VAL [ COMPS < >,
                                 SUBJ < >,
                                 SPEC < >,
                                 SPR < [ OPT +,
                                         LOCAL.CAT.HEAD.POSSESSOR nonpossessive ] > ] ] ] ] ].

;;; Note: we should exclude numbers presumably; they will be measure
adv-from-adj-unary-phrase := unary-phrase & 
  [ SYNSEM [ LOCAL.CAT [HEAD adv & [ MOD.FIRST.LOCAL intersective-mod & 
                                        [ CAT [ HEAD verb & [ INCORP - ], 
                                                VAL.SUBJ cons ] ] ], 
                        VAL [ SPR < >, 
                              SPEC < >, 
                              SUBJ < >, 
                              COMPS < > ], 
                        POSTHEAD - ], 
             NON-LOCAL #nl & non-local-none ], 
    C-CONT [ RELS.LIST < >, 
             HCONS.LIST < >, 
             ICONS.LIST < > ],
    ARGS.FIRST.SYNSEM [ LOCAL.CAT.HEAD adj & 
                          [ INCORP -, 
                            PRD -, 
                            MOD < [ LOCAL [ CAT.HEAD noun & [ CASE ins ], 
                                            CONT.HOOK.INDEX.PNG.NUM sg ] ] > ], 
                        NON-LOCAL #nl ] ].

;;;named-relation :+ [ ARG0 ref-ind ].


compound-relation := arg12-relation & event-relation & 
  [ PRED "compound", 
    ARG1 ref-ind, 
    ARG2 ref-ind ].

arg1-carg-relation := arg1-relation & carg-relation.

arg1-ev-carg-relation := arg1-ev-relation & carg-relation.

;;; 2025-03-14 for numerals (cardinal numbers)
card := arg1-carg-relation & 
"""Relation of numerals. Note that ARG0 does not have a specified type."""
  [ PRED "card" ].

noncard := relation.

hour-relation := time-relation & noun-carg-relation & 
  [ PRED num_hour ].

degree-relation := arg12-ev-relation.

measure-relation := degree-relation
"""
`ARG1`: the event that gets measured.
`ARG2`: the degree of the measure.
""".

; not needed
; temp-degree-relation := arg1-ev-carg-relation & 
;   [ PRED "temp_celsius_degree" ].

num_hour := predsort.

;;; TODO: qeq in HCONS
title-phrase := head-compositional & head-final &
  [
    SYNSEM [ LOCAL.CAT #cat,
             NON-LOCAL non-local-none & [ CRF.LIST < >, CRF-H.LIST < > ] ], 
    C-CONT [ RELS.LIST < compound-relation & 
                [ LBL #hd-lbl, 
                  ARG1 #hdn-idx, 
                  ARG2 #ttl-idx ] >, 
             HCONS.LIST < >, 
             ICONS.LIST < > ],
    HEAD-DTR.SYNSEM [ LOCAL [ CAT #cat & [ HEAD noun & [ CASE #case, PRON - ], 
                                           VAL [ SPR < >, 
                                                 SUBj < >,
                                                 COMPS < > ] ], 
                              CONT [ HOOK [ LTOP #hd-lbl, INDEX #hdn-idx & [ PNG #png ] ], 
                                     RELS.LIST < named-relation > ] ], 
                      NON-LOCAL non-local-none & [ CRF.LIST < >, CRF-H.LIST < > ] ], 
    NON-HEAD-DTR.SYNSEM [ LOCAL [ CAT [ HEAD noun & [ CASE #case, PRON - ], 
                                      VAL [ SPR < >, 
                                            SUBJ < >, 
                                            COMPS < > ], 
                                      POSSESSUM nonpossessive ],
                                CONT.HOOK.INDEX #ttl-idx & [ PNG #png ] ], 
                          NON-LOCAL non-local-none & [ CRF.LIST < >, CRF-H.LIST < > ] ] ]
"""Example: 'teacher John' in English, `ilinniartitsisoq Piitaq` in Kalaallisut.""".

;;; TODO: compound-relation does not seem to be quite correct
;;; TODO: new binary phrase instead of 
;;; this unary + head-adj-int its incorp version(s) might be better?
;;; TODO: how to deal with the SPR? (temporarily make it modifying non-empty cons, but not sure)
;;; 2025-03-25: try COG-ST fam-or-less (this should not ban names, right?)
;;; 2025-03-26: Temporarily set the modified noun to be non-pronoun. But this may get changed.
;;; 2025-11-16 relax ARGS...SPR
noun-compound-unary-phrase := unary-phrase & 
  [ SYNSEM [ LOCAL.CAT [HEAD noun & [ CASE #case,
                                      MIN noncard, 
                                      MOD < [ LOCAL intersective-mod & 
                                                    [ CAT [ HEAD noun & [ PRON - ], 
                                                            VAL [ SPR cons, 
                                                                  SUBJ < >, 
                                                                  COMPS < > ] ], 
                                                      CONT.HOOK [ LTOP #hd-ltop, 
                                                                  INDEX #hdn-idx ] ] ] > ], 
                        VAL [ SUBJ < >, 
                              COMPS < >, 
                              SPEC < > ] ], 
             NON-LOCAL #nl & non-local-none ], 
    C-CONT [ HOOK [ LTOP #hd-ltop, 
                    INDEX #idx ], 
             RELS.LIST < compound-relation & 
                [ LBL #hd-ltop, 
                  ARG0 #idx, 
                  ARG1 #hdn-idx & [ PNG.NUM #num ], 
                  ARG2 #mod-idx & [ PNG.NUM #num, COG-ST fam-or-less ] ] >, 
             HCONS.LIST < >, 
             ICONS.LIST < > ],
    ARGS.FIRST.SYNSEM [ LIGHT +, 
                        LOCAL [ CAT [ HEAD noun & [ CASE #case, 
                                                    PRON -, 
                                                    MOD < >, 
                                                    MIN noncard, 
                                                    POSSESSOR nonpossessive ], 
                                      VAL [ 
                                            ; SPR < >, 
                                              SUBJ < >, 
                                              COMPS < > ], 
                                      POSSESSUM nonpossessive ], 
                                CONT.HOOK.INDEX #mod-idx, 
                                COORD - ], 
                        NON-LOCAL #nl & [ CRF-H.LIST < > ] ] ]
"""
This unary phrase "adjectivizes" a noun to let it be able to modify another head noun.

Example: 'kalaaliq' as in 'arnaq kalaaliq'.

A compound-relation is introduced.

""".

noun-mod-unary-phrase := noun-compound-unary-phrase & 
  [ SYNSEM.LOCAL.CAT [ HEAD [ INCORP - ], 
                       POSTHEAD +, 
                       HEAD.MOD.FIRST.LOCAL.CAT.HEAD.CASE #case ], 
    ARGS.FIRST.SYNSEM.LOCAL.CAT.HEAD.CASE #case ].

noun-mod-incorp-unary-phrase := noun-compound-unary-phrase & 
  [ SYNSEM.LOCAL.CAT [ HEAD.INCORP +, 
                       POSTHEAD - ], 
    ARGS.FIRST.SYNSEM.LOCAL.CAT.HEAD.CASE ins ].
    

demonstrative_a_rel := predsort
"""
Core relation for demonstrative pronouns, demonstrative adjectives, 
demonstrative articles, and demonstrative pronouns.
""".
proximal+dem_a_rel := demonstrative_a_rel
"""close to speaker.""".
distal+dem_a_rel := demonstrative_a_rel
"""away from speaker.""".
;;;mid+dem_a_rel := distal+dem_a_rel.         ; away, but not very far away
;;;far+dem_a_rel := distal+dem_a_rel.         ; very far away

;;; 2025-11-14 add attr-only to avoid subj-head
demonstr-adj-lex := attr-only-adj-lex & demonstr-end-rule-dtr & 
  [ SYNSEM.LOCAL.CONT.HOOK.XARG.COG-ST activ+fam, 
    INFLECTED.NUM_CASE_END-FLAG - ]. 

;;; 2025-03-22 put prefix *after* all the suffix have been applied. But why is this necessary?
demonstr-pref-lex-rule-super := add-only-no-ccont-rule & demonstr-end-rule-dtr &
  [ INFLECTED #infl, 
    DTR demonstr-adj-lex & [ INFLECTED #infl ] ].

tac-lex-rule := demonstr-pref-lex-rule-super & 
  [ SYNSEM.LOCAL.CAT.HEAD.MOD.FIRST.LOCAL.CONT.HOOK.INDEX.COG-ST activ-or-more ].

demonstr-end-rule-dtr := word-or-lexrule.

demonstr-end-lex-rule-super := add-only-no-ccont-rule &
  [ SYNSEM.LOCAL.CAT [ HEAD.PRD -, POSTHEAD + ], 
    INFLECTED [ NUM_CASE_END-FLAG +,
                TRANS_ONLY_V-VERB-FLAG #trans_only_v-verb,
                V_END-OR-V_END_NEG-FLAG #v_end-or-v_end_neg,
                ANTIPASS-OR-PASS-FLAG #antipass-or-nnik_null_pass,
                SG_ABS_QUES_NOUN-NOUN-FLAG #sg_abs_ques_noun-noun,
                TRANS_CLAUSE_VERB_NEG-OR-TRANS_VERB_NEG-OR-V_END-OR-V_END_NEG-FLAG #trans_clause_verb_neg-or-trans_verb_neg-or-v_end-or-v_end_neg,
                HAB-FLAG #hab,
                TI_ANTIPASS-OR-NORMAL-OR-TRANS_CAUS_PASS-FLAG #ti_antipass-or-ti_normal-or-trans_caus_pass,
                TRANS_CLAUSE_VERB-OR-TRANS_CLAUSE_VERB_NEG-OR-V_END-OR-V_END_NEG-FLAG #trans_clause_verb-or-trans_clause_verb_neg-or-v_end-or-v_end_neg,
                TRANS_VALCHG-FLAG #trans_valchg,
                CASE_ENDING-FLAG #case_ending,
                NULL_HTR-FLAG #null_htr,
                CL_Q_TRANS_V-VERB-OR-CL_TRANS_V-VERB-FLAG #cl_q_trans_v-verb-or-cl_trans_v-verb,
                INFL_QUES_N-NOUN-FLAG #infl_ques_n-noun,
                PI_V-VERB-FLAG #pi_v-verb,
                NUM_CASE-OR-POSS-FLAG #num_case-or-poss,
                NUM_CASE-FLAG #num_case,
                TENSE-FLAG #tense ],
    DTR demonstr-end-rule-dtr &
        [ INFLECTED [ TRANS_ONLY_V-VERB-FLAG #trans_only_v-verb,
                      V_END-OR-V_END_NEG-FLAG #v_end-or-v_end_neg,
                      ANTIPASS-OR-PASS-FLAG #antipass-or-nnik_null_pass,
                      SG_ABS_QUES_NOUN-NOUN-FLAG #sg_abs_ques_noun-noun,
                      TRANS_CLAUSE_VERB_NEG-OR-TRANS_VERB_NEG-OR-V_END-OR-V_END_NEG-FLAG #trans_clause_verb_neg-or-trans_verb_neg-or-v_end-or-v_end_neg,
                      HAB-FLAG #hab,
                      TI_ANTIPASS-OR-NORMAL-OR-TRANS_CAUS_PASS-FLAG #ti_antipass-or-ti_normal-or-trans_caus_pass,
                      TRANS_CLAUSE_VERB-OR-TRANS_CLAUSE_VERB_NEG-OR-V_END-OR-V_END_NEG-FLAG #trans_clause_verb-or-trans_clause_verb_neg-or-v_end-or-v_end_neg,
                      TRANS_VALCHG-FLAG #trans_valchg,
                      CASE_ENDING-FLAG #case_ending,
                      NULL_HTR-FLAG #null_htr,
                      CL_Q_TRANS_V-VERB-OR-CL_TRANS_V-VERB-FLAG #cl_q_trans_v-verb-or-cl_trans_v-verb,
                      INFL_QUES_N-NOUN-FLAG #infl_ques_n-noun,
                      PI_V-VERB-FLAG #pi_v-verb,
                      NUM_CASE-OR-POSS-FLAG #num_case-or-poss,
                      NUM_CASE-FLAG #num_case,
                      TENSE-FLAG #tense ] ] ].

;;;posthead-plus-lex-rule := demonstr-end-lex-rule-super & 
;;;  [ SYNSEM.LOCAL.CAT.POSTHEAD + ].

sg-dem-lex-rule := infl-lex-rule & demonstr-end-lex-rule-super &
  [ SYNSEM.LOCAL.CONT.HOOK.XARG.PNG.NUM sg ].

pl-dem-lex-rule := infl-lex-rule & demonstr-end-lex-rule-super &
  [ SYNSEM.LOCAL.CONT.HOOK.XARG.PNG.NUM pl ].

abs-dem-lex-rule := demonstr-end-lex-rule-super &
  [ SYNSEM.LOCAL.CAT.HEAD.MOD.FIRST.LOCAL.CAT.HEAD.CASE abs ].

sg_abs-dem-lex-rule := abs-dem-lex-rule & sg-dem-lex-rule.

pl_abs-dem-lex-rule := abs-dem-lex-rule & pl-dem-lex-rule.

erg-dem-lex-rule := demonstr-end-lex-rule-super & 
  [ SYNSEM.LOCAL.CAT.HEAD.MOD.FIRST.LOCAL.CAT.HEAD.CASE erg ].

sg_erg-dem-lex-rule := erg-dem-lex-rule & sg-dem-lex-rule.

pl_erg-dem-lex-rule := erg-dem-lex-rule & pl-dem-lex-rule.

demonstr-pron-end-dtr := word-or-lexrule.

;;; 2025-03-22 put prefix *after* all the suffix have been applied. But why is this necessary?
demonstr-pron-pref-lex-rule-super := add-only-no-ccont-rule & demonstr-pron-end-dtr & infl-lex-rule &
  [ INFLECTED #infl, 
    DTR demonstr-pron-noun-lex & [ INFLECTED #infl ] ].

tac-pron-lex-rule := demonstr-pron-pref-lex-rule-super & 
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.COG-ST activ-or-more ].
;;tac-pron-lex-rule := demonstr-pron-pref-lex-rule-super.

demonstr-pron-end-lex-rule-super := add-only-no-ccont-rule &
  [ SYNSEM.NON-LOCAL [ CRF.LIST < >, CRF-H.LIST < > ], 
    INFLECTED [ NUM_CASE-OR-POSS-FLAG +,
                NUM_CASE_END-FLAG #num_case_end,
                TRANS_ONLY_V-VERB-FLAG #trans_only_v-verb,
                V_END-OR-V_END_NEG-FLAG #v_end-or-v_end_neg,
                ANTIPASS-OR-PASS-FLAG #antipass-or-nnik_null_pass,
                SG_ABS_QUES_NOUN-NOUN-FLAG #sg_abs_ques_noun-noun,
                TRANS_CLAUSE_VERB_NEG-OR-TRANS_VERB_NEG-OR-V_END-OR-V_END_NEG-FLAG #trans_clause_verb_neg-or-trans_verb_neg-or-v_end-or-v_end_neg,
                HAB-FLAG #hab,
                TI_ANTIPASS-OR-NORMAL-OR-TRANS_CAUS_PASS-FLAG #ti_antipass-or-ti_normal-or-trans_caus_pass,
                TRANS_CLAUSE_VERB-OR-TRANS_CLAUSE_VERB_NEG-OR-V_END-OR-V_END_NEG-FLAG #trans_clause_verb-or-trans_clause_verb_neg-or-v_end-or-v_end_neg,
                TRANS_VALCHG-FLAG #trans_valchg,
                CASE_ENDING-FLAG #case_ending,
                NULL_HTR-FLAG #null_htr,
                CL_Q_TRANS_V-VERB-OR-CL_TRANS_V-VERB-FLAG #cl_q_trans_v-verb-or-cl_trans_v-verb,
                INFL_QUES_N-NOUN-FLAG #infl_ques_n-noun,
                PI_V-VERB-FLAG #pi_v-verb,
                NUM_CASE-FLAG #num_case,
                TENSE-FLAG #tense ],
    DTR demonstr-pron-end-dtr &
        [ INFLECTED [ TRANS_ONLY_V-VERB-FLAG #trans_only_v-verb,
                      V_END-OR-V_END_NEG-FLAG #v_end-or-v_end_neg,
                      ANTIPASS-OR-PASS-FLAG #antipass-or-nnik_null_pass,
                      SG_ABS_QUES_NOUN-NOUN-FLAG #sg_abs_ques_noun-noun,
                      TRANS_CLAUSE_VERB_NEG-OR-TRANS_VERB_NEG-OR-V_END-OR-V_END_NEG-FLAG #trans_clause_verb_neg-or-trans_verb_neg-or-v_end-or-v_end_neg,
                      HAB-FLAG #hab,
                      TI_ANTIPASS-OR-NORMAL-OR-TRANS_CAUS_PASS-FLAG #ti_antipass-or-ti_normal-or-trans_caus_pass,
                      TRANS_CLAUSE_VERB-OR-TRANS_CLAUSE_VERB_NEG-OR-V_END-OR-V_END_NEG-FLAG #trans_clause_verb-or-trans_clause_verb_neg-or-v_end-or-v_end_neg,
                      TRANS_VALCHG-FLAG #trans_valchg,
                      CASE_ENDING-FLAG #case_ending,
                      NULL_HTR-FLAG #null_htr,
                      CL_Q_TRANS_V-VERB-OR-CL_TRANS_V-VERB-FLAG #cl_q_trans_v-verb-or-cl_trans_v-verb,
                      INFL_QUES_N-NOUN-FLAG #infl_ques_n-noun,
                      PI_V-VERB-FLAG #pi_v-verb,
                      NUM_CASE_END-FLAG #num_case_end,
                      NUM_CASE-FLAG #num_case,
                      TENSE-FLAG #tense ] ] ].

sg-dem-pron-lex-rule := infl-lex-rule & demonstr-pron-end-lex-rule-super &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NUM sg, 
    INFLECTED [ DEM_OBLIQUE-FLAG - ] ].

pl-dem-pron-lex-rule := infl-lex-rule & demonstr-pron-end-lex-rule-super &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NUM pl, 
    INFLECTED [ DEM_OBLIQUE-FLAG - ] ].

dem-pron-oblique-lex-rule := infl-lex-rule & demonstr-pron-end-lex-rule-super &
  [ INFLECTED [ DEM_OBLIQUE-FLAG + ] ].

abs-dem-pron-lex-rule := demonstr-pron-end-lex-rule-super &
  [ SYNSEM.LOCAL.CAT.HEAD.CASE abs ].

erg-dem-pron-lex-rule := demonstr-pron-end-lex-rule-super & 
  [ SYNSEM.LOCAL.CAT.HEAD.CASE erg ].

sg_abs-dem-pron-lex-rule := abs-dem-pron-lex-rule & sg-dem-pron-lex-rule.

pl_abs-dem-pron-lex-rule := abs-dem-pron-lex-rule & pl-dem-pron-lex-rule.

sg_erg-dem-pron-lex-rule := erg-dem-pron-lex-rule & sg-dem-pron-lex-rule.

pl_erg-dem-pron-lex-rule := erg-dem-pron-lex-rule & pl-dem-pron-lex-rule.

loc-dem-pron-lex-rule := dem-pron-oblique-lex-rule & 
  [ SYNSEM.LOCAL.CAT.HEAD.CASE loc ].

abl-dem-pron-lex-rule := dem-pron-oblique-lex-rule & 
  [ SYNSEM.LOCAL.CAT.HEAD.CASE abl ].

all-dem-pron-lex-rule := dem-pron-oblique-lex-rule & 
  [ SYNSEM.LOCAL.CAT.HEAD.CASE all ].

ins-dem-pron-lex-rule := dem-pron-oblique-lex-rule & 
  [ SYNSEM.LOCAL.CAT.HEAD.CASE ins ].


;;; 2025-09-30 demonstrative adverbs
demonstr-pron-adv-end-dtr := word-or-lexrule.

demonstr-pron-adv-pref-lex-rule-super := add-only-no-ccont-rule & demonstr-pron-adv-end-dtr & infl-lex-rule &
  [ INFLECTED #infl, 
    DTR demonstr-pron-adv-lex & [ INFLECTED #infl ] ].

tac-pron-adv-lex-rule := demonstr-pron-adv-pref-lex-rule-super & 
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.COG-ST activ-or-more ].

;;; note that this rule will have C-CONT [removed, delaying adding to pp-phrase]
;;; TODO: what is different between a demonstrative adverb and a demonstrative pronoun in oblique case?
demonstr-pron-adv-end-lex-rule-super := add-only-no-ccont-rule & infl-lex-rule & 
  [ SYNSEM.NON-LOCAL [ CRF.LIST < >, CRF-H.LIST < > ], 
    DTR demonstr-pron-adv-end-dtr,
    INFLECTED [ NUM_CASE-OR-POSS-FLAG + ] ].

loc-dem-adv-lex-rule := demonstr-pron-adv-end-lex-rule-super & 
  [ SYNSEM.LOCAL.CAT.HEAD.CASE loc ].

abl-dem-adv-lex-rule := demonstr-pron-adv-end-lex-rule-super & 
  [ SYNSEM.LOCAL.CAT.HEAD.CASE abl ].

all-dem-adv-lex-rule := demonstr-pron-adv-end-lex-rule-super & 
  [ SYNSEM.LOCAL.CAT.HEAD.CASE all ].

;;; 2025-03-25 infostr

infostr-dislocated-phrase := narrow-focus &
  [ SYNSEM [ LOCAL.CAT [ MC +,
                         VAL.SUBJ < > ],
             NON-LOCAL.QUE.LIST < > ],
    C-CONT [ RELS.LIST < >,
             HCONS.LIST < >,
             ICONS.LIST < info-str & #icons &
                          [ IARG1 #clause,
                            IARG2 #index ] > ],
    HEAD-DTR.SYNSEM.LOCAL [ CAT [ MC -,
                                  HEAD verb ],
                            CONT.HOOK [ INDEX #clause,
                                        CLAUSE-KEY #clause ] ],
    NON-HEAD-DTR.SYNSEM [ LIGHT -,
                          LOCAL [ CAT.HEAD +np,
                                  CONT.HOOK [ INDEX #index,
                                              ICONS-KEY #icons ] ] ] ].

infostr-head-filler-phrase := nc-head-filler-phrase & infostr-dislocated-phrase & head-initial &
  [ SYNSEM.R-PERIPH +,
    HEAD-DTR.SYNSEM [ R-PERIPH -,
                      LOCAL.CAT.VAL.SUBJ olist ],
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.ICONS-KEY focus ].

extracted-subj-phrase := basic-extracted-subj-phrase &
  [ C-CONT [ RELS.LIST < >,
             HCONS.LIST < >,
             ICONS.LIST < > ],
    HEAD-DTR.SYNSEM [ R-PERIPH -,
                      LOCAL.CAT.VAL [ SUBJ.FIRST.LOCAL local &
                                                       [ CONT.HOOK.ICONS-KEY focus-or-topic ],
                                      COMPS < > ],
                      NON-LOCAL.SLASH.LIST < > ],
    SYNSEM.LOCAL.CAT.HEAD verb ].

;;; 2025-04-02 there seem to be some more lightweight option:
;;; make [ NON-LOCAL.COREF-IND ref-ind ] a unique pointer
;;;non-local :+ [ COREF-IND ref-ind ].
;;; NOTE: you might actually still need two (CRF, CRF-H)
;;; OR: solve when combined; note: CRF will include something *to be passed*
;;; so for VP, its CRF should be the subject where its clause is the complement
;;; for NP, its CRF should be the subject whose clause it is in.
;;; non-cl-head-comp: [ HEAD.XARG #ind, DTR.CRF #ind ]
;;; cl-head-comp, [ XARG #ind, DTR(COMPS).CRF #ind ]
;;; adj-scop: [ HEAD.XARG #ind, DTR.CRF #ind ]
;;; problem: XARG of v inside scopal adj cannot be retrieved

;;; if use CRF-H and CRF, then 
;;; lexically: V: [ CRF #ind, XARG #ind ]
;;; non-cl-head-comp & adj-int: [ CRF #ind, HEAD.CRF #ind, DTR.CRF #ind ]
;;; cl-head-comp: [ CRF #ind, HEAD.CRF #ind, DTR.CRF-H #ind ]
;;; adj-scop :+ [ [ CRF-H #ind-h, #CRF #ind ], HEAD [ CRF-H #ind-h, CRF #ind] , DTR.CRF-H #ind ] 

;;; CRF should have ref-ind only
non-local :+ [ CRF append-list, 
               CRF-H append-list ].

coord-phrase :+ 
  [ SYNSEM.NON-LOCAL [ CRF-H.APPEND < #crf-h1, #crf-h2>, 
                       CRF.APPEND < #crf1, #crf2 > ],
    LCOORD-DTR.SYNSEM.NON-LOCAL [ CRF-H #crf-h1, CRF #crf1 ],
    RCOORD-DTR.SYNSEM.NON-LOCAL [ CRF-H #crf-h2, CRF #crf2 ] ].

coord-phrase :+
  [ SYNSEM.LOCAL.CRF-UP [ OR < #cu1, #cu2 > ], 
    LCOORD-DTR.SYNSEM.LOCAL.CRF-UP #cu1, 
    RCOORD-DTR.SYNSEM.LOCAL.CRF-UP #cu2 ].

same-crf-binary-phrase := basic-binary-phrase & 
  [ SYNSEM.NON-LOCAL [ CRF-H.APPEND < #crf-h1, #crf-h2>, 
                       CRF.APPEND < #crf1, #crf2 > ],
    ARGS.FIRST.SYNSEM.NON-LOCAL [ CRF-H #crf-h1, CRF #crf1 ],
    ARGS.REST.FIRST.SYNSEM.NON-LOCAL [ CRF-H #crf-h2, CRF #crf2 ] ].

; headed-same-crf-binary-phrase := 

same-crf-unary-phrase := unary-phrase &
  [ SYNSEM.NON-LOCAL [ CRF-H #crf-h, CRF #crf ],
    ARGS < [ SYNSEM.NON-LOCAL [ CRF-H #crf-h, CRF #crf ] ] > ].


basic-head-spec-phrase :+ same-crf-binary-phrase.

; head-spec-phrase :+ same-crf-binary-phrase.

basic-head-comp-phrase :+ same-crf-binary-phrase.

basic-head-opt-comp-phrase :+ 
  [ SYNSEM.NON-LOCAL [ CRF-H.APPEND < #crf-h2, #crf-h1 >, CRF #crf ],
    ARGS < [ SYNSEM [ NON-LOCAL [ CRF-H #crf-h1, CRF #crf ], 
                      LOCAL.CAT.VAL.COMPS.FIRST.NON-LOCAL [ CRF-H #crf-h2 ] ] ] > ].

basic-head-opt-comp-phrase :+ 
  [ SYNSEM.LOCAL.CAT.VAL.INCORP-N #incorp-n, 
    ARGS < [ SYNSEM.LOCAL.CAT.VAL.INCORP-N #incorp-n ] > ].

basic-head-opt-subj-phrase :+ 
  [ SYNSEM.NON-LOCAL [ CRF-H.APPEND < #crf-h2, #crf-h1 >, CRF #crf ],
    ARGS < [ SYNSEM [ NON-LOCAL [ CRF-H #crf-h1, CRF #crf ], 
                      LOCAL.CAT.VAL.SUBJ.FIRST.NON-LOCAL [ CRF-H #crf-h2] ] ] > ].

head-adj-int-phrase :+ same-crf-binary-phrase.
  ; [ SYNSEM.LOCAL.CRF-UP #crfup, 
  ;   HEAD-DTR.SYNSEM.LOCAL.CRF-UP #crfup ].

adj-head-int-phrase :+ same-crf-binary-phrase.
  ; [ SYNSEM.LOCAL.CRF-UP #crfup, 
  ;   HEAD-DTR.SYNSEM.LOCAL.CRF-UP #crfup ].

;;; CCH 2025-11-15 temporary solution to avoid massive rewrite
headed-phrase :+ 
  [ SYNSEM.LOCAL.CRF-UP #crfup, 
    HEAD-DTR.SYNSEM.LOCAL.CRF-UP #crfup ].

incorp-adj-head-phrase :+ same-crf-binary-phrase.

incorp-head-adj-phrase :+ same-crf-binary-phrase.

bare-np-phrase :+ same-crf-unary-phrase.

np1-bottom-coord-rule :+ [ SYNSEM.NON-LOCAL [ CRF-H #crf-h, CRF #crf ],
                             ARGS < [ SYNSEM.NON-LOCAL [ CRF-H #crf-h, CRF #crf ] ] > ].
vp1-bottom-coord-rule :+ [ SYNSEM.NON-LOCAL [ CRF-H.LIST < >, CRF #crf ],
                             ARGS < [ SYNSEM.NON-LOCAL [ CRF #crf ] ] > ].
adj1-bottom-coord-rule :+ [ SYNSEM.NON-LOCAL [ CRF-H.LIST < >, CRF #crf ],
                             ARGS < [ SYNSEM.NON-LOCAL [ CRF #crf ] ] > ].

insitu-int-cl :+ same-crf-unary-phrase.

decl-head-subj-phrase :+ same-crf-binary-phrase.

; head-subj-phrase :+ same-crf-binary-phrase.

;;; TODO: this very much looks like some head feature (seem to be a +vj feature).
local-min :+ [ CRF-UP logical-or ].

;;; 2025-03-30
;;; at the S level, move all CRF-H into CRF after the CRF has been cleaned
;;; This is for the main clause of the clausal complement, so [ HEAD.MOD < > ].
;;; clausal modifiers probably should not go here? 
;;; but their subj/obj will be marked with CRF-H. So they will have some separate rule.
;;; but they are also [ HEAD.MOD < > ] before the attach-mod-cl. 
;;; Probably go for CRF instead, with crf-h-unary always applied (but wasted).

crf-h-unary-phrase := unary-phrase & 
  [ SYNSEM [ LOCAL [ CAT #cat, COORD -, CRF-UP.BOOL + ], 
             NON-LOCAL [ CRF #crf, 
                         CRF-H.LIST < >, 
                         QUE #que, 
                         SLASH #slash, 
                         REL #rel ] ], 
    C-CONT [ HOOK #hook, 
             RELS.LIST < >, 
             HCONS.LIST < >, 
             ICONS.LIST < > ], 
    ARGS.FIRST.SYNSEM [ LOCAL [ CAT #cat & [ HEAD verb & [ MOD < > ], 
                                             VAL [ SUBJ < >, COMPS < > ] ], 
                                CONT.HOOK #hook, 
                                COORD - ], 
                        NON-LOCAL [ CRF-H #crf & [ LIST cons ], 
                                    CRF.LIST < >, 
                                    QUE #que, 
                                    SLASH #slash, 
                                    REL #rel ] ] ].

;;; 2025-03-30 crf
;;; note that we cannot expect adj-head-scop-phrase to always take nonempty CRF-H.
;;; good thing is that there should be at most one element in CRF-H.
;;; TODO: probably want to avoid that something directly comes here before crf-unary-phrase.
;;; but temporarily leave it like this before seeing any problems.

nocrf-adj-head-scop-phrase := adj-head-scop-phrase & 
  [ SYNSEM.NON-LOCAL [ CRF-H #crf-h, CRF.LIST < > ], 
    NON-HEAD-DTR.SYNSEM.NON-LOCAL [ CRF.LIST < >, CRF-H.LIST < > ], 
    HEAD-DTR.SYNSEM.NON-LOCAL [ CRF-H #crf-h, CRF.LIST < > ] ].

crf-adj-head-scop-phrase := adj-head-scop-phrase & 
  [ SYNSEM.NON-LOCAL [ CRF-H #crf-h, CRF.LIST < > ], 
    NON-HEAD-DTR.SYNSEM.NON-LOCAL [ CRF.LIST < #index >, CRF-H.LIST < > ], 
    HEAD-DTR.SYNSEM [ LOCAL.CONT.HOOK.XARG #index, 
                      NON-LOCAL [ CRF-H #crf-h, CRF.LIST < > ] ] ].

;;; 2025-11-14 relax CRF-H.LIST < > to allow head-opt-subj with something in it to pass
gap :+ [ NON-LOCAL [ CRF.LIST < > ] ].

;;; 2025-11-15 relax CRF-H.LIST < > to allow basic-head-opt-comp with something in it to pass
unexpressed :+ [ NON-LOCAL [ CRF.LIST < > ] ].

;;; 2025-03-30
;;; at the S level, when there is something inside CRF, link it with the subject
;;; but note that this should be done before any scopal mod of S takes place; otherwise, 
;;; the XARG will be hidden
;;; 2025-03-31 NOTE: need to relax this in the future because of -qqu

crf-unary-phrase := unary-phrase & 
  [ SYNSEM [ LOCAL [ CAT #cat, COORD - ], 
             NON-LOCAL [ CRF.LIST #crf, 
                         CRF-H #crfh, 
                         QUE #que, 
                         SLASH #slash, 
                         REL #rel ] ], 
    C-CONT [ HOOK #hook, 
             RELS.LIST < >, 
             HCONS.LIST < >, 
             ICONS.LIST < > ], 
    ARGS.FIRST.SYNSEM [ LOCAL [ CAT #cat & [ HEAD verb & [ PRD na-or-+, MOD < > ], 
                                             VAL [ SUBJ < >, COMPS < > ] ], 
                                CONT.HOOK #hook & [ XARG #index ], 
                                COORD -, 
                                CRF-UP.BOOL - ], 
                        NON-LOCAL [ CRF.LIST < #index . #crf >, 
                                    CRF-H #crfh, 
                                    QUE #que, 
                                    SLASH #slash, 
                                    REL #rel ] ] ].


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Additions for punctuation
;;

synsem-min :+
  [ PUNCT punctuation-min ].

punct-hd := head.

n-pct-hd := head.

headed-phrase :+ [ SYNSEM.LOCAL.CAT.HEAD n-pct-hd ].

punct-word := word &
  [ INFLECTED infl-satisfied,
    SYNSEM [ LOCAL [ CAT [ HEAD punct-hd,
                           VAL [ SUBJ < >, SPR < >, SPEC < >,
                                 COMPS < expressed-synsem &
                                         [ OPT - ] > ] ],
                     CONT [ HOOK.INDEX event-or-ref-index,
			    RELS.LIST < >,
			    HCONS.LIST < >,
			    ICONS.LIST < > ] ],
             NON-LOCAL non-local-none ] ].

punct-mark := avm &
  [ PSF iforce ].

punctuation-min := avm.

;;; 2025-11-14 add MPUNCT to deal with [A verbs, B verbs C verbing, where A and B cannot be conjoined first]
;;; but there still isn't a good enough solution -- should both-ind be included here?
punctuation := punctuation-min &
  [ LPUNCT punct-mark,
    RPUNCT punct-mark, 
    MPUNCT punct-mark ].

quote-punct := punct-mark.
non-quote-punct := punct-mark.
comma-or-clause := non-quote-punct.
comma-or-no-punct := non-quote-punct.
comma-punct := comma-or-clause & comma-or-no-punct.
clause-or-no-punct := non-quote-punct.
clause-punct := comma-or-clause & clause-or-no-punct.
no-punct := comma-or-no-punct & clause-or-no-punct.

base-basic-unary-phrase :+ 
  [ SYNSEM.PUNCT #pct, 
    ARGS.FIRST.SYNSEM.PUNCT #pct ].

basic-binary-phrase :+ 
  [ SYNSEM.PUNCT [ LPUNCT #lpct, 
                   RPUNCT #rpct ], 
    ARGS.FIRST.SYNSEM.PUNCT.LPUNCT #lpct, 
    ARGS.REST.FIRST.SYNSEM.PUNCT.RPUNCT #rpct ].

lex-item :+ 
  [ SYNSEM.PUNCT [ LPUNCT no-punct, 
                   RPUNCT no-punct ] ].

lex-rule :+
  [ SYNSEM.PUNCT [ LPUNCT no-punct, 
                   RPUNCT no-punct ] ].

punct-right-word := punct-word &
  [ SYNSEM [ LOCAL.CAT.POSTHEAD +,
             PUNCT [ LPUNCT no-punct,
                     RPUNCT punct-mark ] ] ].

punct-left-word := punct-word &
  [ SYNSEM [ LOCAL.CAT.POSTHEAD -,
             PUNCT [ LPUNCT punct-mark,
                     RPUNCT no-punct ] ] ].

punct-right-clause-word := punct-right-word &
  [ SYNSEM [ LOCAL.CAT.VAL.COMPS < [ PUNCT.RPUNCT clause-or-no-punct ] >,
             PUNCT.RPUNCT clause-punct ] ].

pt-comma-le := punct-right-word &
  [ SYNSEM [ LOCAL.CAT.VAL.COMPS < [ PUNCT.RPUNCT no-punct ] >,
             PUNCT [ LPUNCT no-punct,
		     RPUNCT comma-punct ] ] ].

prop-or-comm := iforce.
prop :+ prop-or-comm.
comm := prop-or-comm
"""command""".

pt-period-le := punct-right-clause-word &
  [ SYNSEM.PUNCT.RPUNCT.PSF prop-or-comm ].

pt-qmark-le := punct-right-clause-word &
  [ SYNSEM.PUNCT.RPUNCT.PSF ques ].

pt-bang-le := punct-right-clause-word &
  [ SYNSEM.PUNCT.RPUNCT.PSF prop-or-comm ].

;;; 2025-11-12 CCH
;;; temporary; this prevents fragments (including single words) and meaningless (or undecipherable) quoted utterances.
;;; should be relaxed.
pt-lquote-le := punct-left-word & 
  [ SYNSEM [ PUNCT.LPUNCT quote-punct ] ].

pt-rquote-le := punct-right-word & 
  [ SYNSEM [ PUNCT.RPUNCT quote-punct ] ].

punct-phrase := phrase &
  [ SYNSEM [ LOCAL #local,
	           NON-LOCAL #nonlocal,
	           LIGHT #light,
             MODIFIED #modif, 
             PUNCT [ LPUNCT #lpct,
                     RPUNCT #rpct] ],
    PT-DTR.SYNSEM.LOCAL.CAT [ HEAD punct-hd,
			                        VAL.COMPS < #synsem > ],
    NONPT-DTR [ INFLECTED #infl,
                SYNSEM #synsem & [ LOCAL #local,
                                  NON-LOCAL #nonlocal,
                                  LIGHT #light & +,
                                  MODIFIED #modif ] ],
    INFLECTED #infl, 
    ARGS.FIRST.SYNSEM.PUNCT.LPUNCT #lpct, 
    ARGS.REST.FIRST.SYNSEM.PUNCT.RPUNCT #rpct ].

punct-right-rule := punct-phrase &
 [ PT-DTR #ptdtr & [ SYNSEM.LOCAL.CAT.POSTHEAD + ],
   NONPT-DTR #nonptdtr,
   ARGS < #nonptdtr, #ptdtr > ].

punct-left-rule := punct-phrase &
 [ PT-DTR #ptdtr & [ SYNSEM.LOCAL.CAT.POSTHEAD - ],
   NONPT-DTR #nonptdtr,
   ARGS < #ptdtr, #nonptdtr > ].

basic-binary-phrase :+ 
  [ SYNSEM.PUNCT [ LPUNCT #lpct, 
                   RPUNCT #rpct ], 
    ARGS < [ SYNSEM.PUNCT.LPUNCT #lpct ],
           [ SYNSEM.PUNCT.RPUNCT #rpct ] > ].

basic-head-subj-phrase :+ 
  [ ARGS < [ SYNSEM.PUNCT.RPUNCT no-punct ], 
           [ SYNSEM.PUNCT.LPUNCT no-punct ]  > ].

basic-unary-phrase :+ 
  [ SYNSEM.PUNCT #pct, 
    ARGS.FIRST.SYNSEM.PUNCT #pct ].

l-periph-minus-basic-unary-phrase :+ 
  [ SYNSEM.PUNCT #pct, 
    ARGS.FIRST.SYNSEM.PUNCT #pct ].
;;
;; End additions for punctuation
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

root-synsem := phr-synsem & 
  [ NON-LOCAL non-local-none & [ CRF.LIST < > ],
    LOCAL [ COORD -,
            CONT.HOOK.INDEX.E.MOOD matrix_mood,
            CAT [ VAL [ SUBJ < >,
                        COMPS < > ],
                  MC +,
                  HEAD +vj & [ PRD na-or-+ ] ] ] ].

;;; 2025-11-14 CCH add all the constraints, including [ MC + ], to avoid it from getting 
;;; applied to MOOD&SF-less clausal modifiers; but after trial this is also not enough
;;; The main reason is that we don't know what kind of MC we want CNTP to get
imp-head-opt-subj-phrase :+ 
  [ SYNSEM.LOCAL.CAT.MC #mc & +,
    HEAD-DTR.SYNSEM.LOCAL.CAT.MC #mc ].

;;; TODO: what about TAM?
tassa-lex := base-transitive-verb-lex & 
  [ SYNSEM [ LOCAL [ CAT [ HEAD [ PRD na-or-+, 
                                  INIT + ],
                       VAL [ SUBJ < [ LOCAL.CAT.HEAD.CASE abs, 
                                      NON-LOCAL non-local-none & [ CRF.LIST < >, 
                                          CRF-H.LIST < > ] ] >, 
                             COMPS < [ LOCAL.CAT.HEAD.CASE abs, 
                                       NON-LOCAL non-local-none & [ CRF.LIST < >, 
                                          CRF-H.LIST < > ],
                                       OPT - ] >, 
                             SPR < >,  
                             --KEYCOMP non-synsem ], 
                       MC + ], 
                   CONT.HOOK.INDEX.SF prop ],
             NON-LOCAL non-local-none & [ CRF.LIST < >, 
                                          CRF-H.LIST < > ] ] ].

headed-phrase :+ 
  [ SYNSEM.PUNCT.MPUNCT #mpunct, 
    HEAD-DTR.SYNSEM.PUNCT.MPUNCT #mpunct ].

wh-q-verb-lex := basic-verb-lex-super & aspect-rule-dtr & tense-rule-dtr & basic-intransitive-lex-item & non-mod-lex-item & basic-wh-word-lex & norm-hook-lex-item & non-conjp-word & 
  [ SYNSEM [ LOCAL [ CAT [ VAL [ SUBJ < #subj >, 
                                 COMPS < >, 
                                 SPR < >, 
                                 SPEC < >, 
                                 --KEYCOMP non-synsem ] ], 
                     CONT [ HOOK.XARG #xarg, 
                            RELS.LIST.REST [ FIRST noun-relation & 
                                                    [ LBL #larg, 
                                                      ARG0 #obj ], 
                                             REST.FIRST quant-relation &
                                                    [ PRED "wh_q_rel",
                                                      ARG0 #obj,
                                                      RSTR #harg ] ], 
                            HCONS.LIST < qeq & [ HARG #harg,
                                                 LARG #larg ] > ] ], 
             NON-LOCAL [ SLASH.LIST < >, 
                         REL.LIST < >, 
                         CRF.LIST < >, 
                         CRF-H.LIST < >, 
                         QUE.LIST < #obj > ], 
             LKEYS.KEYREL event-relation ], 
    ARG-ST.FIRST #subj & 
                  [ LOCAL [ CAT cat-sat & [ VAL [ SPR < >, 
                                                  COMPS < > ] ], 
                            CONT.HOOK.INDEX #xarg ] ], 
    INFLECTED [ TENSE-FLAG -,
                V_END-OR-V_END_NEG-FLAG -,
                CL_Q_TRANS_V-VERB-OR-CL_TRANS_V-VERB-FLAG na-or--,
                TI_NNIK_FLAG na-or--, 
                TRANS_VALCHG-FLAG na-or--,
                NEG_V_END_FLAG na-or-- ] ].

su-lex := wh-q-verb-lex & 
  [ SYNSEM.LOCAL.CONT.RELS.LIST < [ ARG2 #obj ], 
                                  [ PRED "_thing_n_rel",  
                                    ARG0 #obj ], 
                                  [ ] > ].

;;; CCH 2025-11-16 TODO: this might be adjective?
qanuq-it-lex := wh-q-verb-lex & 
  [ SYNSEM.LOCAL.CONT.RELS.LIST < [ LBL #lbl ], 
                                  [ PRED "_property_n_rel", 
                                    ARG0 #obj ], 
                                  [ ],
                                  arg12-ev-relation & 
                                      [ PRED "prpstn_to_prop_rel", 
                                        ARG1 #lbl, 
                                        ARG2 #obj ] > ].